<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>kube-controller分析(五)-QuotaController-v1.5.2 | fankangbest</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">kube-controller分析(五)-QuotaController-v1.5.2</h1><a id="logo" href="/.">fankangbest</a><p class="description">多听，少说，接受每一个人的责难，但是保留自己的最后裁决。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">kube-controller分析(五)-QuotaController-v1.5.2</h1><div class="post-meta">Jan 2, 2018<span> | </span><span class="category"><a href="/categories/容器虚拟化/">容器虚拟化</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p>本次分析将介绍ResourceQuotaController。之前我们已经介绍过Kubernetes如何管理配额，但当发生删除操作时，无需经过比较配额，直接删除即可，或者，系统配额与实际情况不一致的情况，这些，都需要一种机制来矫，而这个机制就是ResourceQuotaController。</p>
<h2 id="ResourceQuotaController"><a href="#ResourceQuotaController" class="headerlink" title="ResourceQuotaController"></a>ResourceQuotaController</h2><p>ResourceQuotaController定义在/pkg/controller/resourcequota/resource_quota_controller.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ResourceQuotaController is responsible for tracking quota usage status in the system</span></div><div class="line"><span class="keyword">type</span> ResourceQuotaController <span class="keyword">struct</span> &#123;</div><div class="line">	<span class="comment">// Must have authority to list all resources in the system, and update quota status</span></div><div class="line">	kubeClient clientset.Interface</div><div class="line">	<span class="comment">// An index of resource quota objects by namespace</span></div><div class="line">	rqIndexer cache.Indexer</div><div class="line">	<span class="comment">// Watches changes to all resource quota</span></div><div class="line">	rqController *cache.Controller</div><div class="line">	<span class="comment">// ResourceQuota objects that need to be synchronized</span></div><div class="line">	queue workqueue.RateLimitingInterface</div><div class="line">	<span class="comment">// missingUsageQueue holds objects that are missing the initial usage informatino</span></div><div class="line">	missingUsageQueue workqueue.RateLimitingInterface</div><div class="line">	<span class="comment">// To allow injection of syncUsage for testing.</span></div><div class="line">	syncHandler <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">error</span></span></div><div class="line">	// <span class="title">function</span> <span class="title">that</span> <span class="title">controls</span> <span class="title">full</span> <span class="title">recalculation</span> <span class="title">of</span> <span class="title">quota</span> <span class="title">usage</span></div><div class="line">	<span class="title">resyncPeriod</span> <span class="title">controller</span>.<span class="title">ResyncPeriodFunc</span></div><div class="line">	// <span class="title">knows</span> <span class="title">how</span> <span class="title">to</span> <span class="title">calculate</span> <span class="title">usage</span></div><div class="line">	<span class="title">registry</span> <span class="title">quota</span>.<span class="title">Registry</span></div><div class="line">	// <span class="title">controllers</span> <span class="title">monitoring</span> <span class="title">to</span> <span class="title">notify</span> <span class="title">for</span> <span class="title">replenishment</span></div><div class="line">	<span class="title">replenishmentControllers</span> []<span class="title">cache</span>.<span class="title">ControllerInterface</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体字段含义如下：</p>
<ol>
<li>kubeClient: kubernetes的client；</li>
<li>rqIndexer：存储resource quota用；</li>
<li>rqController: resource quota的controller；</li>
<li>queue: 缓存待处理的quota的key；</li>
<li>missingUsageQueue: 缓存Used字段未初始化的quota；</li>
<li>syncHandler：处理key所对应的quota的方法；</li>
<li>registry: quota的registry，可以使用registry.Evaluators()来获取所有的evaluator；</li>
<li>replenishmentControllers: 处理删除，更新后需要进行quota更新的操作。</li>
</ol>
<p>可以通过NewResourceQuotaController()生成ResourceQuotaController()：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewResourceQuotaController</span><span class="params">(options *ResourceQuotaControllerOptions)</span> *<span class="title">ResourceQuotaController</span></span> &#123;</div><div class="line">	<span class="comment">// build the resource quota controller</span></div><div class="line">	rq := &amp;ResourceQuotaController&#123;</div><div class="line">		kubeClient:               options.KubeClient,</div><div class="line">		queue:                    workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">"resourcequota_primary"</span>),</div><div class="line">		missingUsageQueue:        workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">"resourcequota_priority"</span>),</div><div class="line">		resyncPeriod:             options.ResyncPeriod,</div><div class="line">		registry:                 options.Registry,</div><div class="line">		replenishmentControllers: []cache.ControllerInterface&#123;&#125;,</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> options.KubeClient != <span class="literal">nil</span> &amp;&amp; options.KubeClient.Core().RESTClient().GetRateLimiter() != <span class="literal">nil</span> &#123;</div><div class="line">		metrics.RegisterMetricAndTrackRateLimiterUsage(<span class="string">"resource_quota_controller"</span>, options.KubeClient.Core().RESTClient().GetRateLimiter())</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// set the synchronization handler</span></div><div class="line">	rq.syncHandler = rq.syncResourceQuotaFromKey</div><div class="line"></div><div class="line">	<span class="comment">// build the controller that observes quota</span></div><div class="line">	rq.rqIndexer, rq.rqController = cache.NewIndexerInformer(</div><div class="line">		&amp;cache.ListWatch&#123;</div><div class="line">			ListFunc: <span class="function"><span class="keyword">func</span><span class="params">(options api.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</div><div class="line">				<span class="keyword">return</span> rq.kubeClient.Core().ResourceQuotas(api.NamespaceAll).List(options)</div><div class="line">			&#125;,</div><div class="line">			WatchFunc: <span class="function"><span class="keyword">func</span><span class="params">(options api.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</div><div class="line">				<span class="keyword">return</span> rq.kubeClient.Core().ResourceQuotas(api.NamespaceAll).Watch(options)</div><div class="line">			&#125;,</div><div class="line">		&#125;,</div><div class="line">		&amp;api.ResourceQuota&#123;&#125;,</div><div class="line">		rq.resyncPeriod(),</div><div class="line">		cache.ResourceEventHandlerFuncs&#123;</div><div class="line">			AddFunc: rq.addQuota,</div><div class="line">			UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, cur <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">				<span class="comment">// We are only interested in observing updates to quota.spec to drive updates to quota.status.</span></div><div class="line">				<span class="comment">// We ignore all updates to quota.Status because they are all driven by this controller.</span></div><div class="line">				<span class="comment">// IMPORTANT:</span></div><div class="line">				<span class="comment">// We do not use this function to queue up a full quota recalculation.  To do so, would require</span></div><div class="line">				<span class="comment">// us to enqueue all quota.Status updates, and since quota.Status updates involve additional queries</span></div><div class="line">				<span class="comment">// that cannot be backed by a cache and result in a full query of a namespace's content, we do not</span></div><div class="line">				<span class="comment">// want to pay the price on spurious status updates.  As a result, we have a separate routine that is</span></div><div class="line">				<span class="comment">// responsible for enqueue of all resource quotas when doing a full resync (enqueueAll)</span></div><div class="line">				oldResourceQuota := old.(*api.ResourceQuota)</div><div class="line">				curResourceQuota := cur.(*api.ResourceQuota)</div><div class="line">				<span class="keyword">if</span> quota.Equals(curResourceQuota.Spec.Hard, oldResourceQuota.Spec.Hard) &#123;</div><div class="line">					<span class="keyword">return</span></div><div class="line">				&#125;</div><div class="line">				rq.addQuota(curResourceQuota)</div><div class="line">			&#125;,</div><div class="line">			<span class="comment">// This will enter the sync loop and no-op, because the controller has been deleted from the store.</span></div><div class="line">			<span class="comment">// Note that deleting a controller immediately after scaling it to 0 will not work. The recommended</span></div><div class="line">			<span class="comment">// way of achieving this is by performing a `stop` operation on the controller.</span></div><div class="line">			DeleteFunc: rq.enqueueResourceQuota,</div><div class="line">		&#125;,</div><div class="line">		cache.Indexers&#123;<span class="string">"namespace"</span>: cache.MetaNamespaceIndexFunc&#125;,</div><div class="line">	)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, groupKindToReplenish := <span class="keyword">range</span> options.GroupKindsToReplenish &#123;</div><div class="line">		controllerOptions := &amp;ReplenishmentControllerOptions&#123;</div><div class="line">			GroupKind:    groupKindToReplenish,</div><div class="line">			ResyncPeriod: options.ReplenishmentResyncPeriod,</div><div class="line">			<span class="comment">//***Fankang***//</span></div><div class="line">			<span class="comment">//***ReplenishentFunc，即rq.replenishQuota***//</span></div><div class="line">			ReplenishmentFunc: rq.replenishQuota,</div><div class="line">		&#125;</div><div class="line">		replenishmentController, err := options.ControllerFactory.NewController(controllerOptions)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			glog.Warningf(<span class="string">"quota controller unable to replenish %s due to %v, changes only accounted during full resync"</span>, groupKindToReplenish, err)</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			rq.replenishmentControllers = <span class="built_in">append</span>(rq.replenishmentControllers, replenishmentController)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> rq</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>NewResourceQuotaController()流程如下：</p>
<ol>
<li>生成ResourceQuotaController；</li>
<li>填充ResourceQuotaController的syncHandler为rq.syncResourceQuotaFromKey；</li>
<li>生成quota的NewIndexerInformer，并把indexer和controller赋值给rq.rqIndexer, rq.rqController；<br> 3.1 AddFunc为rq.addQuota()<br> 3.2 UpdateFunc为rq.addQuota()<br> 3.3 DeleteFunc为rq.enqueueResourceQuota()</li>
<li>生成replenishmentControllers(依据传入的资源列表生成多个replenishmentController)。</li>
</ol>
<h3 id="ResourceQuotaController-Run"><a href="#ResourceQuotaController-Run" class="headerlink" title="ResourceQuotaController::Run()"></a>ResourceQuotaController::Run()</h3><p>每个controller必须定义Run()方法，ResourceQuotaController也不例外：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Run begins quota controller using the specified number of workers</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rq *ResourceQuotaController)</span> <span class="title">Run</span><span class="params">(workers <span class="keyword">int</span>, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</div><div class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</div><div class="line">	<span class="keyword">go</span> rq.rqController.Run(stopCh)</div><div class="line">	<span class="comment">// the controllers that replenish other resources to respond rapidly to state changes</span></div><div class="line">	<span class="comment">//***启动replenishmentController***//</span></div><div class="line">	<span class="keyword">for</span> _, replenishmentController := <span class="keyword">range</span> rq.replenishmentControllers &#123;</div><div class="line">		<span class="keyword">go</span> replenishmentController.Run(stopCh)</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// the workers that chug through the quota calculation backlog</span></div><div class="line">	<span class="comment">//***启动workers***//</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</div><div class="line">		<span class="keyword">go</span> wait.Until(rq.worker(rq.queue), time.Second, stopCh)</div><div class="line">		<span class="keyword">go</span> wait.Until(rq.worker(rq.missingUsageQueue), time.Second, stopCh)</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// the timer for how often we do a full recalculation across all quotas</span></div><div class="line">	<span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; rq.enqueueAll() &#125;, rq.resyncPeriod(), stopCh)</div><div class="line">	&lt;-stopCh</div><div class="line">	glog.Infof(<span class="string">"Shutting down ResourceQuotaController"</span>)</div><div class="line">	rq.queue.ShutDown()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Run()的流程如下：</p>
<ol>
<li>启动rqController，这些关于quota的变化都会同步到rqIndexer中；</li>
<li>启动rq.replenishmentControllers中的replenishmentController；</li>
<li>启动workers个worker消费queue中的内容；</li>
<li>启动workers个worker消费missingUsageQueue中的内容；</li>
<li>启动定时检查所有quota的流程；</li>
<li>监听stopCh。</li>
</ol>
<p>所以，只有给stopCh信号，Run()才会退出。</p>
<h3 id="ResourceQuotaController-worker"><a href="#ResourceQuotaController-worker" class="headerlink" title="ResourceQuotaController::worker()"></a>ResourceQuotaController::worker()</h3><p>再来看下worker：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// worker runs a worker thread that just dequeues items, processes them, and marks them done.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rq *ResourceQuotaController)</span> <span class="title">worker</span><span class="params">(queue workqueue.RateLimitingInterface)</span> <span class="title">func</span><span class="params">()</span></span> &#123;</div><div class="line">	workFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</div><div class="line">		<span class="comment">//***从queue中获取key***//</span></div><div class="line">		key, quit := queue.Get()</div><div class="line">		<span class="keyword">if</span> quit &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">defer</span> queue.Done(key)</div><div class="line">		<span class="comment">//***处理key***//</span></div><div class="line">		err := rq.syncHandler(key.(<span class="keyword">string</span>))</div><div class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">			queue.Forget(key)</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span></div><div class="line">		&#125;</div><div class="line">		utilruntime.HandleError(err)</div><div class="line">		queue.AddRateLimited(key)</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">for</span> &#123;</div><div class="line">			<span class="comment">//***执行workFunc()***//</span></div><div class="line">			<span class="keyword">if</span> quit := workFunc(); quit &#123;</div><div class="line">				glog.Infof(<span class="string">"resource quota controller worker shutting down"</span>)</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>worker的流程就是从queue中获取key，然后调用syncHandler()处理该key，syncHandler()就是rq.syncResourceQuotaFromKey()。</p>
<h3 id="ResourceQuotaController-syncResourceQuotaFromKey"><a href="#ResourceQuotaController-syncResourceQuotaFromKey" class="headerlink" title="ResourceQuotaController::syncResourceQuotaFromKey()"></a>ResourceQuotaController::syncResourceQuotaFromKey()</h3><p>syncResourceQuotaFromKey()从rqIndexer中通过key获取quota，然后调用syncResourceQuota()处理quota。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// syncResourceQuotaFromKey syncs a quota key</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rq *ResourceQuotaController)</span> <span class="title">syncResourceQuotaFromKey</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</div><div class="line">	startTime := time.Now()</div><div class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		glog.V(<span class="number">4</span>).Infof(<span class="string">"Finished syncing resource quota %q (%v)"</span>, key, time.Now().Sub(startTime))</div><div class="line">	&#125;()</div><div class="line">	<span class="comment">//***从rqIndexer中获取key对应的quota***//</span></div><div class="line">	obj, exists, err := rq.rqIndexer.GetByKey(key)</div><div class="line">	<span class="keyword">if</span> !exists &#123;</div><div class="line">		glog.Infof(<span class="string">"Resource quota has been deleted %v"</span>, key)</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		glog.Infof(<span class="string">"Unable to retrieve resource quota %v from store: %v"</span>, key, err)</div><div class="line">		rq.queue.Add(key)</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	quota := *obj.(*api.ResourceQuota)</div><div class="line">	<span class="comment">//***调用syncResourceQuota()***//</span></div><div class="line">	<span class="keyword">return</span> rq.syncResourceQuota(quota)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ResourceQuotaController-syncResourceQuota"><a href="#ResourceQuotaController-syncResourceQuota" class="headerlink" title="ResourceQuotaController::syncResourceQuota()"></a>ResourceQuotaController::syncResourceQuota()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// syncResourceQuota runs a complete sync of resource quota status across all known kinds</span></div><div class="line"><span class="comment">//***Fankang***//</span></div><div class="line"><span class="comment">//***处理resourceQuota***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rq *ResourceQuotaController)</span> <span class="title">syncResourceQuota</span><span class="params">(resourceQuota api.ResourceQuota)</span> <span class="params">(err error)</span></span> &#123;</div><div class="line">	<span class="comment">// quota is dirty if any part of spec hard limits differs from the status hard limits</span></div><div class="line">	dirty := !api.Semantic.DeepEqual(resourceQuota.Spec.Hard, resourceQuota.Status.Hard)</div><div class="line"></div><div class="line">	<span class="comment">// dirty tracks if the usage status differs from the previous sync,</span></div><div class="line">	<span class="comment">// if so, we send a new usage with latest status</span></div><div class="line">	<span class="comment">// if this is our first sync, it will be dirty by default, since we need track usage</span></div><div class="line">	<span class="comment">//***Fankang***//</span></div><div class="line">	<span class="comment">//***dirty表示是否有必要更新***//</span></div><div class="line">	dirty = dirty || (resourceQuota.Status.Hard == <span class="literal">nil</span> || resourceQuota.Status.Used == <span class="literal">nil</span>)</div><div class="line"></div><div class="line">	used := api.ResourceList&#123;&#125;</div><div class="line">	<span class="keyword">if</span> resourceQuota.Status.Used != <span class="literal">nil</span> &#123;</div><div class="line">		used = quota.Add(api.ResourceList&#123;&#125;, resourceQuota.Status.Used)</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//***Fankang***//</span></div><div class="line">	<span class="comment">//***status.hard必须和spec.hard相等***//</span></div><div class="line">	hardLimits := quota.Add(api.ResourceList&#123;&#125;, resourceQuota.Spec.Hard)</div><div class="line"></div><div class="line">	<span class="comment">//***计算新的资源使用量***//</span></div><div class="line">	newUsage, err := quota.CalculateUsage(resourceQuota.Namespace, resourceQuota.Spec.Scopes, hardLimits, rq.registry)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> key, value := <span class="keyword">range</span> newUsage &#123;</div><div class="line">		used[key] = value</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// ensure set of used values match those that have hard constraints</span></div><div class="line">	hardResources := quota.ResourceNames(hardLimits)</div><div class="line">	used = quota.Mask(used, hardResources)</div><div class="line"></div><div class="line">	<span class="comment">// Create a usage object that is based on the quota resource version that will handle updates</span></div><div class="line">	<span class="comment">// by default, we preserve the past usage observation, and set hard to the current spec</span></div><div class="line">	usage := api.ResourceQuota&#123;</div><div class="line">		ObjectMeta: api.ObjectMeta&#123;</div><div class="line">			Name:            resourceQuota.Name,</div><div class="line">			Namespace:       resourceQuota.Namespace,</div><div class="line">			ResourceVersion: resourceQuota.ResourceVersion,</div><div class="line">			Labels:          resourceQuota.Labels,</div><div class="line">			Annotations:     resourceQuota.Annotations&#125;,</div><div class="line">		Status: api.ResourceQuotaStatus&#123;</div><div class="line">			Hard: hardLimits,</div><div class="line">			Used: used,</div><div class="line">		&#125;,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	dirty = dirty || !quota.Equals(usage.Status.Used, resourceQuota.Status.Used)</div><div class="line"></div><div class="line">	<span class="comment">// there was a change observed by this controller that requires we update quota</span></div><div class="line">	<span class="comment">//***如果需要更新，则更新***//</span></div><div class="line">	<span class="keyword">if</span> dirty &#123;</div><div class="line">		_, err = rq.kubeClient.Core().ResourceQuotas(usage.Namespace).UpdateStatus(&amp;usage)</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>syncResourceQuota()会计算quota对应namespace下资源的使用情况，如果需要更新，则更新quota。<br>所以，经过syncResourceQuota()处理过的quota就和实际情况保持一致了。</p>
<h3 id="ResourceQuotaController-addQuota"><a href="#ResourceQuotaController-addQuota" class="headerlink" title="ResourceQuotaController::addQuota()"></a>ResourceQuotaController::addQuota()</h3><p>接着来看IndexerInformer中使用到的addQuota()：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***把quota的key加入到queue中***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rq *ResourceQuotaController)</span> <span class="title">addQuota</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">	key, err := controller.KeyFunc(obj)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		glog.Errorf(<span class="string">"Couldn't get key for object %+v: %v"</span>, obj, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	resourceQuota := obj.(*api.ResourceQuota)</div><div class="line"></div><div class="line">	<span class="comment">// if we declared an intent that is not yet captured in status (prioritize it)</span></div><div class="line">	<span class="keyword">if</span> !api.Semantic.DeepEqual(resourceQuota.Spec.Hard, resourceQuota.Status.Hard) &#123;</div><div class="line">		rq.missingUsageQueue.Add(key)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// if we declared a constraint that has no usage (which this controller can calculate, prioritize it)</span></div><div class="line">	<span class="keyword">for</span> constraint := <span class="keyword">range</span> resourceQuota.Status.Hard &#123;</div><div class="line">		<span class="keyword">if</span> _, usageFound := resourceQuota.Status.Used[constraint]; !usageFound &#123;</div><div class="line">			matchedResources := []api.ResourceName&#123;constraint&#125;</div><div class="line"></div><div class="line">			<span class="keyword">for</span> _, evaluator := <span class="keyword">range</span> rq.registry.Evaluators() &#123;</div><div class="line">				<span class="keyword">if</span> intersection := quota.Intersection(evaluator.MatchesResources(), matchedResources); <span class="built_in">len</span>(intersection) != <span class="number">0</span> &#123;</div><div class="line">					rq.missingUsageQueue.Add(key)</div><div class="line">					<span class="keyword">return</span></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// no special priority, go in normal recalc queue</span></div><div class="line">	rq.queue.Add(key)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>addQuota()会依据情况把quota的key加入到missingUsageQueue或queue中。只要该quota发生了变动，那对该quota进行处理。</p>
<h3 id="ResourceQuotaController-enqueueResourceQuota"><a href="#ResourceQuotaController-enqueueResourceQuota" class="headerlink" title="ResourceQuotaController::enqueueResourceQuota()"></a>ResourceQuotaController::enqueueResourceQuota()</h3><p>enqueueResourceQuota()只把quota的key加入到queue中。因为不是首次quota处理已经由addQuota()完成，即到enqueueResourceQuota()处理时Used初始化已经完成。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// obj could be an *api.ResourceQuota, or a DeletionFinalStateUnknown marker item.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rq *ResourceQuotaController)</span> <span class="title">enqueueResourceQuota</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">	key, err := controller.KeyFunc(obj)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		glog.Errorf(<span class="string">"Couldn't get key for object %+v: %v"</span>, obj, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	rq.queue.Add(key)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ResourceQuotaController-enqueueAll"><a href="#ResourceQuotaController-enqueueAll" class="headerlink" title="ResourceQuotaController::enqueueAll()"></a>ResourceQuotaController::enqueueAll()</h3><p>关于ResourceQuotaController，最后来看下定时处理全部quota的方法enqueueAll():<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// enqueueAll is called at the fullResyncPeriod interval to force a full recalculation of quota usage statistics</span></div><div class="line"><span class="comment">//***Fankang***//</span></div><div class="line"><span class="comment">//***把所有的key加入到queue中***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rq *ResourceQuotaController)</span> <span class="title">enqueueAll</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">defer</span> glog.V(<span class="number">4</span>).Infof(<span class="string">"Resource quota controller queued all resource quota for full calculation of usage"</span>)</div><div class="line">	<span class="keyword">for</span> _, k := <span class="keyword">range</span> rq.rqIndexer.ListKeys() &#123;</div><div class="line">		rq.queue.Add(k)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>enqueueAll()会把rqIndexer中所有的key取出，放到queue中处理。</p>
<h2 id="replenishmentControllerFactory"><a href="#replenishmentControllerFactory" class="headerlink" title="replenishmentControllerFactory"></a>replenishmentControllerFactory</h2><p>replenishmentControllerFactory定义在/pkg/controller/resourcequota/replenishment_controller.go中，负责某些资源的Delete或Update检查，进而触发更新quota的操作。ResourceQuotaController是通过调用NewController()来生成replenishmentController的。</p>
<h3 id="replenishmentControllerFactory-NewController"><a href="#replenishmentControllerFactory-NewController" class="headerlink" title="replenishmentControllerFactory::NewController()"></a>replenishmentControllerFactory::NewController()</h3><p>NewController()会根据不同的资源生成不同的controller。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *replenishmentControllerFactory)</span> <span class="title">NewController</span><span class="params">(options *ReplenishmentControllerOptions)</span> <span class="params">(result cache.ControllerInterface, err error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> r.kubeClient != <span class="literal">nil</span> &amp;&amp; r.kubeClient.Core().RESTClient().GetRateLimiter() != <span class="literal">nil</span> &#123;</div><div class="line">		metrics.RegisterMetricAndTrackRateLimiterUsage(<span class="string">"replenishment_controller"</span>, r.kubeClient.Core().RESTClient().GetRateLimiter())</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">switch</span> options.GroupKind &#123;</div><div class="line">	<span class="keyword">case</span> api.Kind(<span class="string">"Pod"</span>):</div><div class="line">		<span class="keyword">if</span> r.sharedInformerFactory != <span class="literal">nil</span> &#123;</div><div class="line">			result, err = controllerFor(api.Resource(<span class="string">"pods"</span>), r.sharedInformerFactory, cache.ResourceEventHandlerFuncs&#123;</div><div class="line">				UpdateFunc: PodReplenishmentUpdateFunc(options),</div><div class="line">				DeleteFunc: ObjectReplenishmentDeleteFunc(options),</div><div class="line">			&#125;)</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">		result = informers.NewPodInformer(r.kubeClient, options.ResyncPeriod())</div><div class="line">	<span class="keyword">case</span> api.Kind(<span class="string">"Service"</span>):</div><div class="line">		<span class="comment">// TODO move to informer when defined</span></div><div class="line">		_, result = cache.NewInformer(</div><div class="line">			&amp;cache.ListWatch&#123;</div><div class="line">				ListFunc: <span class="function"><span class="keyword">func</span><span class="params">(options api.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</div><div class="line">					<span class="keyword">return</span> r.kubeClient.Core().Services(api.NamespaceAll).List(options)</div><div class="line">				&#125;,</div><div class="line">				WatchFunc: <span class="function"><span class="keyword">func</span><span class="params">(options api.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</div><div class="line">					<span class="keyword">return</span> r.kubeClient.Core().Services(api.NamespaceAll).Watch(options)</div><div class="line">				&#125;,</div><div class="line">			&#125;,</div><div class="line">			&amp;api.Service&#123;&#125;,</div><div class="line">			options.ResyncPeriod(),</div><div class="line">			cache.ResourceEventHandlerFuncs&#123;</div><div class="line">				UpdateFunc: ServiceReplenishmentUpdateFunc(options),</div><div class="line">				DeleteFunc: ObjectReplenishmentDeleteFunc(options),</div><div class="line">			&#125;,</div><div class="line">		)</div><div class="line">	<span class="keyword">case</span> api.Kind(<span class="string">"ReplicationController"</span>):</div><div class="line">		<span class="comment">// TODO move to informer when defined</span></div><div class="line">		_, result = cache.NewInformer(</div><div class="line">			&amp;cache.ListWatch&#123;</div><div class="line">				ListFunc: <span class="function"><span class="keyword">func</span><span class="params">(options api.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</div><div class="line">					<span class="keyword">return</span> r.kubeClient.Core().ReplicationControllers(api.NamespaceAll).List(options)</div><div class="line">				&#125;,</div><div class="line">				WatchFunc: <span class="function"><span class="keyword">func</span><span class="params">(options api.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</div><div class="line">					<span class="keyword">return</span> r.kubeClient.Core().ReplicationControllers(api.NamespaceAll).Watch(options)</div><div class="line">				&#125;,</div><div class="line">			&#125;,</div><div class="line">			&amp;api.ReplicationController&#123;&#125;,</div><div class="line">			options.ResyncPeriod(),</div><div class="line">			cache.ResourceEventHandlerFuncs&#123;</div><div class="line">				DeleteFunc: ObjectReplenishmentDeleteFunc(options),</div><div class="line">			&#125;,</div><div class="line">		)</div><div class="line">	<span class="keyword">case</span> api.Kind(<span class="string">"PersistentVolumeClaim"</span>):</div><div class="line">		<span class="keyword">if</span> r.sharedInformerFactory != <span class="literal">nil</span> &#123;</div><div class="line">			result, err = controllerFor(api.Resource(<span class="string">"persistentvolumeclaims"</span>), r.sharedInformerFactory, cache.ResourceEventHandlerFuncs&#123;</div><div class="line">				DeleteFunc: ObjectReplenishmentDeleteFunc(options),</div><div class="line">			&#125;)</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// TODO (derekwaynecarr) remove me when we can require a sharedInformerFactory in all code paths...</span></div><div class="line">		_, result = cache.NewInformer(</div><div class="line">			&amp;cache.ListWatch&#123;</div><div class="line">				ListFunc: <span class="function"><span class="keyword">func</span><span class="params">(options api.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</div><div class="line">					<span class="keyword">return</span> r.kubeClient.Core().PersistentVolumeClaims(api.NamespaceAll).List(options)</div><div class="line">				&#125;,</div><div class="line">				WatchFunc: <span class="function"><span class="keyword">func</span><span class="params">(options api.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</div><div class="line">					<span class="keyword">return</span> r.kubeClient.Core().PersistentVolumeClaims(api.NamespaceAll).Watch(options)</div><div class="line">				&#125;,</div><div class="line">			&#125;,</div><div class="line">			&amp;api.PersistentVolumeClaim&#123;&#125;,</div><div class="line">			options.ResyncPeriod(),</div><div class="line">			cache.ResourceEventHandlerFuncs&#123;</div><div class="line">				DeleteFunc: ObjectReplenishmentDeleteFunc(options),</div><div class="line">			&#125;,</div><div class="line">		)</div><div class="line">	<span class="keyword">case</span> api.Kind(<span class="string">"Secret"</span>):</div><div class="line">		<span class="comment">// TODO move to informer when defined</span></div><div class="line">		_, result = cache.NewInformer(</div><div class="line">			&amp;cache.ListWatch&#123;</div><div class="line">				ListFunc: <span class="function"><span class="keyword">func</span><span class="params">(options api.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</div><div class="line">					<span class="keyword">return</span> r.kubeClient.Core().Secrets(api.NamespaceAll).List(options)</div><div class="line">				&#125;,</div><div class="line">				WatchFunc: <span class="function"><span class="keyword">func</span><span class="params">(options api.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</div><div class="line">					<span class="keyword">return</span> r.kubeClient.Core().Secrets(api.NamespaceAll).Watch(options)</div><div class="line">				&#125;,</div><div class="line">			&#125;,</div><div class="line">			&amp;api.Secret&#123;&#125;,</div><div class="line">			options.ResyncPeriod(),</div><div class="line">			cache.ResourceEventHandlerFuncs&#123;</div><div class="line">				DeleteFunc: ObjectReplenishmentDeleteFunc(options),</div><div class="line">			&#125;,</div><div class="line">		)</div><div class="line">	<span class="keyword">case</span> api.Kind(<span class="string">"ConfigMap"</span>):</div><div class="line">		<span class="comment">// TODO move to informer when defined</span></div><div class="line">		_, result = cache.NewInformer(</div><div class="line">			&amp;cache.ListWatch&#123;</div><div class="line">				ListFunc: <span class="function"><span class="keyword">func</span><span class="params">(options api.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</div><div class="line">					<span class="keyword">return</span> r.kubeClient.Core().ConfigMaps(api.NamespaceAll).List(options)</div><div class="line">				&#125;,</div><div class="line">				WatchFunc: <span class="function"><span class="keyword">func</span><span class="params">(options api.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</div><div class="line">					<span class="keyword">return</span> r.kubeClient.Core().ConfigMaps(api.NamespaceAll).Watch(options)</div><div class="line">				&#125;,</div><div class="line">			&#125;,</div><div class="line">			&amp;api.ConfigMap&#123;&#125;,</div><div class="line">			options.ResyncPeriod(),</div><div class="line">			cache.ResourceEventHandlerFuncs&#123;</div><div class="line">				DeleteFunc: ObjectReplenishmentDeleteFunc(options),</div><div class="line">			&#125;,</div><div class="line">		)</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, NewUnhandledGroupKindError(options.GroupKind)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> result, err</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这些controller的关键是UpdateFunc，DeleteFunc的设置。以”pod”为例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// PodReplenishmentUpdateFunc will replenish if the old pod was quota tracked but the new is not</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">PodReplenishmentUpdateFunc</span><span class="params">(options *ReplenishmentControllerOptions)</span> <span class="title">func</span><span class="params">(oldObj, newObj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(oldObj, newObj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">		oldPod := oldObj.(*api.Pod)</div><div class="line">		newPod := newObj.(*api.Pod)</div><div class="line">		<span class="comment">//***Fankang***//</span></div><div class="line">		<span class="comment">//***QuotaPod()检查pod是否需要被计算***//</span></div><div class="line">		<span class="keyword">if</span> core.QuotaPod(oldPod) &amp;&amp; !core.QuotaPod(newPod) &#123;</div><div class="line">			options.ReplenishmentFunc(options.GroupKind, newPod.Namespace, oldPod)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>PodReplenishmentUpdateFunc()为UpdateFunc，PodReplenishmentUpdateFunc()会检查oldPod和newPod的，如果oldPod需要纳入计算，但newPod不需要纳入计算了，则触发ReplenishmentFunc()。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ObjectReplenenishmentDeleteFunc will replenish on every delete</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">ObjectReplenishmentDeleteFunc</span><span class="params">(options *ReplenishmentControllerOptions)</span> <span class="title">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">		metaObject, err := meta.Accessor(obj)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			tombstone, ok := obj.(cache.DeletedFinalStateUnknown)</div><div class="line">			<span class="keyword">if</span> !ok &#123;</div><div class="line">				glog.Errorf(<span class="string">"replenishment controller could not get object from tombstone %+v, could take up to %v before quota is replenished"</span>, obj, options.ResyncPeriod())</div><div class="line">				utilruntime.HandleError(err)</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">			metaObject, err = meta.Accessor(tombstone.Obj)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				glog.Errorf(<span class="string">"replenishment controller tombstone contained object that is not a meta %+v, could take up to %v before quota is replenished"</span>, tombstone.Obj, options.ResyncPeriod())</div><div class="line">				utilruntime.HandleError(err)</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		options.ReplenishmentFunc(options.GroupKind, metaObject.GetNamespace(), <span class="literal">nil</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ObjectReplenishmentDeleteFunc()为DeleteFunc，ObjectReplenishmentDeleteFunc()也针对触发ReplenishmentFunc()。</p>
<h3 id="ReplenishmentFunc"><a href="#ReplenishmentFunc" class="headerlink" title="ReplenishmentFunc()"></a>ReplenishmentFunc()</h3><p>ReplenishmentFunc()其实就是rq.replenishQuota()，从下面代码(定义在resource_quota_controller.go的NewResourceQuotaController()中)可以看出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">controllerOptions := &amp;ReplenishmentControllerOptions&#123;</div><div class="line">	GroupKind:    groupKindToReplenish,</div><div class="line">	ResyncPeriod: options.ReplenishmentResyncPeriod,</div><div class="line">	<span class="comment">//***Fankang***//</span></div><div class="line">	<span class="comment">//***ReplenishentFunc，即rq.replenishQuota***//</span></div><div class="line">	ReplenishmentFunc: rq.replenishQuota,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ResourceQuotaController-replenishQuota"><a href="#ResourceQuotaController-replenishQuota" class="headerlink" title="ResourceQuotaController::replenishQuota()"></a>ResourceQuotaController::replenishQuota()</h3><p>replenishQuota()会依据资源找出需要更新的quota，并调用enqueueResourceQuota()触发处理动作。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// replenishQuota is a replenishment function invoked by a controller to notify that a quota should be recalculated</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rq *ResourceQuotaController)</span> <span class="title">replenishQuota</span><span class="params">(groupKind unversioned.GroupKind, namespace <span class="keyword">string</span>, object runtime.Object)</span></span> &#123;</div><div class="line">	<span class="comment">// check if the quota controller can evaluate this kind, if not, ignore it altogether...</span></div><div class="line">	evaluators := rq.registry.Evaluators()</div><div class="line">	evaluator, found := evaluators[groupKind]</div><div class="line">	<span class="keyword">if</span> !found &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// check if this namespace even has a quota...</span></div><div class="line">	indexKey := &amp;api.ResourceQuota&#123;&#125;</div><div class="line">	indexKey.Namespace = namespace</div><div class="line">	resourceQuotas, err := rq.rqIndexer.Index(<span class="string">"namespace"</span>, indexKey)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		glog.Errorf(<span class="string">"quota controller could not find ResourceQuota associated with namespace: %s, could take up to %v before a quota replenishes"</span>, namespace, rq.resyncPeriod())</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(resourceQuotas) == <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// only queue those quotas that are tracking a resource associated with this kind.</span></div><div class="line">	matchedResources := evaluator.MatchesResources()</div><div class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> resourceQuotas &#123;</div><div class="line">		resourceQuota := resourceQuotas[i].(*api.ResourceQuota)</div><div class="line">		resourceQuotaResources := quota.ResourceNames(resourceQuota.Status.Hard)</div><div class="line">		<span class="comment">//***Fankang***//</span></div><div class="line">		<span class="comment">//***如果resourceQuotas有涉及，则更新***//</span></div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(quota.Intersection(matchedResources, resourceQuotaResources)) &gt; <span class="number">0</span> &#123;</div><div class="line">			<span class="comment">// <span class="doctag">TODO:</span> make this support targeted replenishment to a specific kind, right now it does a full recalc on that quota.</span></div><div class="line">			rq.enqueueResourceQuota(resourceQuota)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="controllermanager"><a href="#controllermanager" class="headerlink" title="controllermanager"></a>controllermanager</h2><p>最后来看下controllermanager中对于ResourceQuotaController的调用，代码在/cmd/kube-controller-manager/app/controllermanager.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">resourceQuotaControllerClient := client(<span class="string">"resourcequota-controller"</span>)</div><div class="line">	resourceQuotaRegistry := quotainstall.NewRegistry(resourceQuotaControllerClient, sharedInformers)</div><div class="line">	groupKindsToReplenish := []unversioned.GroupKind&#123;</div><div class="line">		api.Kind(<span class="string">"Pod"</span>),</div><div class="line">		api.Kind(<span class="string">"Service"</span>),</div><div class="line">		api.Kind(<span class="string">"ReplicationController"</span>),</div><div class="line">		api.Kind(<span class="string">"PersistentVolumeClaim"</span>),</div><div class="line">		api.Kind(<span class="string">"Secret"</span>),</div><div class="line">		api.Kind(<span class="string">"ConfigMap"</span>),</div><div class="line">	&#125;</div><div class="line">	resourceQuotaControllerOptions := &amp;resourcequotacontroller.ResourceQuotaControllerOptions&#123;</div><div class="line">		KubeClient:                resourceQuotaControllerClient,</div><div class="line">		ResyncPeriod:              controller.StaticResyncPeriodFunc(s.ResourceQuotaSyncPeriod.Duration),</div><div class="line">		Registry:                  resourceQuotaRegistry,</div><div class="line">		ControllerFactory:         resourcequotacontroller.NewReplenishmentControllerFactory(sharedInformers, resourceQuotaControllerClient),</div><div class="line">		ReplenishmentResyncPeriod: ResyncPeriod(s),</div><div class="line">		GroupKindsToReplenish:     groupKindsToReplenish,</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">go</span> resourcequotacontroller.NewResourceQuotaController(resourceQuotaControllerOptions).Run(<span class="keyword">int</span>(s.ConcurrentResourceQuotaSyncs), wait.NeverStop)</div><div class="line">	time.Sleep(wait.Jitter(s.ControllerStartInterval.Duration, ControllerStartJitter))</div></pre></td></tr></table></figure></p>
<p>所以，可以看出kube-controller监控了”Pod”, “Service”, “ReplicationController”, “PersistentVolumeClaim”, “Secret”, “ConfigMap”这些资源的Update和Delete操作，因为这些资源都和quota相关。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://fankangbest.github.com/2018/01/02/kube-controller分析(五)-QuotaController-v1-5-2/" data-id="cje7r6ee0004rb4qsdb1yrggb" class="article-share-link">分享</a><div class="tags"><a href="/tags/kubernetes/">kubernetes</a><a href="/tags/kubernetes-v1-5-2/">kubernetes-v1.5.2</a></div><div class="post-nav"><a href="/2018/01/04/Kubernetes-Ingress使用-v1-5-2/" class="pre">Kubernetes-Ingress使用-v1.5.2</a><a href="/2018/01/01/runc源码分析(二)-namespace设置流程-v1-0-0-rc2/" class="next">runc源码分析(二)-namespace设置流程-v1.0.0-rc2</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://fankangbest.github.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/GO语言/">GO语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/存储虚拟化/">存储虚拟化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/容器虚拟化/">容器虚拟化</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/containerd-v0-2-4/" style="font-size: 15px;">containerd-v0.2.4</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/kubernetes-v1-5-2/" style="font-size: 15px;">kubernetes-v1.5.2</a> <a href="/tags/GO语言/" style="font-size: 15px;">GO语言</a> <a href="/tags/containerd/" style="font-size: 15px;">containerd</a> <a href="/tags/docker-v1-12-3/" style="font-size: 15px;">docker-v1.12.3</a> <a href="/tags/gRPC/" style="font-size: 15px;">gRPC</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/runc/" style="font-size: 15px;">runc</a> <a href="/tags/runc-v1-0-0-rc2/" style="font-size: 15px;">runc-v1.0.0-rc2</a> <a href="/tags/ceph/" style="font-size: 15px;">ceph</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/02/26/Kubernetes-cni网络调用分析-v1-5-2/">Kubernetes-cni网络调用分析-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/10/Docker命令行分析-load-save-v1-12-3/">Docker命令行分析-load-save-v1.12.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/03/Dockerd的server启动流程分析-v1-12-3/">Dockerd的server启动流程分析-v1.12.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/21/GO语言-切片原理/">GO语言-切片原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/16/Kubernetes-resourceVersion机制分析/">Kubernetes-resourceVersion机制分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/04/Kubernetes-Ingress使用-v1-5-2/">Kubernetes-Ingress使用-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/02/kube-controller分析(五)-QuotaController-v1-5-2/">kube-controller分析(五)-QuotaController-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/01/runc源码分析(二)-namespace设置流程-v1-0-0-rc2/">runc源码分析(二)-namespace设置流程-v1.0.0-rc2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/30/Docker创建spec文件分析-v1-12-3/">Docker创建spec文件分析-v1.12.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/28/Docker工具包分析-archive-v1-12-3/">Docker工具包分析-archive-v1.12.3</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/fankangbest" title="myGithub" target="_blank">myGithub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">fankangbest.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>