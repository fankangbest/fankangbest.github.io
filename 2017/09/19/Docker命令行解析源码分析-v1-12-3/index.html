<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Docker命令行解析源码分析-v1.12.3 | fankangbest</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Docker命令行解析源码分析-v1.12.3</h1><a id="logo" href="/.">fankangbest</a><p class="description">多听，少说，接受每一个人的责难，但是保留自己的最后裁决。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Docker命令行解析源码分析-v1.12.3</h1><div class="post-meta">Sep 19, 2017<span> | </span><span class="category"><a href="/categories/容器虚拟化/">容器虚拟化</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h2 id="Docker命令行"><a href="#Docker命令行" class="headerlink" title="Docker命令行"></a>Docker命令行</h2><p>在使用Docker时，我们通过docker run等命令和dockerd进行交互。目前Docker分为docker和dockerd两个二进制文件，其中docker为客户端；dockerd为server端。本次分析将介绍docker程序是如何解析命令行的。</p>
<h2 id="docker程序入口"><a href="#docker程序入口" class="headerlink" title="docker程序入口"></a>docker程序入口</h2><p>docker程序的入口在/cmd/docker/docker.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// Set terminal emulation based on platform as required.</span></div><div class="line">	stdin, stdout, stderr := term.StdStreams()</div><div class="line"></div><div class="line">	logrus.SetOutput(stderr)</div><div class="line"></div><div class="line">	flag.Merge(flag.CommandLine, clientFlags.FlagSet, commonFlags.FlagSet)</div><div class="line"></div><div class="line">	cobraAdaptor := cobraadaptor.NewCobraAdaptor(clientFlags)</div><div class="line"></div><div class="line">	flag.Usage = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		fmt.Fprint(stdout, <span class="string">"Usage: docker [OPTIONS] COMMAND [arg...]\n       docker [ --help | -v | --version ]\n\n"</span>)</div><div class="line">		fmt.Fprint(stdout, <span class="string">"A self-sufficient runtime for containers.\n\nOptions:\n"</span>)</div><div class="line"></div><div class="line">		flag.CommandLine.SetOutput(stdout)</div><div class="line">		flag.PrintDefaults()</div><div class="line"></div><div class="line">		help := <span class="string">"\nCommands:\n"</span></div><div class="line"></div><div class="line">		dockerCommands := <span class="built_in">append</span>(cli.DockerCommandUsage, cobraAdaptor.Usage()...)</div><div class="line">		<span class="keyword">for</span> _, cmd := <span class="keyword">range</span> sortCommands(dockerCommands) &#123;</div><div class="line">			help += fmt.Sprintf(<span class="string">"    %-10.10s%s\n"</span>, cmd.Name, cmd.Description)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		help += <span class="string">"\nRun 'docker COMMAND --help' for more information on a command."</span></div><div class="line">		fmt.Fprintf(stdout, <span class="string">"%s\n"</span>, help)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	<span class="comment">//***输出version信息***//</span></div><div class="line">	<span class="keyword">if</span> *flVersion &#123;</div><div class="line">		showVersion()</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//***输出help信息***//</span></div><div class="line">	<span class="keyword">if</span> *flHelp &#123;</div><div class="line">		<span class="comment">// if global flag --help is present, regardless of what other options and commands there are,</span></div><div class="line">		<span class="comment">// just print the usage.</span></div><div class="line">		flag.Usage()</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//***生成clientCli，client.NewDockerCli()定义在/api/client/cli.go中***//</span></div><div class="line">	clientCli := client.NewDockerCli(stdin, stdout, stderr, clientFlags)</div><div class="line"></div><div class="line">	<span class="comment">//***New()定义在/cli/cli.go中***//</span></div><div class="line">	c := cli.New(clientCli, NewDaemonProxy(), cobraAdaptor)</div><div class="line">	<span class="comment">//***Run()定义在/cli/cli.go中***//</span></div><div class="line">	<span class="keyword">if</span> err := c.Run(flag.Args()...); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">if</span> sterr, ok := err.(cli.StatusError); ok &#123;</div><div class="line">			<span class="keyword">if</span> sterr.Status != <span class="string">""</span> &#123;</div><div class="line">				fmt.Fprintln(stderr, sterr.Status)</div><div class="line">			&#125;</div><div class="line">			<span class="comment">// StatusError should only be used for errors, and all errors should</span></div><div class="line">			<span class="comment">// have a non-zero exit status, so never exit with 0</span></div><div class="line">			<span class="keyword">if</span> sterr.StatusCode == <span class="number">0</span> &#123;</div><div class="line">				os.Exit(<span class="number">1</span>)</div><div class="line">			&#125;</div><div class="line">			os.Exit(sterr.StatusCode)</div><div class="line">		&#125;</div><div class="line">		fmt.Fprintln(stderr, err)</div><div class="line">		os.Exit(<span class="number">1</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在main()函数中，如果参数为-h或–help，则调用Usage()打印帮助信息；如果参数为-v或–version，则调用showVersion()打印版本信息；否则调用Cli的Run()方法来运行具体命令。<br>可以看出，cli.New(clientCli, NewDaemonProxy(), cobraAdaptor)生成Cli，而clientCli, NewDaemonProxy(), cobraAdaptor都称为handler，所以可以把Cli看成是对多个handler的封装。</p>
<h2 id="clientCli"><a href="#clientCli" class="headerlink" title="clientCli"></a>clientCli</h2><p>在main()中，clientCli通过<br><code>clientCli := client.NewDockerCli(stdin, stdout, stderr, clientFlags)</code>生成。<br>到/api/client/cli.go中来看下NewDockerCli()方法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***生成dockerclient***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDockerCli</span><span class="params">(in io.ReadCloser, out, err io.Writer, clientFlags *cliflags.ClientFlags)</span> *<span class="title">DockerCli</span></span> &#123;</div><div class="line">	cli := &amp;DockerCli&#123;</div><div class="line">		in:      in,</div><div class="line">		out:     out,</div><div class="line">		err:     err,</div><div class="line">		keyFile: clientFlags.Common.TrustKey,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	cli.init = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">		clientFlags.PostParse()</div><div class="line">		cli.configFile = LoadDefaultConfigFile(err)</div><div class="line"></div><div class="line">		<span class="comment">//***调用NewAPIClientFromFlags()，依据flag，生成client***//</span></div><div class="line">		client, err := NewAPIClientFromFlags(clientFlags, cli.configFile)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		cli.client = client</div><div class="line"></div><div class="line">		<span class="keyword">if</span> cli.in != <span class="literal">nil</span> &#123;</div><div class="line">			cli.inFd, cli.isTerminalIn = term.GetFdInfo(cli.in)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> cli.out != <span class="literal">nil</span> &#123;</div><div class="line">			cli.outFd, cli.isTerminalOut = term.GetFdInfo(cli.out)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> cli</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>NewAPIClientFromFlags()定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NewAPIClientFromFlags creates a new APIClient from command line flags</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAPIClientFromFlags</span><span class="params">(clientFlags *cliflags.ClientFlags, configFile *configfile.ConfigFile)</span> <span class="params">(client.APIClient, error)</span></span> &#123;</div><div class="line">	host, err := getServerHost(clientFlags.Common.Hosts, clientFlags.Common.TLSOptions)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> &amp;client.Client&#123;&#125;, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	customHeaders := configFile.HTTPHeaders</div><div class="line">	<span class="keyword">if</span> customHeaders == <span class="literal">nil</span> &#123;</div><div class="line">		customHeaders = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;</div><div class="line">	&#125;</div><div class="line">	customHeaders[<span class="string">"User-Agent"</span>] = clientUserAgent()</div><div class="line"></div><div class="line">	verStr := api.DefaultVersion</div><div class="line">	<span class="keyword">if</span> tmpStr := os.Getenv(<span class="string">"DOCKER_API_VERSION"</span>); tmpStr != <span class="string">""</span> &#123;</div><div class="line">		verStr = tmpStr</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	httpClient, err := newHTTPClient(host, clientFlags.Common.TLSOptions)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> &amp;client.Client&#123;&#125;, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//***client.NewClient()定义在/vendor/src/github.com/docker/engine-api/client/client.go中***//</span></div><div class="line">	<span class="keyword">return</span> client.NewClient(host, verStr, httpClient, customHeaders)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以，可以看出clientCli包含了一个与dockerd打交道的docker client。</p>
<p>那么clientCli怎么可以成为一个handler呢？要知道handler必须实现Command()方法。clientCli的Command()方法定义在/api/client/commands.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Command returns a cli command handler if one exists</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *DockerCli)</span> <span class="title">Command</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">func</span><span class="params">(...<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(...<span class="keyword">string</span>)</span> <span class="title">error</span></span>&#123;</div><div class="line">		<span class="string">"exec"</span>:    cli.CmdExec,</div><div class="line">		<span class="string">"info"</span>:    cli.CmdInfo,</div><div class="line">		<span class="string">"inspect"</span>: cli.CmdInspect,</div><div class="line">		<span class="string">"update"</span>:  cli.CmdUpdate,</div><div class="line">	&#125;[name]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以，clientCli handler会处理exec, info, inspect, update四个子命令。clientCli可以通过Command()方法返回合适的命令处理函数。</p>
<h2 id="NewDaemonProxy"><a href="#NewDaemonProxy" class="headerlink" title="NewDaemonProxy()"></a>NewDaemonProxy()</h2><p>NewDaemonProxy()定义在/cmd/docker/daemon.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> daemonBinary = <span class="string">"dockerd"</span></div><div class="line"></div><div class="line"><span class="comment">// DaemonProxy acts as a cli.Handler to proxy calls to the daemon binary</span></div><div class="line"><span class="keyword">type</span> DaemonProxy <span class="keyword">struct</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// NewDaemonProxy returns a new handler</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDaemonProxy</span><span class="params">()</span> <span class="title">DaemonProxy</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> DaemonProxy&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Command returns a cli command handler if one exists</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p DaemonProxy)</span> <span class="title">Command</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">func</span><span class="params">(...<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(...<span class="keyword">string</span>)</span> <span class="title">error</span></span>&#123;</div><div class="line">		<span class="string">"daemon"</span>: p.CmdDaemon,</div><div class="line">	&#125;[name]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，DaemonProxy是为了兼容旧式”docker daemon”的启动方式，其本质还是调用了dockerd程序。</p>
<h2 id="cobraAdaptor"><a href="#cobraAdaptor" class="headerlink" title="cobraAdaptor"></a>cobraAdaptor</h2><p>cobraAdaptor集成了大部分的docker命令。来看来其生成函数NewCobraAdaptor()，定义在/cli/cobraadaptor/adaptor.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// CobraAdaptor is an adaptor for supporting spf13/cobra commands in the</span></div><div class="line"><span class="comment">// docker/cli framework</span></div><div class="line"><span class="keyword">type</span> CobraAdaptor <span class="keyword">struct</span> &#123;</div><div class="line">	rootCmd   *cobra.Command</div><div class="line">	dockerCli *client.DockerCli</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//***生成新的CobraAdaptor，并向其注册cmd***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCobraAdaptor</span><span class="params">(clientFlags *cliflags.ClientFlags)</span> <span class="title">CobraAdaptor</span></span> &#123;</div><div class="line">	stdin, stdout, stderr := term.StdStreams()</div><div class="line">	dockerCli := client.NewDockerCli(stdin, stdout, stderr, clientFlags)</div><div class="line"></div><div class="line">	<span class="keyword">var</span> rootCmd = &amp;cobra.Command&#123;</div><div class="line">		Use:           <span class="string">"docker [OPTIONS]"</span>,</div><div class="line">		Short:         <span class="string">"A self-sufficient runtime for containers"</span>,</div><div class="line">		SilenceUsage:  <span class="literal">true</span>,</div><div class="line">		SilenceErrors: <span class="literal">true</span>,</div><div class="line">	&#125;</div><div class="line">	rootCmd.SetUsageTemplate(usageTemplate)</div><div class="line">	rootCmd.SetHelpTemplate(helpTemplate)</div><div class="line">	rootCmd.SetFlagErrorFunc(cli.FlagErrorFunc)</div><div class="line">	rootCmd.SetOutput(stdout)</div><div class="line">	rootCmd.AddCommand(</div><div class="line">		node.NewNodeCommand(dockerCli),</div><div class="line">		service.NewServiceCommand(dockerCli),</div><div class="line">		stack.NewStackCommand(dockerCli),</div><div class="line">		stack.NewTopLevelDeployCommand(dockerCli),</div><div class="line">		swarm.NewSwarmCommand(dockerCli),</div><div class="line">		container.NewAttachCommand(dockerCli),</div><div class="line">		container.NewCommitCommand(dockerCli),</div><div class="line">		container.NewCopyCommand(dockerCli),</div><div class="line">		container.NewCreateCommand(dockerCli),</div><div class="line">		container.NewDiffCommand(dockerCli),</div><div class="line">		container.NewExportCommand(dockerCli),</div><div class="line">		container.NewKillCommand(dockerCli),</div><div class="line">		container.NewLogsCommand(dockerCli),</div><div class="line">		container.NewPauseCommand(dockerCli),</div><div class="line">		container.NewPortCommand(dockerCli),</div><div class="line">		container.NewPsCommand(dockerCli),</div><div class="line">		container.NewRenameCommand(dockerCli),</div><div class="line">		container.NewRestartCommand(dockerCli),</div><div class="line">		container.NewRmCommand(dockerCli),</div><div class="line">		container.NewRunCommand(dockerCli),</div><div class="line">		container.NewStartCommand(dockerCli),</div><div class="line">		container.NewStatsCommand(dockerCli),</div><div class="line">		container.NewStopCommand(dockerCli),</div><div class="line">		container.NewTopCommand(dockerCli),</div><div class="line">		container.NewUnpauseCommand(dockerCli),</div><div class="line">		container.NewWaitCommand(dockerCli),</div><div class="line">		image.NewBuildCommand(dockerCli),</div><div class="line">		image.NewHistoryCommand(dockerCli),</div><div class="line">		image.NewImagesCommand(dockerCli),</div><div class="line">		image.NewLoadCommand(dockerCli),</div><div class="line">		image.NewRemoveCommand(dockerCli),</div><div class="line">		image.NewSaveCommand(dockerCli),</div><div class="line">		image.NewPullCommand(dockerCli),</div><div class="line">		image.NewPushCommand(dockerCli),</div><div class="line">		image.NewSearchCommand(dockerCli),</div><div class="line">		image.NewImportCommand(dockerCli),</div><div class="line">		image.NewTagCommand(dockerCli),</div><div class="line">		network.NewNetworkCommand(dockerCli),</div><div class="line">		system.NewEventsCommand(dockerCli),</div><div class="line">		registry.NewLoginCommand(dockerCli),</div><div class="line">		registry.NewLogoutCommand(dockerCli),</div><div class="line">		system.NewVersionCommand(dockerCli),</div><div class="line">		volume.NewVolumeCommand(dockerCli),</div><div class="line">	)</div><div class="line">	plugin.NewPluginCommand(rootCmd, dockerCli)</div><div class="line"></div><div class="line">	rootCmd.PersistentFlags().BoolP(<span class="string">"help"</span>, <span class="string">"h"</span>, <span class="literal">false</span>, <span class="string">"Print usage"</span>)</div><div class="line">	rootCmd.PersistentFlags().MarkShorthandDeprecated(<span class="string">"help"</span>, <span class="string">"please use --help"</span>)</div><div class="line"></div><div class="line">	<span class="keyword">return</span> CobraAdaptor&#123;</div><div class="line">		rootCmd:   rootCmd,</div><div class="line">		dockerCli: dockerCli,</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，CobraAdaptor使用了spf13/cobra命令行管理包。所有的命令都以docker子命令的形式进行管理。</p>
<p>再来看下CobraAdaptor的Command()方法是如何返回合适的方法的：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***找到合适的cmd执行函数，返回的是函数***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c CobraAdaptor)</span> <span class="title">Command</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">func</span><span class="params">(...<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> _, cmd := <span class="keyword">range</span> c.rootCmd.Commands() &#123;</div><div class="line">		<span class="comment">//***Name()返回的是cmd中的use中的内容***//</span></div><div class="line">		<span class="keyword">if</span> cmd.Name() == name &#123;</div><div class="line">			<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(args ...<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">				<span class="keyword">return</span> c.run(name, args)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//***执行相应的cmd处理函数***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c CobraAdaptor)</span> <span class="title">run</span><span class="params">(cmd <span class="keyword">string</span>, args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> err := c.dockerCli.Initialize(); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// Prepend the command name to support normal cobra command delegation</span></div><div class="line">	c.rootCmd.SetArgs(<span class="built_in">append</span>([]<span class="keyword">string</span>&#123;cmd&#125;, args...))</div><div class="line">	<span class="keyword">return</span> c.rootCmd.Execute()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，Command()方法会从子命令中找到合适的命令，然后执行”docker”+子命令+参数的函数。当然，Command()返回的是一个函数。</p>
<h2 id="Cli"><a href="#Cli" class="headerlink" title="Cli"></a>Cli</h2><p>Cli定义在/cli/cli.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***Cli是对多个handler的封装***//</span></div><div class="line"><span class="keyword">type</span> Cli <span class="keyword">struct</span> &#123;</div><div class="line">	Stderr   io.Writer</div><div class="line">	handlers []Handler</div><div class="line">	Usage    <span class="function"><span class="keyword">func</span><span class="params">()</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，Cli封装有多个Handler。再来看Cli的入口，Run()方法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***Cli入口***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *Cli)</span> <span class="title">Run</span><span class="params">(args ...<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(args) &gt; <span class="number">1</span> &#123;</div><div class="line">		command, err := cli.command(args[:<span class="number">2</span>]...)</div><div class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> command(args[<span class="number">2</span>:]...)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> err != errCommandNotFound &#123;</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(args) &gt; <span class="number">0</span> &#123;</div><div class="line">		<span class="comment">//***如docker ps等命令真正执行的地方***//</span></div><div class="line">		<span class="comment">//***获取处理函数***//</span></div><div class="line">		command, err := cli.command(args[<span class="number">0</span>])</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">if</span> err == errCommandNotFound &#123;</div><div class="line">				cli.noSuchCommand(args[<span class="number">0</span>])</div><div class="line">				<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//***执行处理函数***//</span></div><div class="line">		<span class="keyword">return</span> command(args[<span class="number">1</span>:]...)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> cli.CmdHelp()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Run()方法会区分命令中参数的个数，如”docker network create”，则走len(args)&gt;1分支；如”docker ps”， 则走len(args)&gt;0的分支；如果都不符合，则打印帮助信息。<br>Cli通过command()方法获取合适的方法。来看command()的定义：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***根据子命令找到对应的cmd处理函数***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *Cli)</span> <span class="title">command</span><span class="params">(args ...<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">func</span>(...<span class="keyword">string</span>)</span> <span class="title">error</span>, <span class="title">error</span>)</span> &#123;</div><div class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> cli.handlers &#123;</div><div class="line">		<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">//***container, image等相关的cmd处理函数由cobraadaptor负责，其Command()函数定义在/cli/cobraadaptor/adaptor.go中***//</span></div><div class="line">		<span class="keyword">if</span> cmd := c.Command(strings.Join(args, <span class="string">" "</span>)); cmd != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">if</span> ci, ok := c.(Initializer); ok &#123;</div><div class="line">				<span class="keyword">if</span> err := ci.Initialize(); err != <span class="literal">nil</span> &#123;</div><div class="line">					<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> cmd, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, errCommandNotFound</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>command()方法很好理解，轮询Cli中每一个handler，直到有一个handler可以处理该命令行。handler可以处理该命令行，即通过handler的Command()方法可以返回一个正确的函数，而之前介绍过，系统中的三个handler都实现有Command()方法返回命令行对应的处理函数。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次分析了docker的命令行形式。其通过Cli封装了handler，handler实现有Command()方法来返回一个合适的处理函数。这与老版本的docker命令行管理方法来说更进了一步。老版本(v1.8.3)中是通过参数，然后直接通过reflect的GetMethodByName()方法获取处理函数并返回。<br>当然，如果可以直接使用spf13/cobra包来管理命令行那就更好了。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://fankangbest.github.com/2017/09/19/Docker命令行解析源码分析-v1-12-3/" data-id="cjaow4zkg00022gqsnt4pryuk" class="article-share-link">分享</a><div class="tags"><a href="/tags/docker/">docker</a><a href="/tags/docker-v1-12-3/">docker-v1.12.3</a></div><div class="post-nav"><a href="/2017/09/21/apiserver分析(三)-master和genericapiserver-v1-5-2/" class="pre">apiserver分析(三)-master和genericapiserver-v1.5.2</a><a href="/2017/09/18/apiserver分析(二)-authorizer-v1-5-2/" class="next">apiserver分析(二)-authorizer-v1.5.2</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://fankangbest.github.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/GO语言/">GO语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/存储虚拟化/">存储虚拟化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/容器虚拟化/">容器虚拟化</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/containerd-v0-2-4/" style="font-size: 15px;">containerd-v0.2.4</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/docker-v1-12-3/" style="font-size: 15px;">docker-v1.12.3</a> <a href="/tags/GO语言/" style="font-size: 15px;">GO语言</a> <a href="/tags/containerd/" style="font-size: 15px;">containerd</a> <a href="/tags/kubernetes-v1-5-2/" style="font-size: 15px;">kubernetes-v1.5.2</a> <a href="/tags/gRPC/" style="font-size: 15px;">gRPC</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/runc/" style="font-size: 15px;">runc</a> <a href="/tags/runc-v1-0-0-rc2/" style="font-size: 15px;">runc-v1.0.0-rc2</a> <a href="/tags/ceph/" style="font-size: 15px;">ceph</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/12/02/libnetwork源码分析(一)-controller(1)-v1-12-3/">libnetwork源码分析(一)-controller(1)-v1.12.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/30/libnetwork基本概念-v1-12-3/">libnetwork基本概念-v1.12.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/30/Docker容器网络初始化源码分析-v1-12-3/">Docker容器网络初始化源码分析-v1.12.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/26/Docker-reexec机制分析-v1-12-3/">Docker-reexec机制分析-v1.12.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/24/containerd-containerd-shim和runc的依存关系/">containerd,containerd-shim和runc的依存关系</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/22/runc源码分析(一)-create和start流程-v1-0-0-rc2/">runc源码分析(一)-create和start流程-v1.0.0-rc2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/19/containerd-shim源码分析-v0-2-4/">containerd-shim源码分析-v0.2.4</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/19/containerd-container和process-v0-2-4/">containerd-container和process-v0.2.4</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/16/containerd执行流程分析-v0-2-4/">containerd执行流程分析-v0.2.4</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/13/containerd-crt命令行使用-v0-2-4/">containerd-crt命令行使用-v0.2.4</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/fankangbest" title="myGithub" target="_blank">myGithub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">fankangbest.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>