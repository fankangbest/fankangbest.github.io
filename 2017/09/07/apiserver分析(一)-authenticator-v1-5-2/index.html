<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>apiserver分析(一)-authenticator-v1.5.2 | fankangbest</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">apiserver分析(一)-authenticator-v1.5.2</h1><a id="logo" href="/.">fankangbest</a><p class="description">多听，少说，接受每一个人的责难，但是保留自己的最后裁决。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">apiserver分析(一)-authenticator-v1.5.2</h1><div class="post-meta">Sep 7, 2017<span> | </span><span class="category"><a href="/categories/容器虚拟化/">容器虚拟化</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h2 id="什么是Authenticator"><a href="#什么是Authenticator" class="headerlink" title="什么是Authenticator"></a>什么是Authenticator</h2><p>Authenticator负责Kubernetes中对请求进行认证，只有通过认证的请求才会被执行。在Kubernetes中，有BasicAuth, Keystone, X509, Token, ServiceAccount, OIDCIssuer, WebhookToken, AnyToken等认证器。本次分析将介绍Kubernetes是如何管理认证器的，及如何对请求进行认证。</p>
<h2 id="认证器的生成"><a href="#认证器的生成" class="headerlink" title="认证器的生成"></a>认证器的生成</h2><p>认证器的生成在/cmd/kube-apiserver/app/server.go的Run()函数中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***认证器***//</span></div><div class="line">apiAuthenticator, securityDefinitions, err := authenticator.New(authenticator.AuthenticatorConfig&#123;</div><div class="line">    Anonymous:                   s.GenericServerRunOptions.AnonymousAuth,</div><div class="line">    AnyToken:                    s.GenericServerRunOptions.EnableAnyToken,</div><div class="line">    BasicAuthFile:               s.GenericServerRunOptions.BasicAuthFile,</div><div class="line">    ClientCAFile:                s.GenericServerRunOptions.ClientCAFile,</div><div class="line">    TokenAuthFile:               s.GenericServerRunOptions.TokenAuthFile,</div><div class="line">    OIDCIssuerURL:               s.GenericServerRunOptions.OIDCIssuerURL,</div><div class="line">    OIDCClientID:                s.GenericServerRunOptions.OIDCClientID,</div><div class="line">    OIDCCAFile:                  s.GenericServerRunOptions.OIDCCAFile,</div><div class="line">    OIDCUsernameClaim:           s.GenericServerRunOptions.OIDCUsernameClaim,</div><div class="line">    OIDCGroupsClaim:             s.GenericServerRunOptions.OIDCGroupsClaim,</div><div class="line">    ServiceAccountKeyFiles:      s.ServiceAccountKeyFiles,</div><div class="line">    ServiceAccountLookup:        s.ServiceAccountLookup,</div><div class="line">    ServiceAccountTokenGetter:   serviceAccountGetter,</div><div class="line">    KeystoneURL:                 s.GenericServerRunOptions.KeystoneURL,</div><div class="line">    KeystoneCAFile:              s.GenericServerRunOptions.KeystoneCAFile,</div><div class="line">    WebhookTokenAuthnConfigFile: s.WebhookTokenAuthnConfigFile,</div><div class="line">    WebhookTokenAuthnCacheTTL:   s.WebhookTokenAuthnCacheTTL,</div><div class="line">    RequestHeaderConfig:         s.GenericServerRunOptions.AuthenticationRequestHeaderConfig(),</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>所以，接下来看authenticator.New()，定义在/pkg/apiserver/authenticator/authn.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(config AuthenticatorConfig)</span> <span class="params">(authenticator.Request, *spec.SecurityDefinitions, error)</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> authenticators []authenticator.Request</div><div class="line">    securityDefinitions := spec.SecurityDefinitions&#123;&#125;</div><div class="line">    hasBasicAuth := <span class="literal">false</span></div><div class="line">    hasTokenAuth := <span class="literal">false</span></div><div class="line">    <span class="comment">// front-proxy, BasicAuth methods, local first, then remote</span></div><div class="line">    <span class="comment">// Add the front proxy authenticator if requested</span></div><div class="line">    <span class="keyword">if</span> config.RequestHeaderConfig != <span class="literal">nil</span> &#123;</div><div class="line">        requestHeaderAuthenticator, err := headerrequest.NewSecure(</div><div class="line">            config.RequestHeaderConfig.ClientCA,</div><div class="line">            config.RequestHeaderConfig.AllowedClientNames,</div><div class="line">            config.RequestHeaderConfig.UsernameHeaders,</div><div class="line">        )</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</div><div class="line">        &#125;</div><div class="line">        authenticators = <span class="built_in">append</span>(authenticators, requestHeaderAuthenticator)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(config.BasicAuthFile) &gt; <span class="number">0</span> &#123;</div><div class="line">        basicAuth, err := newAuthenticatorFromBasicAuthFile(config.BasicAuthFile)</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</div><div class="line">        &#125;</div><div class="line">        authenticators = <span class="built_in">append</span>(authenticators, basicAuth)</div><div class="line">        hasBasicAuth = <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(config.KeystoneURL) &gt; <span class="number">0</span> &#123;</div><div class="line">        keystoneAuth, err := newAuthenticatorFromKeystoneURL(config.KeystoneURL, config.KeystoneCAFile)</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</div><div class="line">        &#125;</div><div class="line">        authenticators = <span class="built_in">append</span>(authenticators, keystoneAuth)</div><div class="line">        hasBasicAuth = <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// X509 methods</span></div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(config.ClientCAFile) &gt; <span class="number">0</span> &#123;</div><div class="line">        certAuth, err := newAuthenticatorFromClientCAFile(config.ClientCAFile)</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</div><div class="line">        &#125;</div><div class="line">        authenticators = <span class="built_in">append</span>(authenticators, certAuth)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Bearer token methods, local first, then remote</span></div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(config.TokenAuthFile) &gt; <span class="number">0</span> &#123;</div><div class="line">        tokenAuth, err := newAuthenticatorFromTokenFile(config.TokenAuthFile)</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</div><div class="line">        &#125;</div><div class="line">        authenticators = <span class="built_in">append</span>(authenticators, tokenAuth)</div><div class="line">        hasTokenAuth = <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(config.ServiceAccountKeyFiles) &gt; <span class="number">0</span> &#123;</div><div class="line">        serviceAccountAuth, err := newServiceAccountAuthenticator(config.ServiceAccountKeyFiles, config.ServiceAccountLookup, config.ServiceAccountTokenGetter)</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</div><div class="line">        &#125;</div><div class="line">        authenticators = <span class="built_in">append</span>(authenticators, serviceAccountAuth)</div><div class="line">        hasTokenAuth = <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// NOTE(ericchiang): Keep the OpenID Connect after Service Accounts.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// Because both plugins verify JWTs whichever comes first in the union experiences</span></div><div class="line">    <span class="comment">// cache misses for all requests using the other. While the service account plugin</span></div><div class="line">    <span class="comment">// simply returns an error, the OpenID Connect plugin may query the provider to</span></div><div class="line">    <span class="comment">// update the keys, causing performance hits.</span></div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(config.OIDCIssuerURL) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(config.OIDCClientID) &gt; <span class="number">0</span> &#123;</div><div class="line">        oidcAuth, err := newAuthenticatorFromOIDCIssuerURL(config.OIDCIssuerURL, config.OIDCClientID, config.OIDCCAFile, config.OIDCUsernameClaim, config.OIDCGroupsClaim)</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</div><div class="line">        &#125;</div><div class="line">        authenticators = <span class="built_in">append</span>(authenticators, oidcAuth)</div><div class="line">        hasTokenAuth = <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(config.WebhookTokenAuthnConfigFile) &gt; <span class="number">0</span> &#123;</div><div class="line">        webhookTokenAuth, err := newWebhookTokenAuthenticator(config.WebhookTokenAuthnConfigFile, config.WebhookTokenAuthnCacheTTL)</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</div><div class="line">        &#125;</div><div class="line">        authenticators = <span class="built_in">append</span>(authenticators, webhookTokenAuth)</div><div class="line">        hasTokenAuth = <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// always add anytoken last, so that every other token authenticator gets to try first</span></div><div class="line">    <span class="keyword">if</span> config.AnyToken &#123;</div><div class="line">        authenticators = <span class="built_in">append</span>(authenticators, bearertoken.New(anytoken.AnyTokenAuthenticator&#123;&#125;))</div><div class="line">        hasTokenAuth = <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> hasBasicAuth &#123;</div><div class="line">        securityDefinitions[<span class="string">"HTTPBasic"</span>] = &amp;spec.SecurityScheme&#123;</div><div class="line">            SecuritySchemeProps: spec.SecuritySchemeProps&#123;</div><div class="line">                Type:        <span class="string">"basic"</span>,</div><div class="line">                Description: <span class="string">"HTTP Basic authentication"</span>,</div><div class="line">            &#125;,</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> hasTokenAuth &#123;</div><div class="line">        securityDefinitions[<span class="string">"BearerToken"</span>] = &amp;spec.SecurityScheme&#123;</div><div class="line">            SecuritySchemeProps: spec.SecuritySchemeProps&#123;</div><div class="line">                Type:        <span class="string">"apiKey"</span>,</div><div class="line">                Name:        <span class="string">"authorization"</span>,</div><div class="line">                In:          <span class="string">"header"</span>,</div><div class="line">                Description: <span class="string">"Bearer Token authentication"</span>,</div><div class="line">            &#125;,</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(authenticators) == <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">if</span> config.Anonymous &#123;</div><div class="line">            <span class="keyword">return</span> anonymous.NewAuthenticator(), &amp;securityDefinitions, <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">switch</span> <span class="built_in">len</span>(authenticators) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, &amp;securityDefinitions, <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    authenticator := union.New(authenticators...)</div><div class="line">    <span class="comment">//***GroupAdder定义在/pkg/auth/group***//</span></div><div class="line">    <span class="comment">//***所以，antenticator调用的是GroupAdder的AuthenticateRequest()***//</span></div><div class="line">    authenticator = group.NewGroupAdder(authenticator, []<span class="keyword">string</span>&#123;user.AllAuthenticated&#125;)</div><div class="line">    <span class="keyword">if</span> config.Anonymous &#123;</div><div class="line">        <span class="comment">// If the authenticator chain returns an error, return an error (don't consider a bad bearer token anonymous).</span></div><div class="line">        authenticator = union.NewFailOnError(authenticator, anonymous.NewAuthenticator())</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> authenticator, &amp;securityDefinitions, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>New()会根据kube-apiserver的参数来生成各个认证器，并把认证器放在authenticators变量中。比如，如果指定了–experimental-keystone-url，则就会生成keystoneAuthenticator。这里要强调的是unionAuthenticator可以封装多个认证器，关于unionAuthenticator，稍后分析。</p>
<p>这里还要涉及到一个概念，GroupAdder，封装了authenticator，定义在/pkg/auth/group/group_adder.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// GroupAdder adds groups to an authenticated user.Info</span></div><div class="line"><span class="keyword">type</span> GroupAdder <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="comment">// Authenticator is delegated to make the authentication decision</span></div><div class="line">    Authenticator authenticator.Request</div><div class="line">    <span class="comment">// Groups are additional groups to add to the user.Info from a successful authentication</span></div><div class="line">    Groups []<span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// NewGroupAdder wraps a request authenticator, and adds the specified groups to the returned user when authentication succeeds</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGroupAdder</span><span class="params">(auth authenticator.Request, groups []<span class="keyword">string</span>)</span> <span class="title">authenticator</span>.<span class="title">Request</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> &amp;GroupAdder&#123;auth, groups&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>New()会根据kube-apiserver的参数来生成各个认证器，并把认证器放在authenticators变量中。比如，如果指定了–experimental-keystone-url，则就会生成keystoneAuthenticator。这里要强调的是unionAuthenticator可以封装多个认证器，关于unionAuthenticator，稍后分析。</p>
<p>这里还要涉及到一个概念，GroupAdder，封装了authenticator，定义在/pkg/auth/group/group_adder.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// GroupAdder adds groups to an authenticated user.Info</span></div><div class="line"><span class="keyword">type</span> GroupAdder <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="comment">// Authenticator is delegated to make the authentication decision</span></div><div class="line">    Authenticator authenticator.Request</div><div class="line">    <span class="comment">// Groups are additional groups to add to the user.Info from a successful authentication</span></div><div class="line">    Groups []<span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// NewGroupAdder wraps a request authenticator, and adds the specified groups to the returned user when authentication succeeds</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGroupAdder</span><span class="params">(auth authenticator.Request, groups []<span class="keyword">string</span>)</span> <span class="title">authenticator</span>.<span class="title">Request</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> &amp;GroupAdder&#123;auth, groups&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以，kube-apiserver的认证器就一个GroupAdder，GroupAdder定义有认证的入口：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***实现AuthenticateRequest()***//</span></div><div class="line"><span class="comment">//***返回user.DefaultInfo***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GroupAdder)</span> <span class="title">AuthenticateRequest</span><span class="params">(req *http.Request)</span> <span class="params">(user.Info, <span class="keyword">bool</span>, error)</span></span> &#123;</div><div class="line">    u, ok, err := g.Authenticator.AuthenticateRequest(req)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || !ok &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ok, err</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> &amp;user.DefaultInfo&#123;</div><div class="line">        Name:   u.GetName(),</div><div class="line">        UID:    u.GetUID(),</div><div class="line">        Groups: <span class="built_in">append</span>(u.GetGroups(), g.Groups...),</div><div class="line">        Extra:  u.GetExtra(),</div><div class="line">    &#125;, <span class="literal">true</span>, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>GroupAdder的AuthenticateRequest()会调用unionAuthenticator的AuthenticateRequest()对请求进行认证，得到user信息之后返回。</p>
<p>关于Group，定义在/pkg/auth/user/user.go中，authenticator.New()传入的是AllAuthenticated，估计是为了把该用户标记为已经通过认证。但现在还不知道user为什么要这么分类。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// well-known user and group names</span></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    SystemPrivilegedGroup = <span class="string">"system:masters"</span></div><div class="line">    NodesGroup            = <span class="string">"system:nodes"</span></div><div class="line">    AllUnauthenticated    = <span class="string">"system:unauthenticated"</span></div><div class="line">    AllAuthenticated      = <span class="string">"system:authenticated"</span></div><div class="line">    Anonymous     = <span class="string">"system:anonymous"</span></div><div class="line">    APIServerUser = <span class="string">"system:apiserver"</span></div><div class="line">)</div></pre></td></tr></table></figure></p>
<h2 id="unionAuthenticator"><a href="#unionAuthenticator" class="headerlink" title="unionAuthenticator"></a>unionAuthenticator</h2><p>unionAuthenticator定义在/plugin/pkg/auth/authenticator/request/union/union.go:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// unionAuthRequestHandler authenticates requests using a chain of authenticator.Requests</span></div><div class="line"><span class="keyword">type</span> unionAuthRequestHandler <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="comment">// Handlers is a chain of request authenticators to delegate to</span></div><div class="line">    Handlers []authenticator.Request</div><div class="line">    <span class="comment">// FailOnError determines whether an error returns short-circuits the chain</span></div><div class="line">    FailOnError <span class="keyword">bool</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//***Go语言中参数三个点表示可变参数***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(authRequestHandlers ...authenticator.Request)</span> <span class="title">authenticator</span>.<span class="title">Request</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(authRequestHandlers) == <span class="number">1</span> &#123;</div><div class="line">        <span class="keyword">return</span> authRequestHandlers[<span class="number">0</span>]</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> &amp;unionAuthRequestHandler&#123;Handlers: authRequestHandlers, FailOnError: <span class="literal">false</span>&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>unionAuthenticator的AuthenticateRequest()方法定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***逐个调用authRequestHandler，如果有一个成功，则返回***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(authHandler *unionAuthRequestHandler)</span> <span class="title">AuthenticateRequest</span><span class="params">(req *http.Request)</span> <span class="params">(user.Info, <span class="keyword">bool</span>, error)</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> errlist []error</div><div class="line">    <span class="keyword">for</span> _, currAuthRequestHandler := <span class="keyword">range</span> authHandler.Handlers &#123;</div><div class="line">        info, ok, err := currAuthRequestHandler.AuthenticateRequest(req)</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">if</span> authHandler.FailOnError &#123;</div><div class="line">                <span class="keyword">return</span> info, ok, err</div><div class="line">            &#125;</div><div class="line">            errlist = <span class="built_in">append</span>(errlist, err)</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> ok &#123;</div><div class="line">            <span class="keyword">return</span> info, ok, err</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, utilerrors.NewAggregate(errlist)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>AuthenticateRequest()会轮询每一个authenticator，如果有一个authenticator认证成功，则直接返回认证成功。</p>
<h2 id="keystoneAuthenticator"><a href="#keystoneAuthenticator" class="headerlink" title="keystoneAuthenticator"></a>keystoneAuthenticator</h2><p>接下来回到/pkg/apiserver/authenticator/authn.go的New()中。New()调用newAuthenticatorFromKeystoneURL()生成keystoneAuthenticator。newAuthenticatorFromKeystoneURL()定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// newAuthenticatorFromTokenFile returns an authenticator.Request or an error</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">newAuthenticatorFromKeystoneURL</span><span class="params">(keystoneURL <span class="keyword">string</span>, keystoneCAFile <span class="keyword">string</span>)</span> <span class="params">(authenticator.Request, error)</span></span> &#123;</div><div class="line">	keystoneAuthenticator, err := keystone.NewKeystoneAuthenticator(keystoneURL, keystoneCAFile)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> basicauth.New(keystoneAuthenticator), <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，basicAuthenticator封装了keystoneAuthenticator的AuthenticatePassword()方法，定义在/plugin/pkg/auth/authenticator/request/basicauth/basicauth.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Authenticator authenticates requests using basic auth</span></div><div class="line"><span class="keyword">type</span> Authenticator <span class="keyword">struct</span> &#123;</div><div class="line">	auth authenticator.Password</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// New returns a request authenticator that validates credentials using the provided password authenticator</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(auth authenticator.Password)</span> *<span class="title">Authenticator</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> &amp;Authenticator&#123;auth&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// AuthenticateRequest authenticates the request using the "Authorization: Basic" header in the request</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Authenticator)</span> <span class="title">AuthenticateRequest</span><span class="params">(req *http.Request)</span> <span class="params">(user.Info, <span class="keyword">bool</span>, error)</span></span> &#123;</div><div class="line">	username, password, found := req.BasicAuth()</div><div class="line">	<span class="keyword">if</span> !found &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> a.auth.AuthenticatePassword(username, password)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，basicAuthenticator实现了AuthenticateRequest()，该方法会从请求中获取用户名和密码，然后调用所封装的认证器的AuthenticatePassword()方法进行认证。</p>
<p>回到正题来看keystoneAuthenticator。keystoneAuthenticator实现了authenticatePassword()方法。keystoneAuthenticator定义在/pkg/auth/authenticator/password/keystone/keystone.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// KeystoneAuthenticator contacts openstack keystone to validate user's credentials passed in the request.</span></div><div class="line"><span class="comment">// The keystone endpoint is passed during apiserver startup</span></div><div class="line"><span class="keyword">type</span> KeystoneAuthenticator <span class="keyword">struct</span> &#123;</div><div class="line">	authURL   <span class="keyword">string</span></div><div class="line">	transport http.RoundTripper</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// NewKeystoneAuthenticator returns a password authenticator that validates credentials using openstack keystone</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewKeystoneAuthenticator</span><span class="params">(authURL <span class="keyword">string</span>, caFile <span class="keyword">string</span>)</span> <span class="params">(*KeystoneAuthenticator, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> !strings.HasPrefix(authURL, <span class="string">"https"</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"Auth URL should be secure and start with https"</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> authURL == <span class="string">""</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"Auth URL is empty"</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> caFile != <span class="string">""</span> &#123;</div><div class="line">		roots, err := certutil.NewPool(caFile)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">		&#125;</div><div class="line">		config := &amp;tls.Config&#123;&#125;</div><div class="line">		config.RootCAs = roots</div><div class="line">		transport := netutil.SetOldTransportDefaults(&amp;http.Transport&#123;TLSClientConfig: config&#125;)</div><div class="line">		<span class="keyword">return</span> &amp;KeystoneAuthenticator&#123;authURL, transport&#125;, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> &amp;KeystoneAuthenticator&#123;authURL: authURL&#125;, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再来看下authenticatePassword()方法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AuthenticatePassword checks the username, password via keystone call</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(keystoneAuthenticator *KeystoneAuthenticator)</span> <span class="title">AuthenticatePassword</span><span class="params">(username <span class="keyword">string</span>, password <span class="keyword">string</span>)</span> <span class="params">(user.Info, <span class="keyword">bool</span>, error)</span></span> &#123;</div><div class="line">	opts := gophercloud.AuthOptions&#123;</div><div class="line">		IdentityEndpoint: keystoneAuthenticator.authURL,</div><div class="line">		Username:         username,</div><div class="line">		Password:         password,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	_, err := keystoneAuthenticator.AuthenticatedClient(opts)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		glog.Info(<span class="string">"Failed: Starting openstack authenticate client:"</span> + err.Error())</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, errors.New(<span class="string">"Failed to authenticate"</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> &amp;user.DefaultInfo&#123;Name: username&#125;, <span class="literal">true</span>, <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// AuthenticatedClient logs in to an OpenStack cloud found at the identity endpoint specified by options, acquires a</span></div><div class="line"><span class="comment">// token, and returns a Client instance that's ready to operate.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(keystoneAuthenticator *KeystoneAuthenticator)</span> <span class="title">AuthenticatedClient</span><span class="params">(options gophercloud.AuthOptions)</span> <span class="params">(*gophercloud.ProviderClient, error)</span></span> &#123;</div><div class="line">	client, err := openstack.NewClient(options.IdentityEndpoint)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> keystoneAuthenticator.transport != <span class="literal">nil</span> &#123;</div><div class="line">		client.HTTPClient.Transport = keystoneAuthenticator.transport</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	err = openstack.Authenticate(client, options)</div><div class="line">	<span class="keyword">return</span> client, err</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现也很简单，生成openstack client，然后去认证用户名和密码，最后返回的是user。</p>
<h2 id="对请求进行认证"><a href="#对请求进行认证" class="headerlink" title="对请求进行认证"></a>对请求进行认证</h2><p>现在来看下如何对请求进行处理。<br>在GenericAPIServer结构体(定义在/pkg/genericapiserver/genericapiserver.go中)中，有HandlerContainer和Handler两个字段。其中HandlerContainer封装了所有的API处理函数，具体如何封装以后分析；而Handler在HandlerContainer的基础上还封装了授权，认证等处理函数。详见/pkg/genericapiserver/config.go:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***通过调用WithAuthentication(), WithAuthorization()等构建handler处理链***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">DefaultBuildHandlerChain</span><span class="params">(apiHandler http.Handler, c *Config)</span> <span class="params">(secure, insecure http.Handler)</span></span> &#123;</div><div class="line">	attributeGetter := apiserverfilters.NewRequestAttributeGetter(c.RequestContextMapper)</div><div class="line"></div><div class="line">	generic := <span class="function"><span class="keyword">func</span><span class="params">(handler http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</div><div class="line">		handler = genericfilters.WithCORS(handler, c.CorsAllowedOriginList, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">"true"</span>)</div><div class="line">		handler = genericfilters.WithPanicRecovery(handler, c.RequestContextMapper)</div><div class="line">		handler = apiserverfilters.WithRequestInfo(handler, NewRequestInfoResolver(c), c.RequestContextMapper)</div><div class="line">		handler = api.WithRequestContext(handler, c.RequestContextMapper)</div><div class="line">		handler = genericfilters.WithTimeoutForNonLongRunningRequests(handler, c.LongRunningFunc)</div><div class="line">		handler = genericfilters.WithMaxInFlightLimit(handler, c.MaxRequestsInFlight, c.LongRunningFunc)</div><div class="line">		<span class="keyword">return</span> handler</div><div class="line">	&#125;</div><div class="line">	audit := <span class="function"><span class="keyword">func</span><span class="params">(handler http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</div><div class="line">		<span class="keyword">return</span> apiserverfilters.WithAudit(handler, attributeGetter, c.AuditWriter)</div><div class="line">	&#125;</div><div class="line">	protect := <span class="function"><span class="keyword">func</span><span class="params">(handler http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</div><div class="line">		<span class="comment">//***封装在/pkg/apiserver/filters/authorization.go中***//</span></div><div class="line">		handler = apiserverfilters.WithAuthorization(handler, attributeGetter, c.Authorizer)</div><div class="line">		handler = apiserverfilters.WithImpersonation(handler, c.RequestContextMapper, c.Authorizer)</div><div class="line">		handler = audit(handler) <span class="comment">// before impersonation to read original user</span></div><div class="line">		handler = authhandlers.WithAuthentication(handler, c.RequestContextMapper, c.Authenticator, authhandlers.Unauthorized(c.SupportsBasicAuth))</div><div class="line">		<span class="keyword">return</span> handler</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> generic(protect(apiHandler)), generic(audit(apiHandler))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以WithAuthentication()为例来看下是如何对handler进行层层封装的。WithAuthentication()定义在/pkg/auth/handlers/handlers.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// WithAuthentication creates an http handler that tries to authenticate the given request as a user, and then</span></div><div class="line"><span class="comment">// stores any such user found onto the provided context for the request. If authentication fails or returns an error</span></div><div class="line"><span class="comment">// the failed handler is used. On success, "Authorization" header is removed from the request and handler</span></div><div class="line"><span class="comment">// is invoked to serve the request.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithAuthentication</span><span class="params">(handler http.Handler, mapper api.RequestContextMapper, auth authenticator.Request, failed http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> auth == <span class="literal">nil</span> &#123;</div><div class="line">		glog.Warningf(<span class="string">"Authentication is disabled"</span>)</div><div class="line">		<span class="keyword">return</span> handler</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> api.WithRequestContext(</div><div class="line">		http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</div><div class="line">			<span class="comment">//***handler中的认证***//</span></div><div class="line">			user, ok, err := auth.AuthenticateRequest(req)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> || !ok &#123;</div><div class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">					glog.Errorf(<span class="string">"Unable to authenticate the request due to an error: %v"</span>, err)</div><div class="line">				&#125;</div><div class="line">				failed.ServeHTTP(w, req)</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">// authorization header is not required anymore in case of a successful authentication.</span></div><div class="line">			req.Header.Del(<span class="string">"Authorization"</span>)</div><div class="line"></div><div class="line">			<span class="keyword">if</span> ctx, ok := mapper.Get(req); ok &#123;</div><div class="line">				mapper.Update(req, api.WithUser(ctx, user))</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			authenticatedUserCounter.WithLabelValues(compressUsername(user.GetName())).Inc()</div><div class="line"></div><div class="line">			handler.ServeHTTP(w, req)</div><div class="line">		&#125;),</div><div class="line">		mapper,</div><div class="line">	)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，http.HandlerFunc本身就是一个handler。所以WithAuthentication()先调用auth.AuthenticateRequest()对请求进行验证，然后调用前handler的ServeHTTP()对请求接着作处理，以达到在处理前进行认证的目的。</p>
<p>回到DefaultBuildHandlerChain()，调用DefaultBuildHandlerChain()函数的地方在/pkg/genericapiserver/config.go中的New()方法中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***调用BuildHandlerChainsFunc()生成Handler***//</span></div><div class="line"><span class="comment">//***把HandlerContainer进一步封装，以进行认证，授权等动作***//</span></div><div class="line">s.Handler, s.InsecureHandler = c.BuildHandlerChainsFunc(s.HandlerContainer.ServeMux, c.Config)</div></pre></td></tr></table></figure></p>
<p>其中，BuildHandlerChainsFunc就是DefaultBuildHandlerChain。可见，Handler是在handlerContainer的基础上封装了protect和generic；InsecureHandler是在handlerContainer的基础上封装了audit和generic。</p>
<p>那么，是怎样关联server和handler呢？</p>
<p>来看/pkg/genericapiserver/genericapiserver.go中preparedGenericAPIServer的Run()方法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Run spawns the http servers (secure and insecure). It only returns if stopCh is closed</span></div><div class="line"><span class="comment">// or one of the ports cannot be listened on initially.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s preparedGenericAPIServer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</div><div class="line">	<span class="comment">//***监听安全端口***//</span></div><div class="line">	<span class="keyword">if</span> s.SecureServingInfo != <span class="literal">nil</span> &amp;&amp; s.Handler != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">if</span> err := s.serveSecurely(stopCh); err != <span class="literal">nil</span> &#123;</div><div class="line">			glog.Fatal(err)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//***监听非安全端口***//</span></div><div class="line">	<span class="keyword">if</span> s.InsecureServingInfo != <span class="literal">nil</span> &amp;&amp; s.InsecureHandler != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">if</span> err := s.serveInsecurely(stopCh); err != <span class="literal">nil</span> &#123;</div><div class="line">			glog.Fatal(err)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	s.RunPostStartHooks()</div><div class="line"></div><div class="line">	<span class="comment">// err == systemd.SdNotifyNoSocket when not running on a systemd system</span></div><div class="line">	<span class="keyword">if</span> err := systemd.SdNotify(<span class="string">"READY=1\n"</span>); err != <span class="literal">nil</span> &amp;&amp; err != systemd.SdNotifyNoSocket &#123;</div><div class="line">		glog.Errorf(<span class="string">"Unable to send systemd daemon successful start message: %v\n"</span>, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//***监听stpCh channel，如果有信号，则退出***//</span></div><div class="line">	&lt;-stopCh</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Run()方法中，有serveSecurely()和serveInsecuurely()两个函数调用，这两个函数定义在/pkg/genericapiserver/serve.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***监听安全端口***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GenericAPIServer)</span> <span class="title">serveSecurely</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</div><div class="line">	namedCerts, err := getNamedCertificateMap(s.SecureServingInfo.SNICerts)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"unable to load SNI certificates: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	secureServer := &amp;http.Server&#123;</div><div class="line">		Addr:           s.SecureServingInfo.BindAddress,</div><div class="line">		Handler:        s.Handler,</div><div class="line">		MaxHeaderBytes: <span class="number">1</span> &lt;&lt; <span class="number">20</span>,</div><div class="line">		TLSConfig: &amp;tls.Config&#123;</div><div class="line">			NameToCertificate: namedCerts,</div><div class="line">			<span class="comment">// Can't use SSLv3 because of POODLE and BEAST</span></div><div class="line">			<span class="comment">// Can't use TLSv1.0 because of POODLE and BEAST using CBC cipher</span></div><div class="line">			<span class="comment">// Can't use TLSv1.1 because of RC4 cipher usage</span></div><div class="line">			MinVersion: tls.VersionTLS12,</div><div class="line">			<span class="comment">// enable HTTP2 for go's 1.7 HTTP Server</span></div><div class="line">			NextProtos: []<span class="keyword">string</span>&#123;<span class="string">"h2"</span>, <span class="string">"http/1.1"</span>&#125;,</div><div class="line">		&#125;,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s.SecureServingInfo.ServerCert.CertFile) != <span class="number">0</span> || <span class="built_in">len</span>(s.SecureServingInfo.ServerCert.KeyFile) != <span class="number">0</span> &#123;</div><div class="line">		secureServer.TLSConfig.Certificates = <span class="built_in">make</span>([]tls.Certificate, <span class="number">1</span>)</div><div class="line">		secureServer.TLSConfig.Certificates[<span class="number">0</span>], err = tls.LoadX509KeyPair(s.SecureServingInfo.ServerCert.CertFile, s.SecureServingInfo.ServerCert.KeyFile)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"unable to load server certificate: %v"</span>, err)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// append all named certs. Otherwise, the go tls stack will think no SNI processing</span></div><div class="line">	<span class="comment">// is necessary because there is only one cert anyway.</span></div><div class="line">	<span class="comment">// Moreover, if ServerCert.CertFile/ServerCert.KeyFile are not set, the first SNI</span></div><div class="line">	<span class="comment">// cert will become the default cert. That's what we expect anyway.</span></div><div class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> namedCerts &#123;</div><div class="line">		secureServer.TLSConfig.Certificates = <span class="built_in">append</span>(secureServer.TLSConfig.Certificates, *c)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s.SecureServingInfo.ClientCA) &gt; <span class="number">0</span> &#123;</div><div class="line">		clientCAs, err := certutil.NewPool(s.SecureServingInfo.ClientCA)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"unable to load client CA file: %v"</span>, err)</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// Populate PeerCertificates in requests, but don't reject connections without certificates</span></div><div class="line">		<span class="comment">// This allows certificates to be validated by authenticators, while still allowing other auth types</span></div><div class="line">		secureServer.TLSConfig.ClientAuth = tls.RequestClientCert</div><div class="line">		<span class="comment">// Specify allowed CAs for client certificates</span></div><div class="line">		secureServer.TLSConfig.ClientCAs = clientCAs</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	glog.Infof(<span class="string">"Serving securely on %s"</span>, s.SecureServingInfo.BindAddress)</div><div class="line">	s.effectiveSecurePort, err = runServer(secureServer, s.SecureServingInfo.BindNetwork, stopCh)</div><div class="line">	<span class="keyword">return</span> err</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//***监听非安全端口***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GenericAPIServer)</span> <span class="title">serveInsecurely</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</div><div class="line">	insecureServer := &amp;http.Server&#123;</div><div class="line">		Addr:           s.InsecureServingInfo.BindAddress,</div><div class="line">		Handler:        s.InsecureHandler,</div><div class="line">		MaxHeaderBytes: <span class="number">1</span> &lt;&lt; <span class="number">20</span>,</div><div class="line">	&#125;</div><div class="line">	glog.Infof(<span class="string">"Serving insecurely on %s"</span>, s.InsecureServingInfo.BindAddress)</div><div class="line">	<span class="keyword">var</span> err error</div><div class="line">	s.effectiveInsecurePort, err = runServer(insecureServer, s.InsecureServingInfo.BindNetwork, stopCh)</div><div class="line">	<span class="keyword">return</span> err</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，这两个函数中的server的Handler分别为s.Handler和s.InsecureHandler。在来看下runServer()：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// runServer listens on the given port, then spawns a go-routine continuously serving</span></div><div class="line"><span class="comment">// until the stopCh is closed. The port is returned. This function does not block.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">runServer</span><span class="params">(server *http.Server, network <span class="keyword">string</span>, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(server.Addr) == <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">"address cannot be empty"</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(network) == <span class="number">0</span> &#123;</div><div class="line">		network = <span class="string">"tcp"</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// first listen is synchronous (fail early!)</span></div><div class="line">	ln, err := net.Listen(network, server.Addr)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">"failed to listen on %v: %v"</span>, server.Addr, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// get port</span></div><div class="line">	tcpAddr, ok := ln.Addr().(*net.TCPAddr)</div><div class="line">	<span class="keyword">if</span> !ok &#123;</div><div class="line">		ln.Close()</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">"invalid listen address: %q"</span>, ln.Addr().String())</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	lock := sync.Mutex&#123;&#125; <span class="comment">// to avoid we close an old listener during a listen retry</span></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		&lt;-stopCh</div><div class="line">		lock.Lock()</div><div class="line">		<span class="keyword">defer</span> lock.Unlock()</div><div class="line">		ln.Close()</div><div class="line">	&#125;()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">defer</span> utilruntime.HandleCrash()</div><div class="line"></div><div class="line">		<span class="keyword">for</span> &#123;</div><div class="line">			<span class="keyword">var</span> listener net.Listener</div><div class="line">			listener = tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;</div><div class="line">			<span class="keyword">if</span> server.TLSConfig != <span class="literal">nil</span> &#123;</div><div class="line">				listener = tls.NewListener(listener, server.TLSConfig)</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">//***server开始监听***//</span></div><div class="line">			err := server.Serve(listener)</div><div class="line">			glog.Errorf(<span class="string">"Error serving %v (%v); will try again."</span>, server.Addr, err)</div><div class="line"></div><div class="line">			<span class="comment">// listen again</span></div><div class="line">			<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">				lock.Lock()</div><div class="line">				<span class="keyword">defer</span> lock.Unlock()</div><div class="line">				<span class="keyword">for</span> &#123;</div><div class="line">					time.Sleep(<span class="number">15</span> * time.Second)</div><div class="line"></div><div class="line">					ln, err = net.Listen(<span class="string">"tcp"</span>, server.Addr)</div><div class="line">					<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">						<span class="keyword">return</span></div><div class="line">					&#125;</div><div class="line">					<span class="keyword">select</span> &#123;</div><div class="line">					<span class="keyword">case</span> &lt;-stopCh:</div><div class="line">						<span class="keyword">return</span></div><div class="line">					<span class="keyword">default</span>:</div><div class="line">					&#125;</div><div class="line">					glog.Errorf(<span class="string">"Error listening on %v (%v); will try again."</span>, server.Addr, err)</div><div class="line">				&#125;</div><div class="line">			&#125;()</div><div class="line"></div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-stopCh:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">default</span>:</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> tcpAddr.Port, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>runServer()中会开始监听端口，并把请求交给Handler或InsecureHandler进行处理。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://fankangbest.github.com/2017/09/07/apiserver分析(一)-authenticator-v1-5-2/" data-id="cjbqbopue002l9wqsg2pgjbs9" class="article-share-link">分享</a><div class="tags"><a href="/tags/kubernetes/">kubernetes</a><a href="/tags/kubernetes-v1-5-2/">kubernetes-v1.5.2</a></div><div class="post-nav"><a href="/2017/09/07/resourcequota分析(二)-quota-v1-5-2/" class="pre">resourcequota分析(二)-quota-v1.5.2</a><a href="/2017/09/06/resourcequota分析(一)-evaluator-v1-5-2/" class="next">resourcequota分析(一)-evaluator-v1.5.2</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://fankangbest.github.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/GO语言/">GO语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/存储虚拟化/">存储虚拟化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/容器虚拟化/">容器虚拟化</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/containerd-v0-2-4/" style="font-size: 15px;">containerd-v0.2.4</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/docker-v1-12-3/" style="font-size: 15px;">docker-v1.12.3</a> <a href="/tags/GO语言/" style="font-size: 15px;">GO语言</a> <a href="/tags/containerd/" style="font-size: 15px;">containerd</a> <a href="/tags/kubernetes-v1-5-2/" style="font-size: 15px;">kubernetes-v1.5.2</a> <a href="/tags/gRPC/" style="font-size: 15px;">gRPC</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/runc/" style="font-size: 15px;">runc</a> <a href="/tags/runc-v1-0-0-rc2/" style="font-size: 15px;">runc-v1.0.0-rc2</a> <a href="/tags/ceph/" style="font-size: 15px;">ceph</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/12/28/Docker工具包分析-archive-v1-12-3/">Docker工具包分析-archive-v1.12.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/27/Docker命令行分析-cp-v1-12-3/">Docker命令行分析-cp-v1.12.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/26/tar-stream-demo/">tar-stream-demo</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/25/Docker命令分行分析-run-v1-12-3/">Docker命令分行分析-run-v1.12.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/23/kubelet分析(七)-dockerManager(2)-v1-5-2/">kubelet分析(七)-dockerManager(2)-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/23/kubelet分析(七)-dockerManager(1)-v1-5-2/">kubelet分析(七)-dockerManager(1)-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/20/kubelet分析(六)-proberManager-v1-5-2/">kubelet分析(六)-proberManager-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/18/kubelet分析(五)-podManager-v1-5-2/">kubelet分析(五)-podManager-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/17/kubelet分析(四)-statusManager-v1-5-2/">kubelet分析(四)-statusManager-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/17/kubelet分析(三)-volumeManager-v1-5-2/">kubelet分析(三)-volumeManager-v1.5.2</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/fankangbest" title="myGithub" target="_blank">myGithub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">fankangbest.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>