<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Docker命令行分析-cp-v1.12.3 | fankangbest</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Docker命令行分析-cp-v1.12.3</h1><a id="logo" href="/.">fankangbest</a><p class="description">多听，少说，接受每一个人的责难，但是保留自己的最后裁决。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Docker命令行分析-cp-v1.12.3</h1><div class="post-meta">Dec 27, 2017<span> | </span><span class="category"><a href="/categories/容器虚拟化/">容器虚拟化</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p>Docker的copy命令可以在容器与物理机之间拷贝内容。本次分析将介绍copy命令是如何实现的。</p>
<h2 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h2><p>在Docker client端，copy命令由runCopy()执行。runCopy()定义在/api/client/container/cp.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">runCopy</span><span class="params">(dockerCli *client.DockerCli, opts copyOptions)</span> <span class="title">error</span></span> &#123;</div><div class="line">	srcContainer, srcPath := splitCpArg(opts.source)</div><div class="line">	dstContainer, dstPath := splitCpArg(opts.destination)</div><div class="line"></div><div class="line">	<span class="keyword">var</span> direction copyDirection</div><div class="line">	<span class="keyword">if</span> srcContainer != <span class="string">""</span> &#123;</div><div class="line">		direction |= fromContainer</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> dstContainer != <span class="string">""</span> &#123;</div><div class="line">		direction |= toContainer</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	cpParam := &amp;cpConfig&#123;</div><div class="line">		followLink: opts.followLink,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	ctx := context.Background()</div><div class="line"></div><div class="line">	<span class="keyword">switch</span> direction &#123;</div><div class="line">	<span class="keyword">case</span> fromContainer:</div><div class="line">		<span class="keyword">return</span> copyFromContainer(ctx, dockerCli, srcContainer, srcPath, dstPath, cpParam)</div><div class="line">	<span class="keyword">case</span> toContainer:</div><div class="line">		<span class="keyword">return</span> copyToContainer(ctx, dockerCli, srcPath, dstContainer, dstPath, cpParam)</div><div class="line">	<span class="keyword">case</span> acrossContainers:</div><div class="line">		<span class="comment">// Copying between containers isn't supported.</span></div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"copying between containers is not supported"</span>)</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="comment">// User didn't specify any container.</span></div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"must specify at least one container source"</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>runCopy()会根据copy的参数，如container出现在src中，则调用copyFromContainer()；如container出现在dest中，则调用copyToContainer()。</p>
<p>copyFromContainer()可以把内容从容器中拷贝到物理机，定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***从container中复制***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyFromContainer</span><span class="params">(ctx context.Context, dockerCli *client.DockerCli, srcContainer, srcPath, dstPath <span class="keyword">string</span>, cpParam *cpConfig)</span> <span class="params">(err error)</span></span> &#123;</div><div class="line">	......</div><div class="line"></div><div class="line">	<span class="comment">//***从container中拷贝内容***//</span></div><div class="line">	content, stat, err := dockerCli.Client().CopyFromContainer(ctx, srcContainer, srcPath)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">defer</span> content.Close()</div><div class="line"></div><div class="line">	......</div><div class="line">	<span class="comment">// Prepare source copy info.</span></div><div class="line">	srcInfo := archive.CopyInfo&#123;</div><div class="line">		Path:       srcPath,</div><div class="line">		Exists:     <span class="literal">true</span>,</div><div class="line">		IsDir:      stat.Mode.IsDir(),</div><div class="line">		RebaseName: rebaseName,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	preArchive := content</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(srcInfo.RebaseName) != <span class="number">0</span> &#123;</div><div class="line">		_, srcBase := archive.SplitPathDirEntry(srcInfo.Path)</div><div class="line">		preArchive = archive.RebaseArchiveEntries(content, srcBase, srcInfo.RebaseName)</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// See comments in the implementation of `archive.CopyTo` for exactly what</span></div><div class="line">	<span class="comment">// goes into deciding how and whether the source archive needs to be</span></div><div class="line">	<span class="comment">// altered for the correct copy behavior.</span></div><div class="line">	<span class="comment">//***把内容拷贝到dstPath***//</span></div><div class="line">	<span class="keyword">return</span> archive.CopyTo(preArchive, srcInfo, dstPath)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>copyFromContainer()先调用Client的CopyFromContainer()获取打包好的content；然后调用archive包的CopyTo()把content的内容解包到dstPath。所以这里出现了archive包的CopyTo()函数，关于archive包，将在下一次分析中介绍。</p>
<p>copyToContainer()可以把物理机上的内容拷贝到容器中，定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyToContainer</span><span class="params">(ctx context.Context, dockerCli *client.DockerCli, srcPath, dstContainer, dstPath <span class="keyword">string</span>, cpParam *cpConfig)</span> <span class="params">(err error)</span></span> &#123;</div><div class="line">	......</div><div class="line">	<span class="keyword">if</span> srcPath == <span class="string">"-"</span> &#123;</div><div class="line">		......</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">// Prepare source copy info.</span></div><div class="line">		srcInfo, err := archive.CopyInfoSourcePath(srcPath, cpParam.followLink)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">//***调用TarResource()***//</span></div><div class="line">		srcArchive, err := archive.TarResource(srcInfo)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">defer</span> srcArchive.Close()</div><div class="line">		......</div><div class="line">		dstDir, preparedArchive, err := archive.PrepareArchiveCopy(srcArchive, srcInfo, dstInfo)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">defer</span> preparedArchive.Close()</div><div class="line"></div><div class="line">		resolvedDstPath = dstDir</div><div class="line">		content = preparedArchive</div><div class="line">	&#125;</div><div class="line">	......</div><div class="line">	<span class="keyword">return</span> dockerCli.Client().CopyToContainer(ctx, dstContainer, resolvedDstPath, content, options)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>copyToContainer()会调用aichive包的TarResource()来把文件源进行打包，然后调用client的CopyToContainer()把打包数据流传入拷贝到容器中。这里出现了archive包的TarResource()函数。</p>
<h2 id="engine-api端"><a href="#engine-api端" class="headerlink" title="engine-api端"></a>engine-api端</h2><p>engine-api的client中定义有CopyFromContainer()和CopyToContainer()，都定义在/docker/engine-api/client/container_copy.go中：<br>CopyFromContainer()定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// CopyFromContainer gets the content from the container and returns it as a Reader</span></div><div class="line"><span class="comment">// to manipulate it in the host. It's up to the caller to close the reader.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *Client)</span> <span class="title">CopyFromContainer</span><span class="params">(ctx context.Context, container, srcPath <span class="keyword">string</span>)</span> <span class="params">(io.ReadCloser, types.ContainerPathStat, error)</span></span> &#123;</div><div class="line">	query := <span class="built_in">make</span>(url.Values, <span class="number">1</span>)</div><div class="line">	query.Set(<span class="string">"path"</span>, filepath.ToSlash(srcPath)) <span class="comment">// Normalize the paths used in the API.</span></div><div class="line"></div><div class="line">	apiPath := fmt.Sprintf(<span class="string">"/containers/%s/archive"</span>, container)</div><div class="line">	response, err := cli.get(ctx, apiPath, query, <span class="literal">nil</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, types.ContainerPathStat&#123;&#125;, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> response.statusCode != http.StatusOK &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, types.ContainerPathStat&#123;&#125;, fmt.Errorf(<span class="string">"unexpected status code from daemon: %d"</span>, response.statusCode)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	......</div><div class="line">	stat, err := getContainerPathStatFromHeader(response.header)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, stat, fmt.Errorf(<span class="string">"unable to get resource stat from response: %s"</span>, err)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> response.body, stat, err</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>CopyFromContainer()使用”GET”去请求dockerd的”/containers/container-name/archive”路径。</p>
<p>CopyToContainer()定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***拷贝到容器中***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *Client)</span> <span class="title">CopyToContainer</span><span class="params">(ctx context.Context, container, path <span class="keyword">string</span>, content io.Reader, options types.CopyToContainerOptions)</span> <span class="title">error</span></span> &#123;</div><div class="line">	query := url.Values&#123;&#125;</div><div class="line">	query.Set(<span class="string">"path"</span>, filepath.ToSlash(path)) <span class="comment">// Normalize the paths used in the API.</span></div><div class="line">	<span class="comment">// Do not allow for an existing directory to be overwritten by a non-directory and vice versa.</span></div><div class="line">	<span class="keyword">if</span> !options.AllowOverwriteDirWithFile &#123;</div><div class="line">		query.Set(<span class="string">"noOverwriteDirNonDir"</span>, <span class="string">"true"</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	apiPath := fmt.Sprintf(<span class="string">"/containers/%s/archive"</span>, container)</div><div class="line"></div><div class="line">	response, err := cli.putRaw(ctx, apiPath, query, content, <span class="literal">nil</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">defer</span> ensureReaderClosed(response)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> response.statusCode != http.StatusOK &#123;</div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"unexpected status code from daemon: %d"</span>, response.statusCode)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>CopyToContainer把打包数据流以”PUT”方法发送到dockerd的”/containers/container-name/archive”路径。</p>
<h2 id="dockerd侧"><a href="#dockerd侧" class="headerlink" title="dockerd侧"></a>dockerd侧</h2><p>在dockerd，”/containers/<container-name>/archive”路径的”GET”请求的功能由getContainersArchive()方法实现；”/containers/<container-name>/archive”路径的”PUT”请求的功能由putContainersArchive()方法实现。</container-name></container-name></p>
<h3 id="getContainersArchive"><a href="#getContainersArchive" class="headerlink" title="getContainersArchive()"></a>getContainersArchive()</h3><p>getContainersArchive()定义在/api/server/router/container/copy.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *containerRouter)</span> <span class="title">getContainersArchive</span><span class="params">(ctx context.Context, w http.ResponseWriter, r *http.Request, vars <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	v, err := httputils.ArchiveFormValues(r, vars)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//***调用Daemon的ContainerArchivePath()***//</span></div><div class="line">	tarArchive, stat, err := s.backend.ContainerArchivePath(v.Name, v.Path)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">defer</span> tarArchive.Close()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err := setContainerPathStatHeader(stat, w.Header()); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/x-tar"</span>)</div><div class="line">	<span class="comment">//***把tarArchive的内容拷贝到http.ResponseWriter***//</span></div><div class="line">	_, err = io.Copy(w, tarArchive)</div><div class="line"></div><div class="line">	<span class="keyword">return</span> err</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>getContainersArchive()会从参数中解析出需要拷贝容器的文件(或目录)，然后调用dockerd的ContainerArchivePath()方法把文件(或目录)打包成数据流，然后把数据流的数据通过io.Copy()写入到ResponseWriter中，即应答的body中。</p>
<p>所以关键的实现是ContainerArchivePath()是如何打包文件(或目录)的。ContainerArchivePath()定义在/daemon/archive.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span> <span class="title">ContainerArchivePath</span><span class="params">(name <span class="keyword">string</span>, path <span class="keyword">string</span>)</span> <span class="params">(content io.ReadCloser, stat *types.ContainerPathStat, err error)</span></span> &#123;</div><div class="line">	container, err := daemon.GetContainer(name)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> daemon.containerArchivePath(container, path)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ContainerArchivePath()先获取container，然后调用containerArchivePath()来打包容器中的内容。<br>containerArchivePath()定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// containerArchivePath creates an archive of the filesystem resource at the specified</span></div><div class="line"><span class="comment">// path in this container. Returns a tar archive of the resource and stat info</span></div><div class="line"><span class="comment">// about the resource.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span> <span class="title">containerArchivePath</span><span class="params">(container *container.Container, path <span class="keyword">string</span>)</span> <span class="params">(content io.ReadCloser, stat *types.ContainerPathStat, err error)</span></span> &#123;</div><div class="line">	container.Lock()</div><div class="line"></div><div class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="comment">// Wait to unlock the container until the archive is fully read</span></div><div class="line">			<span class="comment">// (see the ReadCloseWrapper func below) or if there is an error</span></div><div class="line">			<span class="comment">// before that occurs.</span></div><div class="line">			container.Unlock()</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err = daemon.Mount(container); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="comment">// unmount any volumes</span></div><div class="line">			container.UnmountVolumes(<span class="literal">true</span>, daemon.LogVolumeEvent)</div><div class="line">			<span class="comment">// unmount the container's rootfs</span></div><div class="line">			daemon.Unmount(container)</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err = daemon.mountVolumes(container); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//***resolvedPath:  /var/lib/docker1/aufs/mnt/74c46809b458407e104da88a470e71924a49ddb7e5e259f24fc0e8ef48571a17/init_ssh.sh***//</span></div><div class="line">	<span class="comment">//***absPath:  /init_ssh.sh***//</span></div><div class="line">	resolvedPath, absPath, err := container.ResolvePath(path)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	......</div><div class="line">	<span class="comment">//***调用TarResourceRebase()***//</span></div><div class="line">	data, err := archive.TarResourceRebase(resolvedPath, filepath.Base(absPath))</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	content = ioutils.NewReadCloserWrapper(data, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">		err := data.Close()</div><div class="line">		container.UnmountVolumes(<span class="literal">true</span>, daemon.LogVolumeEvent)</div><div class="line">		daemon.Unmount(container)</div><div class="line">		container.Unlock()</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;)</div><div class="line"></div><div class="line">	daemon.LogContainerEvent(container, <span class="string">"archive-path"</span>)</div><div class="line"></div><div class="line">	<span class="keyword">return</span> content, stat, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>containerArchivePath()先解析出resolvedPath和absPath。然后调用archive.TarResourceRebase()来对文件(或目录)进行打包。然后把数据流返回。这里使用了archive包中的TarResourceRebase()。</p>
<h3 id="putContainersArchive"><a href="#putContainersArchive" class="headerlink" title="putContainersArchive()"></a>putContainersArchive()</h3><p>putContainersArchive()定义在/api/server/router/container/copy.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***把内容拷贝到容器中***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *containerRouter)</span> <span class="title">putContainersArchive</span><span class="params">(ctx context.Context, w http.ResponseWriter, r *http.Request, vars <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	v, err := httputils.ArchiveFormValues(r, vars)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	noOverwriteDirNonDir := httputils.BoolValue(r, <span class="string">"noOverwriteDirNonDir"</span>)</div><div class="line"></div><div class="line">	<span class="comment">//***调用Daemon的ContainerExtractToDir()***//</span></div><div class="line">	<span class="keyword">return</span> s.backend.ContainerExtractToDir(v.Name, v.Path, noOverwriteDirNonDir, r.Body)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>putContainersArchive()主要调用了dockerd的ContainerExtractToDir()方法。</p>
<p>ContainerExtractToDir()定义在/daemon/archive.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span> <span class="title">containerExtractToDir</span><span class="params">(container *container.Container, path <span class="keyword">string</span>, noOverwriteDirNonDir <span class="keyword">bool</span>, content io.Reader)</span> <span class="params">(err error)</span></span> &#123;</div><div class="line">	......</div><div class="line">	absPath := archive.PreserveTrailingDotOrSeparator(filepath.Join(<span class="keyword">string</span>(filepath.Separator), path), path)</div><div class="line"></div><div class="line">	<span class="comment">// This will evaluate the last path element if it is a symlink.</span></div><div class="line">	<span class="comment">//***resolvedPath:  /var/lib/docker1/aufs/mnt/74c46809b458407e104da88a470e71924a49ddb7e5e259f24fc0e8ef48571a17/home***//</span></div><div class="line">	resolvedPath, err := container.GetResourcePath(absPath)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	......</div><div class="line">	uid, gid := daemon.GetRemappedUIDGID()</div><div class="line">	options := &amp;archive.TarOptions&#123;</div><div class="line">		NoOverwriteDirNonDir: noOverwriteDirNonDir,</div><div class="line">		ChownOpts: &amp;archive.TarChownOptions&#123;</div><div class="line">			UID: uid, GID: gid, <span class="comment">// <span class="doctag">TODO:</span> should all ownership be set to root (either real or remapped)?</span></div><div class="line">		&#125;,</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//***Fankang***//</span></div><div class="line">	<span class="comment">//***调用Untar()***//</span></div><div class="line">	<span class="keyword">if</span> err := chrootarchive.Untar(content, resolvedPath, options); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	daemon.LogContainerEvent(container, <span class="string">"extract-to-dir"</span>)</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>containerExtractToDir()主要调用的是chrootarchive的Untar()对打包数据流进行解包。</p>
<h4 id="chrootarchive"><a href="#chrootarchive" class="headerlink" title="chrootarchive"></a>chrootarchive</h4><p>chrootarchive的Untar()定义在/pkg/chrootarchive/archive.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Untar</span><span class="params">(tarArchive io.Reader, dest <span class="keyword">string</span>, options *archive.TarOptions)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> untarHandler(tarArchive, dest, options, <span class="literal">true</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Handler for teasing out the automatic decompression</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">untarHandler</span><span class="params">(tarArchive io.Reader, dest <span class="keyword">string</span>, options *archive.TarOptions, decompress <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> tarArchive == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"Empty archive"</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> options == <span class="literal">nil</span> &#123;</div><div class="line">		options = &amp;archive.TarOptions&#123;&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> options.ExcludePatterns == <span class="literal">nil</span> &#123;</div><div class="line">		options.ExcludePatterns = []<span class="keyword">string</span>&#123;&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	rootUID, rootGID, err := idtools.GetRootUIDGID(options.UIDMaps, options.GIDMaps)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	dest = filepath.Clean(dest)</div><div class="line">	<span class="keyword">if</span> _, err := os.Stat(dest); os.IsNotExist(err) &#123;</div><div class="line">		<span class="keyword">if</span> err := idtools.MkdirAllNewAs(dest, <span class="number">0755</span>, rootUID, rootGID); err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	r := ioutil.NopCloser(tarArchive)</div><div class="line">	<span class="keyword">if</span> decompress &#123;</div><div class="line">		decompressedArchive, err := archive.DecompressStream(tarArchive)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">defer</span> decompressedArchive.Close()</div><div class="line">		r = decompressedArchive</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> invokeUnpack(r, dest, options)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Untar()调用了untarHandler()，而untarHandler()主要调用了invokeUnpack()。</p>
<p>invokeUnpack()定义在/pkg/chrootarchive/archive_unix.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">invokeUnpack</span><span class="params">(decompressedArchive io.Reader, dest <span class="keyword">string</span>, options *archive.TarOptions)</span> <span class="title">error</span></span> &#123;</div><div class="line"></div><div class="line">	<span class="comment">// We can't pass a potentially large exclude list directly via cmd line</span></div><div class="line">	<span class="comment">// because we easily overrun the kernel's max argument/environment size</span></div><div class="line">	<span class="comment">// when the full image list is passed (e.g. when this is used by</span></div><div class="line">	<span class="comment">// `docker load`). We will marshall the options via a pipe to the</span></div><div class="line">	<span class="comment">// child</span></div><div class="line">	r, w, err := os.Pipe()</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"Untar pipe failure: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//***调用docker-untar***//</span></div><div class="line">	<span class="comment">//***dest:  /var/lib/docker1/aufs/mnt/74c46809b458407e104da88a470e71924a49ddb7e5e259f24fc0e8ef48571a17/home***//</span></div><div class="line">	cmd := reexec.Command(<span class="string">"docker-untar"</span>, dest)</div><div class="line">	<span class="comment">//***把decompressedArchive作为输入***//</span></div><div class="line">	cmd.Stdin = decompressedArchive</div><div class="line"></div><div class="line">	cmd.ExtraFiles = <span class="built_in">append</span>(cmd.ExtraFiles, r)</div><div class="line">	output := bytes.NewBuffer(<span class="literal">nil</span>)</div><div class="line">	cmd.Stdout = output</div><div class="line">	cmd.Stderr = output</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err := cmd.Start(); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"Untar error on re-exec cmd: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//write the options to the pipe for the untar exec to read</span></div><div class="line">	<span class="keyword">if</span> err := json.NewEncoder(w).Encode(options); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"Untar json encode to pipe failed: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	w.Close()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err := cmd.Wait(); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="comment">// when `xz -d -c -q | docker-untar ...` failed on docker-untar side,</span></div><div class="line">		<span class="comment">// we need to exhaust `xz`'s output, otherwise the `xz` side will be</span></div><div class="line">		<span class="comment">// pending on write pipe forever</span></div><div class="line">		io.Copy(ioutil.Discard, decompressedArchive)</div><div class="line"></div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"Error processing tar file(%v): %s"</span>, err, output)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里很有意思，invokeUnpack()调用的是docker-untar(todo: 为什么要通过reexec机制来解包，而不是直接解包，还有待研究)，打包数据流以stdin的方式传入。该实现使用Docker的reexec机制，所以必有注册的地方，来看/pkg/chrootarchive/init_unix.go：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</div><div class="line">	reexec.Register(<span class="string">"docker-applyLayer"</span>, applyLayer)</div><div class="line">	reexec.Register(<span class="string">"docker-untar"</span>, untar)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以docker的”docker-untar”由untar()函数完成功能执行，untar定义在/pkg/chrootarchive/archive_unix.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">untar</span><span class="params">()</span></span> &#123;</div><div class="line">	runtime.LockOSThread()</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	<span class="keyword">var</span> options *archive.TarOptions</div><div class="line"></div><div class="line">	<span class="comment">//read the options from the pipe "ExtraFiles"</span></div><div class="line">	<span class="keyword">if</span> err := json.NewDecoder(os.NewFile(<span class="number">3</span>, <span class="string">"options"</span>)).Decode(&amp;options); err != <span class="literal">nil</span> &#123;</div><div class="line">		fatal(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err := chroot(flag.Arg(<span class="number">0</span>)); err != <span class="literal">nil</span> &#123;</div><div class="line">		fatal(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//***从stdin中获取***//</span></div><div class="line">	<span class="keyword">if</span> err := archive.Unpack(os.Stdin, <span class="string">"/"</span>, options); err != <span class="literal">nil</span> &#123;</div><div class="line">		fatal(err)</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// fully consume stdin in case it is zero padded</span></div><div class="line">	<span class="keyword">if</span> _, err := flush(os.Stdin); err != <span class="literal">nil</span> &#123;</div><div class="line">		fatal(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	os.Exit(<span class="number">0</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>untar()会调用archive包的Unpack()实现从Stdin中解包数据。所以这里出现了archive包的Unpack()。Unpack()会把数据流解包到容器指定目录中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从容器向物理机拷贝：使用archive包的TarResourceRebase()进行容器中文件(或目录)的打包操作；使用archive包的CopyTo()函数完成数据流解包操作；<br>从物理机向容器拷贝：使用archive包的TarResource()对物理机上文件(或目录)进行打包；使用archive包的Unpack()把数据流解包到容器指定目录中。</p>
<p>下一次分析将介绍Docker的archive包。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://fankangbest.github.com/2017/12/27/Docker命令行分析-cp-v1-12-3/" data-id="cjbqdaqqv000674qsl54c1zgq" class="article-share-link">分享</a><div class="tags"><a href="/tags/docker/">docker</a><a href="/tags/docker-v1-12-3/">docker-v1.12.3</a></div><div class="post-nav"><a href="/2017/12/28/Docker工具包分析-archive-v1-12-3/" class="pre">Docker工具包分析-archive-v1.12.3</a><a href="/2017/12/26/tar-stream-demo/" class="next">tar-stream-demo</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://fankangbest.github.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/GO语言/">GO语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/存储虚拟化/">存储虚拟化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/容器虚拟化/">容器虚拟化</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/containerd-v0-2-4/" style="font-size: 15px;">containerd-v0.2.4</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/docker-v1-12-3/" style="font-size: 15px;">docker-v1.12.3</a> <a href="/tags/GO语言/" style="font-size: 15px;">GO语言</a> <a href="/tags/containerd/" style="font-size: 15px;">containerd</a> <a href="/tags/kubernetes-v1-5-2/" style="font-size: 15px;">kubernetes-v1.5.2</a> <a href="/tags/gRPC/" style="font-size: 15px;">gRPC</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/runc/" style="font-size: 15px;">runc</a> <a href="/tags/runc-v1-0-0-rc2/" style="font-size: 15px;">runc-v1.0.0-rc2</a> <a href="/tags/ceph/" style="font-size: 15px;">ceph</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/12/28/Docker工具包分析-archive-v1-12-3/">Docker工具包分析-archive-v1.12.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/27/Docker命令行分析-cp-v1-12-3/">Docker命令行分析-cp-v1.12.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/26/tar-stream-demo/">tar-stream-demo</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/25/Docker命令分行分析-run-v1-12-3/">Docker命令分行分析-run-v1.12.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/23/kubelet分析(七)-dockerManager(2)-v1-5-2/">kubelet分析(七)-dockerManager(2)-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/23/kubelet分析(七)-dockerManager(1)-v1-5-2/">kubelet分析(七)-dockerManager(1)-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/20/kubelet分析(六)-proberManager-v1-5-2/">kubelet分析(六)-proberManager-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/18/kubelet分析(五)-podManager-v1-5-2/">kubelet分析(五)-podManager-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/17/kubelet分析(四)-statusManager-v1-5-2/">kubelet分析(四)-statusManager-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/17/kubelet分析(三)-volumeManager-v1-5-2/">kubelet分析(三)-volumeManager-v1.5.2</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/fankangbest" title="myGithub" target="_blank">myGithub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">fankangbest.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>