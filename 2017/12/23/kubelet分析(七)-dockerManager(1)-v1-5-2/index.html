<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>kubelet分析(七)-dockerManager(1)-v1.5.2 | fankangbest</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">kubelet分析(七)-dockerManager(1)-v1.5.2</h1><a id="logo" href="/.">fankangbest</a><p class="description">多听，少说，接受每一个人的责难，但是保留自己的最后裁决。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">kubelet分析(七)-dockerManager(1)-v1.5.2</h1><div class="post-meta">Dec 23, 2017<span> | </span><span class="category"><a href="/categories/容器虚拟化/">容器虚拟化</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p>dockerManager负责在kubelet中与docker打交道。dockerManager会把pod的相关信息转换成具体的docker实现，并管理docker容器。在介绍dockerManager之前，先介绍dockerManager会用到的一些其他概念：containerGC, ExecHandler, imageStatsProvider及instrumentedDockerInterface，当然，这里介绍的概念的实现在kubelet中都是最底层的实现，都是基于docker runtime的。</p>
<p>先来看containerGC。</p>
<h2 id="containerGC"><a href="#containerGC" class="headerlink" title="containerGC"></a>containerGC</h2><p>containerGC的整体调用顺序为kubelet–container的containerGC–docker runtime的containerGC，这在以后分析。本次就介绍docker runtime的containerGC。<br>containerGC负责处理”dead”状态的容器的回收，当然，被回收的容器都是由kubelet创建的。<br>先来看下ContainerGCPolicy，定义在/pkg/kubelet/container/container_gc.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Specified a policy for garbage collecting containers.</span></div><div class="line"><span class="keyword">type</span> ContainerGCPolicy <span class="keyword">struct</span> &#123;</div><div class="line">	<span class="comment">// Minimum age at which a container can be garbage collected, zero for no limit.</span></div><div class="line">	MinAge time.Duration</div><div class="line"></div><div class="line">	<span class="comment">// Max number of dead containers any single pod (UID, container name) pair is</span></div><div class="line">	<span class="comment">// allowed to have, less than zero for no limit.</span></div><div class="line">	MaxPerPodContainer <span class="keyword">int</span></div><div class="line"></div><div class="line">	<span class="comment">// Max number of total dead containers, less than zero for no limit.</span></div><div class="line">	MaxContainers <span class="keyword">int</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>containerGC会依据ContainerGCPolicy中的MinAge, MaxPerPodContainer, MaxContainers三个字段来进行容器的回收，字段含义如下：</p>
<ul>
<li>MinAge: 容器状态成为”dead”后，过MinAge时间后都会被回收，由kubelet的–minimum-container-ttl-duration参数指定；</li>
<li>MaxPerPodContainer: 如果属于某个pod的”dead”状态容器数量超过此阈值，则消除超出的容器，由–kubelet的maximum-dead-containers-per-container参数指定；</li>
<li>MaxContainers: 如果”dead”状态的容器数量大于MaxContainers，则回收超出的部分，由kubelet的–maximum-dead-containers参数指定。</li>
</ul>
<p>注：kubelet的–minimum-container-ttl-duration, –kubelet的maximum-dead-containers-per-container, –maximum-dead-containers参数将由–eviction-soft及–eviction-hard代替。</p>
<p>docker runtime的containerGC定义在/pkg/kubelet/dockertools/container_gc.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> containerGC <span class="keyword">struct</span> &#123;</div><div class="line">	client           DockerInterface</div><div class="line">	podGetter        podGetter</div><div class="line">	containerLogsDir <span class="keyword">string</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以通过NewContainerGC()生成：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewContainerGC</span><span class="params">(client DockerInterface, podGetter podGetter, containerLogsDir <span class="keyword">string</span>)</span> *<span class="title">containerGC</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> &amp;containerGC&#123;</div><div class="line">		client:           client,</div><div class="line">		podGetter:        podGetter,</div><div class="line">		containerLogsDir: containerLogsDir,</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>docker runtime的containerGC实现有GarbageCollect()方法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***回收容器***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cgc *containerGC)</span> <span class="title">GarbageCollect</span><span class="params">(gcPolicy kubecontainer.ContainerGCPolicy, allSourcesReady <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="comment">// Separate containers by evict units.</span></div><div class="line">	<span class="comment">//***获取需要回收的容器***//</span></div><div class="line">	evictUnits, unidentifiedContainers, err := cgc.evictableContainers(gcPolicy.MinAge)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Remove unidentified containers.</span></div><div class="line">	<span class="comment">//***回收名称解析失败的"dead"容器***//</span></div><div class="line">	<span class="keyword">for</span> _, container := <span class="keyword">range</span> unidentifiedContainers &#123;</div><div class="line">		glog.Infof(<span class="string">"Removing unidentified dead container %q with ID %q"</span>, container.name, container.id)</div><div class="line">		err = cgc.client.RemoveContainer(container.id, dockertypes.ContainerRemoveOptions&#123;RemoveVolumes: <span class="literal">true</span>&#125;)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			glog.Warningf(<span class="string">"Failed to remove unidentified dead container %q: %v"</span>, container.name, err)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Remove deleted pod containers if all sources are ready.</span></div><div class="line">	<span class="comment">//***回收删除的容器***//</span></div><div class="line">	<span class="keyword">if</span> allSourcesReady &#123;</div><div class="line">		<span class="keyword">for</span> key, unit := <span class="keyword">range</span> evictUnits &#123;</div><div class="line">			<span class="keyword">if</span> cgc.isPodDeleted(key.uid) &#123;</div><div class="line">				cgc.removeOldestN(unit, <span class="built_in">len</span>(unit)) <span class="comment">// Remove all.</span></div><div class="line">				<span class="built_in">delete</span>(evictUnits, key)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Enforce max containers per evict unit.</span></div><div class="line">	<span class="comment">//***保证每个pod所属的"dead"容器数量在阈值内***//</span></div><div class="line">	<span class="keyword">if</span> gcPolicy.MaxPerPodContainer &gt;= <span class="number">0</span> &#123;</div><div class="line">		cgc.enforceMaxContainersPerEvictUnit(evictUnits, gcPolicy.MaxPerPodContainer)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Enforce max total number of containers.</span></div><div class="line">	<span class="comment">//***如果"daed"容器数量超过总的阈值，则取平均值计算每个evictUnits中可以保留的容器数量，清除超出部分***//</span></div><div class="line">	<span class="keyword">if</span> gcPolicy.MaxContainers &gt;= <span class="number">0</span> &amp;&amp; evictUnits.NumContainers() &gt; gcPolicy.MaxContainers &#123;</div><div class="line">		<span class="comment">// Leave an equal number of containers per evict unit (min: 1).</span></div><div class="line">		numContainersPerEvictUnit := gcPolicy.MaxContainers / evictUnits.NumEvictUnits()</div><div class="line">		<span class="keyword">if</span> numContainersPerEvictUnit &lt; <span class="number">1</span> &#123;</div><div class="line">			numContainersPerEvictUnit = <span class="number">1</span></div><div class="line">		&#125;</div><div class="line">		cgc.enforceMaxContainersPerEvictUnit(evictUnits, numContainersPerEvictUnit)</div><div class="line"></div><div class="line">		<span class="comment">// If we still need to evict, evict oldest first.</span></div><div class="line">		numContainers := evictUnits.NumContainers()</div><div class="line">		<span class="keyword">if</span> numContainers &gt; gcPolicy.MaxContainers &#123;</div><div class="line">			flattened := <span class="built_in">make</span>([]containerGCInfo, <span class="number">0</span>, numContainers)</div><div class="line">			<span class="keyword">for</span> uid := <span class="keyword">range</span> evictUnits &#123;</div><div class="line">				flattened = <span class="built_in">append</span>(flattened, evictUnits[uid]...)</div><div class="line">			&#125;</div><div class="line">			sort.Sort(byCreated(flattened))</div><div class="line"></div><div class="line">			cgc.removeOldestN(flattened, numContainers-gcPolicy.MaxContainers)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Remove dead symlinks - should only happen on upgrade</span></div><div class="line">	<span class="comment">// from a k8s version without proper log symlink cleanup</span></div><div class="line">	logSymlinks, _ := filepath.Glob(path.Join(cgc.containerLogsDir, fmt.Sprintf(<span class="string">"*.%s"</span>, LogSuffix)))</div><div class="line">	<span class="keyword">for</span> _, logSymlink := <span class="keyword">range</span> logSymlinks &#123;</div><div class="line">		<span class="keyword">if</span> _, err = os.Stat(logSymlink); os.IsNotExist(err) &#123;</div><div class="line">			err = os.Remove(logSymlink)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				glog.Warningf(<span class="string">"Failed to remove container log dead symlink %q: %v"</span>, logSymlink, err)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>GarbageCollect()流程如下：</p>
<ol>
<li>通过evictableContainers()获取”dead”时间超过阈值的容器；</li>
<li>回收对应pod已经被删除的容器；</li>
<li>调用enforceMaxContainersPerEvictUnit()保证每个podcontainer对应的”dead”容器数量在阈值内；</li>
<li>如果总的”dead”容器数量超出阈值，则计算每个podcontainer能保留的数量，调用enforceMaxContainersPerEvictUnit()回收超出部分。</li>
</ol>
<p>enforceMaxContainersPerEvictUnit()定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***如果podcontainer对应的"dead"状态的容器超过阈值，则回收超过阈值的容器***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cgc *containerGC)</span> <span class="title">enforceMaxContainersPerEvictUnit</span><span class="params">(evictUnits containersByEvictUnit, MaxContainers <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> uid := <span class="keyword">range</span> evictUnits &#123;</div><div class="line">		toRemove := <span class="built_in">len</span>(evictUnits[uid]) - MaxContainers</div><div class="line"></div><div class="line">		<span class="keyword">if</span> toRemove &gt; <span class="number">0</span> &#123;</div><div class="line">			evictUnits[uid] = cgc.removeOldestN(evictUnits[uid], toRemove)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Removes the oldest toRemove containers and returns the resulting slice.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cgc *containerGC)</span> <span class="title">removeOldestN</span><span class="params">(containers []containerGCInfo, toRemove <span class="keyword">int</span>)</span> []<span class="title">containerGCInfo</span></span> &#123;</div><div class="line">	<span class="comment">// Remove from oldest to newest (last to first).</span></div><div class="line">	numToKeep := <span class="built_in">len</span>(containers) - toRemove</div><div class="line">	<span class="keyword">for</span> i := numToKeep; i &lt; <span class="built_in">len</span>(containers); i++ &#123;</div><div class="line">		cgc.removeContainer(containers[i].id, containers[i].podNameWithNamespace, containers[i].containerName)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Assume we removed the containers so that we're not too aggressive.</span></div><div class="line">	<span class="keyword">return</span> containers[:numToKeep]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="ExecHandler"><a href="#ExecHandler" class="headerlink" title="ExecHandler"></a>ExecHandler</h2><p>ExecHandler可以在容器中执行一条命令。在docker runtime中，提供了nsenter和原生exec两种方式。<br>ExecHandler最开始在/pkg/kbuelet/kubelet.go中生成。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dockerExecHandler dockertools.ExecHandler</div><div class="line"><span class="keyword">switch</span> kubeCfg.DockerExecHandlerName &#123;</div><div class="line"><span class="keyword">case</span> <span class="string">"native"</span>:</div><div class="line">	dockerExecHandler = &amp;dockertools.NativeExecHandler&#123;&#125;</div><div class="line"><span class="keyword">case</span> <span class="string">"nsenter"</span>:</div><div class="line">	dockerExecHandler = &amp;dockertools.NsenterExecHandler&#123;&#125;</div><div class="line"><span class="keyword">default</span>:</div><div class="line">	glog.Warningf(<span class="string">"Unknown Docker exec handler %q; defaulting to native"</span>, kubeCfg.DockerExecHandlerName)</div><div class="line">	dockerExecHandler = &amp;dockertools.NativeExecHandler&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ExecHandler定义在/pkg/kubelet/dockertools/exec.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ExecHandler knows how to execute a command in a running Docker container.</span></div><div class="line"><span class="keyword">type</span> ExecHandler <span class="keyword">interface</span> &#123;</div><div class="line">	ExecInContainer(client DockerInterface, container *dockertypes.ContainerJSON, cmd []<span class="keyword">string</span>, stdin io.Reader, stdout, stderr io.WriteCloser, tty <span class="keyword">bool</span>, resize &lt;-<span class="keyword">chan</span> term.Size, timeout time.Duration) error</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可见，实现了ExecInContainer()方法的结构体都可以称为ExecHandler()。</p>
<h3 id="NsenterExecHandler"><a href="#NsenterExecHandler" class="headerlink" title="NsenterExecHandler"></a>NsenterExecHandler</h3><p>NsenterExecHandler使用nsenter命令在容器中执行命令，定义在/pkg/kubelet/dockertools/exec.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> NsenterExecHandler <span class="keyword">struct</span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>ExecInContainer()方法如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***在容器中执行命令***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*NsenterExecHandler)</span> <span class="title">ExecInContainer</span><span class="params">(client DockerInterface, container *dockertypes.ContainerJSON, cmd []<span class="keyword">string</span>, stdin io.Reader, stdout, stderr io.WriteCloser, tty <span class="keyword">bool</span>, resize &lt;-<span class="keyword">chan</span> term.Size, timeout time.Duration)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="comment">//***查找nsenter***//</span></div><div class="line">	nsenter, err := exec.LookPath(<span class="string">"nsenter"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"exec unavailable - unable to locate nsenter"</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//***获取容器的pid***//</span></div><div class="line">	containerPid := container.State.Pid</div><div class="line"></div><div class="line">	<span class="comment">// TODO what if the container doesn't have `env`???</span></div><div class="line">	args := []<span class="keyword">string</span>&#123;<span class="string">"-t"</span>, fmt.Sprintf(<span class="string">"%d"</span>, containerPid), <span class="string">"-m"</span>, <span class="string">"-i"</span>, <span class="string">"-u"</span>, <span class="string">"-n"</span>, <span class="string">"-p"</span>, <span class="string">"--"</span>, <span class="string">"env"</span>, <span class="string">"-i"</span>&#125;</div><div class="line">	args = <span class="built_in">append</span>(args, fmt.Sprintf(<span class="string">"HOSTNAME=%s"</span>, container.Config.Hostname))</div><div class="line">	args = <span class="built_in">append</span>(args, container.Config.Env...)</div><div class="line">	args = <span class="built_in">append</span>(args, cmd...)</div><div class="line">	command := exec.Command(nsenter, args...)</div><div class="line">	<span class="keyword">if</span> tty &#123;</div><div class="line">		p, err := kubecontainer.StartPty(command)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">defer</span> p.Close()</div><div class="line"></div><div class="line">		<span class="comment">// make sure to close the stdout stream</span></div><div class="line">		<span class="keyword">defer</span> stdout.Close()</div><div class="line"></div><div class="line">		kubecontainer.HandleResizing(resize, <span class="function"><span class="keyword">func</span><span class="params">(size term.Size)</span></span> &#123;</div><div class="line">			term.SetSize(p.Fd(), size)</div><div class="line">		&#125;)</div><div class="line"></div><div class="line">		<span class="keyword">if</span> stdin != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">go</span> io.Copy(p, stdin)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> stdout != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">go</span> io.Copy(stdout, p)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		err = command.Wait()</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">if</span> stdin != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="comment">// Use an os.Pipe here as it returns true *os.File objects.</span></div><div class="line">			<span class="comment">// This way, if you run 'kubectl exec &lt;pod&gt; -i bash' (no tty) and type 'exit',</span></div><div class="line">			<span class="comment">// the call below to command.Run() can unblock because its Stdin is the read half</span></div><div class="line">			<span class="comment">// of the pipe.</span></div><div class="line">			r, w, err := os.Pipe()</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> err</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">go</span> io.Copy(w, stdin)</div><div class="line"></div><div class="line">			command.Stdin = r</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> stdout != <span class="literal">nil</span> &#123;</div><div class="line">			command.Stdout = stdout</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> stderr != <span class="literal">nil</span> &#123;</div><div class="line">			command.Stderr = stderr</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		err = command.Run()</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> exitErr, ok := err.(*exec.ExitError); ok &#123;</div><div class="line">		<span class="keyword">return</span> &amp;utilexec.ExitErrorWrapper&#123;ExitError: exitErr&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> err</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="NativeExecHandler"><a href="#NativeExecHandler" class="headerlink" title="NativeExecHandler"></a>NativeExecHandler</h3><p>NativeExecHandler调用Docker提供的API在容器中执行命令，定义在/pkg/kubelet/dockertools/exec.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> NativeExecHandler <span class="keyword">struct</span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>ExecInContainer()定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*NativeExecHandler)</span> <span class="title">ExecInContainer</span><span class="params">(client DockerInterface, container *dockertypes.ContainerJSON, cmd []<span class="keyword">string</span>, stdin io.Reader, stdout, stderr io.WriteCloser, tty <span class="keyword">bool</span>, resize &lt;-<span class="keyword">chan</span> term.Size, timeout time.Duration)</span> <span class="title">error</span></span> &#123;</div><div class="line">	createOpts := dockertypes.ExecConfig&#123;</div><div class="line">		Cmd:          cmd,</div><div class="line">		AttachStdin:  stdin != <span class="literal">nil</span>,</div><div class="line">		AttachStdout: stdout != <span class="literal">nil</span>,</div><div class="line">		AttachStderr: stderr != <span class="literal">nil</span>,</div><div class="line">		Tty:          tty,</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//***创建exec***//</span></div><div class="line">	execObj, err := client.CreateExec(container.ID, createOpts)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to exec in container - Exec setup failed - %v"</span>, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Have to start this before the call to client.StartExec because client.StartExec is a blocking</span></div><div class="line">	<span class="comment">// call :-( Otherwise, resize events don't get processed and the terminal never resizes.</span></div><div class="line">	kubecontainer.HandleResizing(resize, <span class="function"><span class="keyword">func</span><span class="params">(size term.Size)</span></span> &#123;</div><div class="line">		client.ResizeExecTTY(execObj.ID, <span class="keyword">int</span>(size.Height), <span class="keyword">int</span>(size.Width))</div><div class="line">	&#125;)</div><div class="line"></div><div class="line">	startOpts := dockertypes.ExecStartCheck&#123;Detach: <span class="literal">false</span>, Tty: tty&#125;</div><div class="line">	streamOpts := StreamOptions&#123;</div><div class="line">		InputStream:  stdin,</div><div class="line">		OutputStream: stdout,</div><div class="line">		ErrorStream:  stderr,</div><div class="line">		RawTerminal:  tty,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//***启动exec***//</span></div><div class="line">	err = client.StartExec(execObj.ID, startOpts, streamOpts)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	ticker := time.NewTicker(<span class="number">2</span> * time.Second)</div><div class="line">	<span class="keyword">defer</span> ticker.Stop()</div><div class="line">	count := <span class="number">0</span></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		inspect, err2 := client.InspectExec(execObj.ID)</div><div class="line">		<span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> err2</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//***inspect的状态不为Running且ExitCode为0，则正常退出***//</span></div><div class="line">		<span class="keyword">if</span> !inspect.Running &#123;</div><div class="line">			<span class="keyword">if</span> inspect.ExitCode != <span class="number">0</span> &#123;</div><div class="line">				err = &amp;dockerExitError&#123;inspect&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		count++</div><div class="line">		<span class="keyword">if</span> count == <span class="number">5</span> &#123;</div><div class="line">			glog.Errorf(<span class="string">"Exec session %s in container %s terminated but process still running!"</span>, execObj.ID, container.ID)</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		&lt;-ticker.C</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> err</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="imageStatsProvider"><a href="#imageStatsProvider" class="headerlink" title="imageStatsProvider"></a>imageStatsProvider</h2><p>imageStatsProvider可以查看镜像信息，定义在/pkg/kubelet/dockertools/images.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// imageStatsProvider exposes stats about all images currently available.</span></div><div class="line"><span class="keyword">type</span> imageStatsProvider <span class="keyword">struct</span> &#123;</div><div class="line">	sync.Mutex</div><div class="line">	<span class="comment">// layers caches the current layers, key is the layer ID.</span></div><div class="line">	layers <span class="keyword">map</span>[<span class="keyword">string</span>]*dockertypes.ImageHistory</div><div class="line">	<span class="comment">// imageToLayerIDs maps image to its layer IDs.</span></div><div class="line">	imageToLayerIDs <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span></div><div class="line">	<span class="comment">// Docker remote API client</span></div><div class="line">	c DockerInterface</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">newImageStatsProvider</span><span class="params">(c DockerInterface)</span> *<span class="title">imageStatsProvider</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> &amp;imageStatsProvider&#123;</div><div class="line">		layers:          <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*dockertypes.ImageHistory),</div><div class="line">		imageToLayerIDs: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>),</div><div class="line">		c:               c,</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以通过ImageStats()方法查看镜像信息：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***查看镜像信息***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(isp *imageStatsProvider)</span> <span class="title">ImageStats</span><span class="params">()</span> <span class="params">(*runtime.ImageStats, error)</span></span> &#123;</div><div class="line">	images, err := isp.c.ListImages(dockertypes.ImageListOptions&#123;&#125;)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"failed to list docker images - %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// Take the lock to protect the cache</span></div><div class="line">	isp.Lock()</div><div class="line">	<span class="keyword">defer</span> isp.Unlock()</div><div class="line">	<span class="comment">// Create new cache each time, this is a little more memory consuming, but:</span></div><div class="line">	<span class="comment">// * ImageStats is only called every 10 seconds</span></div><div class="line">	<span class="comment">// * We use pointers and reference to copy cache elements.</span></div><div class="line">	<span class="comment">// The memory usage should be acceptable.</span></div><div class="line">	<span class="comment">// TODO(random-liu): Add more logic to implement in place cache update.</span></div><div class="line">	newLayers := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*dockertypes.ImageHistory)</div><div class="line">	newImageToLayerIDs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</div><div class="line">	<span class="keyword">for</span> _, image := <span class="keyword">range</span> images &#123;</div><div class="line">		layerIDs, ok := isp.imageToLayerIDs[image.ID]</div><div class="line">		<span class="keyword">if</span> !ok &#123;</div><div class="line">			<span class="comment">// Get information about the various layers of the given docker image.</span></div><div class="line">			history, err := isp.c.ImageHistory(image.ID)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="comment">// Skip the image and inspect again in next ImageStats if the image is still there</span></div><div class="line">				glog.V(<span class="number">2</span>).Infof(<span class="string">"failed to get history of docker image %+v - %v"</span>, image, err)</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">			<span class="comment">// Cache each layer</span></div><div class="line">			<span class="keyword">for</span> i := <span class="keyword">range</span> history &#123;</div><div class="line">				layer := &amp;history[i]</div><div class="line">				key := layer.ID</div><div class="line">				<span class="comment">// Some of the layers are empty.</span></div><div class="line">				<span class="comment">// We are hoping that these layers are unique to each image.</span></div><div class="line">				<span class="comment">// Still keying with the CreatedBy field to be safe.</span></div><div class="line">				<span class="keyword">if</span> key == <span class="string">""</span> || key == <span class="string">"&lt;missing&gt;"</span> &#123;</div><div class="line">					key = key + layer.CreatedBy</div><div class="line">				&#125;</div><div class="line">				layerIDs = <span class="built_in">append</span>(layerIDs, key)</div><div class="line">				newLayers[key] = layer</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">for</span> _, layerID := <span class="keyword">range</span> layerIDs &#123;</div><div class="line">				newLayers[layerID] = isp.layers[layerID]</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		newImageToLayerIDs[image.ID] = layerIDs</div><div class="line">	&#125;</div><div class="line">	ret := &amp;runtime.ImageStats&#123;&#125;</div><div class="line">	<span class="comment">// Calculate the total storage bytes</span></div><div class="line">	<span class="keyword">for</span> _, layer := <span class="keyword">range</span> newLayers &#123;</div><div class="line">		ret.TotalStorageBytes += <span class="keyword">uint64</span>(layer.Size)</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// Update current cache</span></div><div class="line">	isp.layers = newLayers</div><div class="line">	isp.imageToLayerIDs = newImageToLayerIDs</div><div class="line">	<span class="keyword">return</span> ret, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="instrumentedDockerInterface"><a href="#instrumentedDockerInterface" class="headerlink" title="instrumentedDockerInterface"></a>instrumentedDockerInterface</h2><p>instrumentedDockerInterface是对kubeDockerClient的封装，提供了记录功能，定义在/pkg/kubelet/dockertools/instrumented_docker.go中：<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> instrumentedDockerInterface <span class="keyword">struct</span> &#123;</div><div class="line">	client DockerInterface</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Creates an instrumented DockerInterface from an existing DockerInterface.</span></div><div class="line"><span class="comment">//***生成InstrumentedDockerInterface***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewInstrumentedDockerInterface</span><span class="params">(dockerClient DockerInterface)</span> <span class="title">DockerInterface</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> instrumentedDockerInterface&#123;</div><div class="line">		client: dockerClient,</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>记录函数定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// recordOperation records the duration of the operation.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">recordOperation</span><span class="params">(operation <span class="keyword">string</span>, start time.Time)</span></span> &#123;</div><div class="line">	metrics.DockerOperations.WithLabelValues(operation).Inc()</div><div class="line">	metrics.DockerOperationsLatency.WithLabelValues(operation).Observe(metrics.SinceInMicroseconds(start))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// recordError records error for metric if an error occurred.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">recordError</span><span class="params">(operation <span class="keyword">string</span>, err error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">if</span> _, ok := err.(operationTimeout); ok &#123;</div><div class="line">			metrics.DockerOperationsTimeout.WithLabelValues(operation).Inc()</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// Docker operation timeout error is also a docker error, so we don't add else here.</span></div><div class="line">		metrics.DockerOperationsErrors.WithLabelValues(operation).Inc()</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如在ListContainers()中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***列出containers***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(in instrumentedDockerInterface)</span> <span class="title">ListContainers</span><span class="params">(options dockertypes.ContainerListOptions)</span> <span class="params">([]dockertypes.Container, error)</span></span> &#123;</div><div class="line">	<span class="keyword">const</span> operation = <span class="string">"list_containers"</span></div><div class="line">	<span class="keyword">defer</span> recordOperation(operation, time.Now())</div><div class="line"></div><div class="line">	out, err := in.client.ListContainers(options)</div><div class="line">	recordError(operation, err)</div><div class="line">	<span class="keyword">return</span> out, err</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>instrumentedDockerInterface具体的封装这里不做详细介绍，比较是DockerManager作为runtime供kubelet调用的。</p>
<p>再来看下instrumentedDockerInterface中的client是如何生成的。</p>
<p>该client可以由ConnectToDockerOrDie()生成，定义在/pkg/kbuelet/dockertools/docker.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConnectToDockerOrDie</span><span class="params">(dockerEndpoint <span class="keyword">string</span>, requestTimeout time.Duration)</span> <span class="title">DockerInterface</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> dockerEndpoint == <span class="string">"fake://"</span> &#123;</div><div class="line">		<span class="keyword">return</span> NewFakeDockerClient()</div><div class="line">	&#125;</div><div class="line">	client, err := getDockerClient(dockerEndpoint)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		glog.Fatalf(<span class="string">"Couldn't connect to docker: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	glog.Infof(<span class="string">"Start docker client with request timeout=%v"</span>, requestTimeout)</div><div class="line">	<span class="keyword">return</span> newKubeDockerClient(client, requestTimeout)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//***如果有dockerEndpoint，则通过dockerEndpoint生成docker client; 否则通过环境变量生成docker client***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDockerClient</span><span class="params">(dockerEndpoint <span class="keyword">string</span>)</span> <span class="params">(*dockerapi.Client, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(dockerEndpoint) &gt; <span class="number">0</span> &#123;</div><div class="line">		glog.Infof(<span class="string">"Connecting to docker on %s"</span>, dockerEndpoint)</div><div class="line">		<span class="keyword">return</span> dockerapi.NewClient(dockerEndpoint, <span class="string">""</span>, <span class="literal">nil</span>, <span class="literal">nil</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> dockerapi.NewEnvClient()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ConnectToDockerOrDie()调用了getDockerClient()生成一个client，再调用newKubeDockerClient()生成一个新的client。<br>newKubeDockerClient()定义在/kube_docker_client.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// newKubeDockerClient creates an kubeDockerClient from an existing docker client. If requestTimeout is 0,</span></div><div class="line"><span class="comment">// defaultTimeout will be applied.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">newKubeDockerClient</span><span class="params">(dockerClient *dockerapi.Client, requestTimeout time.Duration)</span> <span class="title">DockerInterface</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> requestTimeout == <span class="number">0</span> &#123;</div><div class="line">		requestTimeout = defaultTimeout</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	k := &amp;kubeDockerClient&#123;</div><div class="line">		client:  dockerClient,</div><div class="line">		timeout: requestTimeout,</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// Notice that this assumes that docker is running before kubelet is started.</span></div><div class="line">	v, err := k.Version()</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		glog.Errorf(<span class="string">"failed to retrieve docker version: %v"</span>, err)</div><div class="line">		glog.Warningf(<span class="string">"Using empty version for docker client, this may sometimes cause compatibility issue."</span>)</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">// Update client version with real api version.</span></div><div class="line">		dockerClient.UpdateClientVersion(v.APIVersion)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> k</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>newKubeDockerClient在原生client的基础上添加了超时机制。KubeDockerClient提供了对容器的操作方法。</p>
<p>所以，关于client，KubeDockerClient在Docker原生client基础上添加了超时机制；instrumentedDockerInterface又在KubeDockerClient的基础上添加了记录功能。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://fankangbest.github.com/2017/12/23/kubelet分析(七)-dockerManager(1)-v1-5-2/" data-id="cjbnggj6400695sqsftls0eg5" class="article-share-link">分享</a><div class="tags"><a href="/tags/kubernetes/">kubernetes</a><a href="/tags/kubernetes-v1-5-2/">kubernetes-v1.5.2</a></div><div class="post-nav"><a href="/2017/12/23/kubelet分析(七)-dockerManager(2)-v1-5-2/" class="pre">kubelet分析(七)-dockerManager(2)-v1.5.2</a><a href="/2017/12/20/kubelet分析(六)-proberManager-v1-5-2/" class="next">kubelet分析(六)-proberManager-v1.5.2</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://fankangbest.github.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/GO语言/">GO语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/存储虚拟化/">存储虚拟化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/容器虚拟化/">容器虚拟化</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/containerd-v0-2-4/" style="font-size: 15px;">containerd-v0.2.4</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/docker-v1-12-3/" style="font-size: 15px;">docker-v1.12.3</a> <a href="/tags/GO语言/" style="font-size: 15px;">GO语言</a> <a href="/tags/containerd/" style="font-size: 15px;">containerd</a> <a href="/tags/kubernetes-v1-5-2/" style="font-size: 15px;">kubernetes-v1.5.2</a> <a href="/tags/gRPC/" style="font-size: 15px;">gRPC</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/runc/" style="font-size: 15px;">runc</a> <a href="/tags/runc-v1-0-0-rc2/" style="font-size: 15px;">runc-v1.0.0-rc2</a> <a href="/tags/ceph/" style="font-size: 15px;">ceph</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/12/26/tar-stream-demo/">tar-stream-demo</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/25/Docker命令分行分析-run-v1-12-3/">Docker命令分行分析-run-v1.12.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/23/kubelet分析(七)-dockerManager(2)-v1-5-2/">kubelet分析(七)-dockerManager(2)-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/23/kubelet分析(七)-dockerManager(1)-v1-5-2/">kubelet分析(七)-dockerManager(1)-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/20/kubelet分析(六)-proberManager-v1-5-2/">kubelet分析(六)-proberManager-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/18/kubelet分析(五)-podManager-v1-5-2/">kubelet分析(五)-podManager-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/17/kubelet分析(四)-statusManager-v1-5-2/">kubelet分析(四)-statusManager-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/17/kubelet分析(三)-volumeManager-v1-5-2/">kubelet分析(三)-volumeManager-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/16/kubelet分析(二)-podWorker-v1-5-2/">kubelet分析(二)-podWorker-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/16/kubelet分析(一)-config-v1-5-2/">kubelet分析(一)-config-v1.5.2</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/fankangbest" title="myGithub" target="_blank">myGithub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">fankangbest.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>