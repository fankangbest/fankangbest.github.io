<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>kubernetes-listwatch机制-v1.5.2 | fankangbest</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">kubernetes-listwatch机制-v1.5.2</h1><a id="logo" href="/.">fankangbest</a><p class="description">多听，少说，接受每一个人的责难，但是保留自己的最后裁决。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">kubernetes-listwatch机制-v1.5.2</h1><div class="post-meta">Dec 14, 2017<span> | </span><span class="category"><a href="/categories/容器虚拟化/">容器虚拟化</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>之前，我们分析过Kubernetes的reflect机制。reflector可以消费watch channel中的内容，并存储到store中。本次分析就将介绍Kubernetes的listwatch机制的主要调用流程，将按下面两部分进行分析：</p>
<ol>
<li>组件向apiserver请求；</li>
<li>apiserver向ETCD请求。</li>
</ol>
<p>首先，介绍组件向apiserver人listwatch请求。让我们来看个例子，在/pkg/kubelet/config/apiserver.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NewSourceApiserver creates a config source that watches and pulls from the apiserver.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSourceApiserver</span><span class="params">(c *clientset.Clientset, nodeName types.NodeName, updates <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">	<span class="comment">//***创建apiserver的listwatch***//</span></div><div class="line">	lw := cache.NewListWatchFromClient(c.Core().RESTClient(), <span class="string">"pods"</span>, api.NamespaceAll, fields.OneTermEqualSelector(api.PodHostField, <span class="keyword">string</span>(nodeName)))</div><div class="line">	newSourceApiserverFromLW(lw, updates)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以很明显看出，listwatch可以使用<code>lw := cache.NewListWatchFromClient(c.Core().RESTClient(), &quot;pods&quot;, api.NamespaceAll, fields.OneTermEqualSelector(api.PodHostField, string(nodeName)))</code>生成。<br>所以，先来看ListWatch的定义。</p>
<h2 id="ListWatch"><a href="#ListWatch" class="headerlink" title="ListWatch"></a>ListWatch</h2><p>ListWatch定义在/pkg/client/cache/listwatch.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ListerWatcher is any object that knows how to perform an initial list and start a watch on a resource.</span></div><div class="line"><span class="comment">//***ListerWatcher接口，只要有List()和Watch()即可***//</span></div><div class="line"><span class="keyword">type</span> ListerWatcher <span class="keyword">interface</span> &#123;</div><div class="line">	<span class="comment">// List should return a list type object; the Items field will be extracted, and the</span></div><div class="line">	<span class="comment">// ResourceVersion field will be used to start the watch in the right place.</span></div><div class="line">	List(options api.ListOptions) (runtime.Object, error)</div><div class="line">	<span class="comment">// Watch should begin a watch at the specified version.</span></div><div class="line">	Watch(options api.ListOptions) (watch.Interface, error)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ListFunc knows how to list resources</span></div><div class="line"><span class="keyword">type</span> ListFunc <span class="function"><span class="keyword">func</span><span class="params">(options api.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span></div><div class="line"></div><div class="line">// <span class="title">WatchFunc</span> <span class="title">knows</span> <span class="title">how</span> <span class="title">to</span> <span class="title">watch</span> <span class="title">resources</span></div><div class="line"><span class="title">type</span> <span class="title">WatchFunc</span> <span class="title">func</span><span class="params">(options api.ListOptions)</span> <span class="params">(watch.Interface, error)</span></div><div class="line"></div><div class="line">// <span class="title">ListWatch</span> <span class="title">knows</span> <span class="title">how</span> <span class="title">to</span> <span class="title">list</span> <span class="title">and</span> <span class="title">watch</span> <span class="title">a</span> <span class="title">set</span> <span class="title">of</span> <span class="title">apiserver</span> <span class="title">resources</span>.  <span class="title">It</span> <span class="title">satisfies</span> <span class="title">the</span> <span class="title">ListerWatcher</span> <span class="title">interface</span>.</div><div class="line">// <span class="title">It</span> <span class="title">is</span> <span class="title">a</span> <span class="title">convenience</span> <span class="title">function</span> <span class="title">for</span> <span class="title">users</span> <span class="title">of</span> <span class="title">NewReflector</span>, <span class="title">etc</span>.</div><div class="line">// <span class="title">ListFunc</span> <span class="title">and</span> <span class="title">WatchFunc</span> <span class="title">must</span> <span class="title">not</span> <span class="title">be</span> <span class="title">nil</span></div><div class="line"><span class="title">type</span> <span class="title">ListWatch</span> <span class="title">struct</span> &#123;</div><div class="line">	ListFunc  ListFunc</div><div class="line">	WatchFunc WatchFunc</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以，只要实现了List()和Watch()的结构体都可以称为ListerWatcher。而ListWatch结构体内刚好有ListFunc和WatchFunc成员，也实现了List()和Watch()：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// List a set of apiserver resources</span></div><div class="line"><span class="comment">//***执行List操作***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lw *ListWatch)</span> <span class="title">List</span><span class="params">(options api.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> lw.ListFunc(options)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Watch a set of apiserver resources</span></div><div class="line"><span class="comment">//***执行Watch操作***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lw *ListWatch)</span> <span class="title">Watch</span><span class="params">(options api.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> lw.WatchFunc(options)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>List()和Watch()分别调用了ListFunc()和WatchFunc()。再来看ListWatch的生成方法，即上面提到的NewListWatchFromClient()：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NewListWatchFromClient creates a new ListWatch from the specified client, resource, namespace and field selector.</span></div><div class="line"><span class="comment">//***使用client的方法来组建ListWatch，并返回***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewListWatchFromClient</span><span class="params">(c Getter, resource <span class="keyword">string</span>, namespace <span class="keyword">string</span>, fieldSelector fields.Selector)</span> *<span class="title">ListWatch</span></span> &#123;</div><div class="line">	listFunc := <span class="function"><span class="keyword">func</span><span class="params">(options api.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</div><div class="line">		<span class="keyword">return</span> c.Get().</div><div class="line">			Namespace(namespace).</div><div class="line">			Resource(resource).</div><div class="line">			VersionedParams(&amp;options, api.ParameterCodec).</div><div class="line">			FieldsSelectorParam(fieldSelector).</div><div class="line">			Do().</div><div class="line">			Get()</div><div class="line">	&#125;</div><div class="line">	watchFunc := <span class="function"><span class="keyword">func</span><span class="params">(options api.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</div><div class="line">		<span class="keyword">return</span> c.Get().</div><div class="line">			Prefix(<span class="string">"watch"</span>).</div><div class="line">			Namespace(namespace).</div><div class="line">			Resource(resource).</div><div class="line">			VersionedParams(&amp;options, api.ParameterCodec).</div><div class="line">			FieldsSelectorParam(fieldSelector).</div><div class="line">			Watch()</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> &amp;ListWatch&#123;ListFunc: listFunc, WatchFunc: watchFunc&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，NewListWatchFromClient()会依据参数来构造listFunc和watchFunc，其中参数c可以为c.Core().RESTClient()。<br>所以，接下来来看RESTClient。</p>
<h2 id="RESTClient"><a href="#RESTClient" class="headerlink" title="RESTClient"></a>RESTClient</h2><p>RESTClient在”kubernetes-client分析(二)-restclient-v1.5.2”进行了分析，但未对watch进行详细介绍。所以，在该小节中会具体介绍watch()方法，定义在/pkg/client/restclient/request.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Watch attempts to begin watching the requested location.</span></div><div class="line"><span class="comment">// Returns a watch.Interface, or an error.</span></div><div class="line"><span class="comment">//***Watch实现***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">Watch</span><span class="params">()</span> <span class="params">(watch.Interface, error)</span></span> &#123;</div><div class="line">	<span class="comment">// We specifically don't want to rate limit watches, so we</span></div><div class="line">	<span class="comment">// don't use r.throttle here.</span></div><div class="line">	<span class="keyword">if</span> r.err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, r.err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> r.serializers.Framer == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"watching resources is not possible with this client (content-type: %s)"</span>, r.content.ContentType)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	url := r.URL().String()</div><div class="line">	req, err := http.NewRequest(r.verb, url, r.body)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	req.Header = r.headers</div><div class="line">	client := r.client</div><div class="line">	<span class="keyword">if</span> client == <span class="literal">nil</span> &#123;</div><div class="line">		client = http.DefaultClient</div><div class="line">	&#125;</div><div class="line">	r.backoffMgr.Sleep(r.backoffMgr.CalculateBackoff(r.URL()))</div><div class="line">	resp, err := client.Do(req)</div><div class="line">	updateURLMetrics(r, resp, err)</div><div class="line">	<span class="keyword">if</span> r.baseURL != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			r.backoffMgr.UpdateBackoff(r.baseURL, err, <span class="number">0</span>)</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			r.backoffMgr.UpdateBackoff(r.baseURL, err, resp.StatusCode)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="comment">// The watch stream mechanism handles many common partial data errors, so closed</span></div><div class="line">		<span class="comment">// connections can be retried in many cases.</span></div><div class="line">		<span class="keyword">if</span> net.IsProbableEOF(err) &#123;</div><div class="line">			<span class="keyword">return</span> watch.NewEmptyWatch(), <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> resp.StatusCode != http.StatusOK &#123;</div><div class="line">		<span class="keyword">defer</span> resp.Body.Close()</div><div class="line">		<span class="keyword">if</span> result := r.transformResponse(resp, req); result.err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, result.err</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"for request '%+v', got status: %v"</span>, url, resp.StatusCode)</div><div class="line">	&#125;</div><div class="line">	framer := r.serializers.Framer.NewFrameReader(resp.Body)</div><div class="line">	decoder := streaming.NewDecoder(framer, r.serializers.StreamingSerializer)</div><div class="line">	<span class="comment">//***返回的是StreamWatcher***//</span></div><div class="line">	<span class="keyword">return</span> watch.NewStreamWatcher(versioned.NewDecoder(decoder, r.serializers.Decoder)), <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，代码先执行请求，然后把请求体的response封装成decoder，然后调用watch.NewStreamWatcher()来生成一个stream watcher。</p>
<h2 id="StreamWatcher"><a href="#StreamWatcher" class="headerlink" title="StreamWatcher()"></a>StreamWatcher()</h2><p>StreamWatcher定义在/pkg/watch/streamwatcher.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// StreamWatcher turns any stream for which you can write a Decoder interface</span></div><div class="line"><span class="comment">// into a watch.Interface.</span></div><div class="line"><span class="keyword">type</span> StreamWatcher <span class="keyword">struct</span> &#123;</div><div class="line">	sync.Mutex</div><div class="line">	source  Decoder</div><div class="line">	result  <span class="keyword">chan</span> Event</div><div class="line">	stopped <span class="keyword">bool</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>StreamWatcher可以从source中获取event，并存储到result chan中。来看StreamWatch的生成函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NewStreamWatcher creates a StreamWatcher from the given decoder.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStreamWatcher</span><span class="params">(d Decoder)</span> *<span class="title">StreamWatcher</span></span> &#123;</div><div class="line">	sw := &amp;StreamWatcher&#123;</div><div class="line">		source: d,</div><div class="line">		<span class="comment">// It's easy for a consumer to add buffering via an extra</span></div><div class="line">		<span class="comment">// goroutine/channel, but impossible for them to remove it,</span></div><div class="line">		<span class="comment">// so nonbuffered is better.</span></div><div class="line">		result: <span class="built_in">make</span>(<span class="keyword">chan</span> Event),</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">go</span> sw.receive()</div><div class="line">	<span class="keyword">return</span> sw</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>NewStreamWatcher()在生成StreamWAtcher后，会启动receive()。receive()定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// receive reads result from the decoder in a loop and sends down the result channel.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sw *StreamWatcher)</span> <span class="title">receive</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">//***在defer中关闭result channel***//</span></div><div class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(sw.result)</div><div class="line">	<span class="keyword">defer</span> sw.Stop()</div><div class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		action, obj, err := sw.source.Decode()</div><div class="line">		<span class="comment">//***如果发生错误，则直接返回***//</span></div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="comment">// Ignore expected error.</span></div><div class="line">			<span class="keyword">if</span> sw.stopping() &#123;</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">switch</span> err &#123;</div><div class="line">			<span class="keyword">case</span> io.EOF:</div><div class="line">				<span class="comment">// watch closed normally</span></div><div class="line">			<span class="keyword">case</span> io.ErrUnexpectedEOF:</div><div class="line">				glog.V(<span class="number">1</span>).Infof(<span class="string">"Unexpected EOF during watch stream event decoding: %v"</span>, err)</div><div class="line">			<span class="keyword">default</span>:</div><div class="line">				msg := <span class="string">"Unable to decode an event from the watch stream: %v"</span></div><div class="line">				<span class="keyword">if</span> net.IsProbableEOF(err) &#123;</div><div class="line">					glog.V(<span class="number">5</span>).Infof(msg, err)</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					glog.Errorf(msg, err)</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">//***把Event放入result***//</span></div><div class="line">		sw.result &lt;- Event&#123;</div><div class="line">			Type:   action,</div><div class="line">			Object: obj,</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在receive()中，先从source中解码出obj，然后把obj封装成Event，并放入到result channel中。<br>现在result channel中已经有来自apiserver的Event，那么还得定义一个方法返回result channel供调用方消费：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ResultChan implements Interface.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sw *StreamWatcher)</span> <span class="title">ResultChan</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">Event</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> sw.result</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ResultChan()就是用来返回StreamWatcher的result channel。每个watcher结构体都会定义ResultChan()用来返回result channel。<br>关于如何从stream中获取一个obj，以后分析，其最后也是调用了json包。json包解析stream中的数据详见”kubernetes-watcher-demo”。</p>
<p>现在组件已经各apiserver建立了联接，并对联接中数据流中的数据进行解析。所以接下来看apiserver是如何进行watch响应的。</p>
<h2 id="apiserver"><a href="#apiserver" class="headerlink" title="apiserver"></a>apiserver</h2><p>apiserver的listwatch由ListResource() resthandler承担，定义在/pkg/apiserver/resthandler.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ListResource returns a function that handles retrieving a list of resources from a rest.Storage object.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListResource</span><span class="params">(r rest.Lister, rw rest.Watcher, scope RequestScope, forceWatch <span class="keyword">bool</span>, minRequestTimeout time.Duration)</span> <span class="title">restful</span>.<span class="title">RouteFunction</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(req *restful.Request, res *restful.Response)</span></span> &#123;</div><div class="line">		<span class="comment">// For performance tracking purposes.</span></div><div class="line">		trace := util.NewTrace(<span class="string">"List "</span> + req.Request.URL.Path)</div><div class="line"></div><div class="line">		w := res.ResponseWriter</div><div class="line"></div><div class="line">		<span class="comment">//***获取namespace***//</span></div><div class="line">		namespace, err := scope.Namer.Namespace(req)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			scope.err(err, res.ResponseWriter, req.Request)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// Watches for single objects are routed to this function.</span></div><div class="line">		<span class="comment">// Treat a /name parameter the same as a field selector entry.</span></div><div class="line">		hasName := <span class="literal">true</span></div><div class="line">		_, name, err := scope.Namer.Name(req)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			hasName = <span class="literal">false</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		ctx := scope.ContextFunc(req)</div><div class="line">		<span class="comment">//***设置namespace key***//</span></div><div class="line">		ctx = api.WithNamespace(ctx, namespace)</div><div class="line"></div><div class="line">		opts := api.ListOptions&#123;&#125;</div><div class="line">		<span class="keyword">if</span> err := scope.ParameterCodec.DecodeParameters(req.Request.URL.Query(), scope.Kind.GroupVersion(), &amp;opts); err != <span class="literal">nil</span> &#123;</div><div class="line">			scope.err(err, res.ResponseWriter, req.Request)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// transform fields</span></div><div class="line">		<span class="comment">// <span class="doctag">TODO:</span> DecodeParametersInto should do this.</span></div><div class="line">		<span class="keyword">if</span> opts.FieldSelector != <span class="literal">nil</span> &#123;</div><div class="line">			fn := <span class="function"><span class="keyword">func</span><span class="params">(label, value <span class="keyword">string</span>)</span> <span class="params">(newLabel, newValue <span class="keyword">string</span>, err error)</span></span> &#123;</div><div class="line">				<span class="keyword">return</span> scope.Convertor.ConvertFieldLabel(scope.Kind.GroupVersion().String(), scope.Kind.Kind, label, value)</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> opts.FieldSelector, err = opts.FieldSelector.Transform(fn); err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="comment">// <span class="doctag">TODO:</span> allow bad request to set field causes based on query parameters</span></div><div class="line">				err = errors.NewBadRequest(err.Error())</div><div class="line">				scope.err(err, res.ResponseWriter, req.Request)</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> hasName &#123;</div><div class="line">			<span class="comment">// metadata.name is the canonical internal name.</span></div><div class="line">			<span class="comment">// SelectionPredicate will notice that this is</span></div><div class="line">			<span class="comment">// a request for a single object and optimize the</span></div><div class="line">			<span class="comment">// storage query accordingly.</span></div><div class="line">			nameSelector := fields.OneTermEqualSelector(<span class="string">"metadata.name"</span>, name)</div><div class="line">			<span class="keyword">if</span> opts.FieldSelector != <span class="literal">nil</span> &amp;&amp; !opts.FieldSelector.Empty() &#123;</div><div class="line">				<span class="comment">// It doesn't make sense to ask for both a name</span></div><div class="line">				<span class="comment">// and a field selector, since just the name is</span></div><div class="line">				<span class="comment">// sufficient to narrow down the request to a</span></div><div class="line">				<span class="comment">// single object.</span></div><div class="line">				scope.err(errors.NewBadRequest(<span class="string">"both a name and a field selector provided; please provide one or the other."</span>), res.ResponseWriter, req.Request)</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">			opts.FieldSelector = nameSelector</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (opts.Watch || forceWatch) &amp;&amp; rw != <span class="literal">nil</span> &#123;</div><div class="line">			watcher, err := rw.Watch(ctx, &amp;opts)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				scope.err(err, res.ResponseWriter, req.Request)</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">			<span class="comment">// <span class="doctag">TODO:</span> Currently we explicitly ignore ?timeout= and use only ?timeoutSeconds=.</span></div><div class="line">			timeout := time.Duration(<span class="number">0</span>)</div><div class="line">			<span class="keyword">if</span> opts.TimeoutSeconds != <span class="literal">nil</span> &#123;</div><div class="line">				timeout = time.Duration(*opts.TimeoutSeconds) * time.Second</div><div class="line">			&#125;</div><div class="line">			<span class="comment">//***设置timeout***//</span></div><div class="line">			<span class="keyword">if</span> timeout == <span class="number">0</span> &amp;&amp; minRequestTimeout &gt; <span class="number">0</span> &#123;</div><div class="line">				timeout = time.Duration(<span class="keyword">float64</span>(minRequestTimeout) * (rand.Float64() + <span class="number">1.0</span>))</div><div class="line">			&#125;</div><div class="line">			serveWatch(watcher, scope, req, res, timeout)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// Log only long List requests (ignore Watch).</span></div><div class="line">		<span class="keyword">defer</span> trace.LogIfLong(<span class="number">500</span> * time.Millisecond)</div><div class="line">		trace.Step(<span class="string">"About to List from storage"</span>)</div><div class="line">		<span class="comment">//***获取list result***//</span></div><div class="line">		result, err := r.List(ctx, &amp;opts)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			scope.err(err, res.ResponseWriter, req.Request)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">		trace.Step(<span class="string">"Listing from storage done"</span>)</div><div class="line">		numberOfItems, err := setListSelfLink(result, req, scope.Namer)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			scope.err(err, res.ResponseWriter, req.Request)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">		trace.Step(<span class="string">"Self-linking done"</span>)</div><div class="line">		write(http.StatusOK, scope.Kind.GroupVersion(), scope.Serializer, result, w, req.Request)</div><div class="line">		trace.Step(fmt.Sprintf(<span class="string">"Writing http response done (%d items)"</span>, numberOfItems))</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ListResource()中包含了list操作和watch操作。list操作比较简单，直接调用storage的List()。watch操作主要调用了serveWatch()，还定义了超时时间，定义在/pkg/apiserver/watch.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// serveWatch handles serving requests to the server</span></div><div class="line"><span class="comment">// <span class="doctag">TODO:</span> the functionality in this method and in WatchServer.Serve is not cleanly decoupled.</span></div><div class="line"><span class="comment">//***Fankang***//</span></div><div class="line"><span class="comment">//***Watch()实现函数***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveWatch</span><span class="params">(watcher watch.Interface, scope RequestScope, req *restful.Request, res *restful.Response, timeout time.Duration)</span></span> &#123;</div><div class="line">	<span class="comment">// negotiate for the stream serializer</span></div><div class="line">	serializer, err := negotiateOutputStreamSerializer(req.Request, scope.Serializer)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		scope.err(err, res.ResponseWriter, req.Request)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	framer := serializer.StreamSerializer.Framer</div><div class="line">	streamSerializer := serializer.StreamSerializer.Serializer</div><div class="line">	embedded := serializer.Serializer</div><div class="line">	<span class="keyword">if</span> framer == <span class="literal">nil</span> &#123;</div><div class="line">		scope.err(fmt.Errorf(<span class="string">"no framer defined for %q available for embedded encoding"</span>, serializer.MediaType), res.ResponseWriter, req.Request)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	encoder := scope.Serializer.EncoderForVersion(streamSerializer, scope.Kind.GroupVersion())</div><div class="line"></div><div class="line">	useTextFraming := serializer.EncodesAsText</div><div class="line"></div><div class="line">	<span class="comment">// find the embedded serializer matching the media type</span></div><div class="line">	embeddedEncoder := scope.Serializer.EncoderForVersion(embedded, scope.Kind.GroupVersion())</div><div class="line"></div><div class="line">	<span class="comment">// <span class="doctag">TODO:</span> next step, get back mediaTypeOptions from negotiate and return the exact value here</span></div><div class="line">	mediaType := serializer.MediaType</div><div class="line">	<span class="keyword">if</span> mediaType != runtime.ContentTypeJSON &#123;</div><div class="line">		mediaType += <span class="string">";stream=watch"</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	server := &amp;WatchServer&#123;</div><div class="line">		watching: watcher,</div><div class="line">		scope:    scope,</div><div class="line"></div><div class="line">		useTextFraming:  useTextFraming,</div><div class="line">		mediaType:       mediaType,</div><div class="line">		framer:          framer,</div><div class="line">		encoder:         encoder,</div><div class="line">		embeddedEncoder: embeddedEncoder,</div><div class="line">		fixup: <span class="function"><span class="keyword">func</span><span class="params">(obj runtime.Object)</span></span> &#123;</div><div class="line">			<span class="keyword">if</span> err := setSelfLink(obj, req, scope.Namer); err != <span class="literal">nil</span> &#123;</div><div class="line">				utilruntime.HandleError(fmt.Errorf(<span class="string">"failed to set link for object %v: %v"</span>, reflect.TypeOf(obj), err))</div><div class="line">			&#125;</div><div class="line">		&#125;,</div><div class="line"></div><div class="line">		t: &amp;realTimeoutFactory&#123;timeout&#125;,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	server.ServeHTTP(res.ResponseWriter, req.Request)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>serveWatch()主要调用了ServeHTTP():<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ServeHTTP serves a series of encoded events via HTTP with Transfer-Encoding: chunked</span></div><div class="line"><span class="comment">// or over a websocket connection.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *WatchServer)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</div><div class="line">	w = httplog.Unlogged(w)</div><div class="line"></div><div class="line">	<span class="comment">//***WebSocketRequest请求走此通道***//</span></div><div class="line">	<span class="keyword">if</span> wsstream.IsWebSocketRequest(req) &#123;</div><div class="line">		w.Header().Set(<span class="string">"Content-Type"</span>, s.mediaType)</div><div class="line">		websocket.Handler(s.HandleWS).ServeHTTP(w, req)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	cn, ok := w.(http.CloseNotifier)</div><div class="line">	<span class="keyword">if</span> !ok &#123;</div><div class="line">		err := fmt.Errorf(<span class="string">"unable to start watch - can't get http.CloseNotifier: %#v"</span>, w)</div><div class="line">		utilruntime.HandleError(err)</div><div class="line">		s.scope.err(errors.NewInternalError(err), w, req)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	flusher, ok := w.(http.Flusher)</div><div class="line">	<span class="keyword">if</span> !ok &#123;</div><div class="line">		err := fmt.Errorf(<span class="string">"unable to start watch - can't get http.Flusher: %#v"</span>, w)</div><div class="line">		utilruntime.HandleError(err)</div><div class="line">		s.scope.err(errors.NewInternalError(err), w, req)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	framer := s.framer.NewFrameWriter(w)</div><div class="line">	<span class="keyword">if</span> framer == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="comment">// programmer error</span></div><div class="line">		err := fmt.Errorf(<span class="string">"no stream framing support is available for media type %q"</span>, s.mediaType)</div><div class="line">		utilruntime.HandleError(err)</div><div class="line">		s.scope.err(errors.NewBadRequest(err.Error()), w, req)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	e := streaming.NewEncoder(framer, s.encoder)</div><div class="line"></div><div class="line">	<span class="comment">// ensure the connection times out</span></div><div class="line">	timeoutCh, cleanup := s.t.TimeoutCh()</div><div class="line">	<span class="keyword">defer</span> cleanup()</div><div class="line">	<span class="keyword">defer</span> s.watching.Stop()</div><div class="line"></div><div class="line">	<span class="comment">// begin the stream</span></div><div class="line">	w.Header().Set(<span class="string">"Content-Type"</span>, s.mediaType)</div><div class="line">	w.Header().Set(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>)</div><div class="line">	w.WriteHeader(http.StatusOK)</div><div class="line">	flusher.Flush()</div><div class="line"></div><div class="line">	<span class="keyword">var</span> unknown runtime.Unknown</div><div class="line">	internalEvent := &amp;versioned.InternalEvent&#123;&#125;</div><div class="line">	buf := &amp;bytes.Buffer&#123;&#125;</div><div class="line">	<span class="comment">//***获取watcher的outgoing channel***//</span></div><div class="line">	ch := s.watching.ResultChan()</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> &lt;-cn.CloseNotify():</div><div class="line">			<span class="keyword">return</span></div><div class="line">		<span class="keyword">case</span> &lt;-timeoutCh:</div><div class="line">			<span class="keyword">return</span></div><div class="line">		<span class="keyword">case</span> event, ok := &lt;-ch:</div><div class="line">			<span class="comment">//***出错返回***//</span></div><div class="line">			<span class="keyword">if</span> !ok &#123;</div><div class="line">				<span class="comment">// End of results.</span></div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line"></div><div class="line">			obj := event.Object</div><div class="line">			s.fixup(obj)</div><div class="line">			<span class="keyword">if</span> err := s.embeddedEncoder.Encode(obj, buf); err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="comment">// unexpected error</span></div><div class="line">				utilruntime.HandleError(fmt.Errorf(<span class="string">"unable to encode watch object: %v"</span>, err))</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">// ContentType is not required here because we are defaulting to the serializer</span></div><div class="line">			<span class="comment">// type</span></div><div class="line">			unknown.Raw = buf.Bytes()</div><div class="line">			event.Object = &amp;unknown</div><div class="line"></div><div class="line">			<span class="comment">// the internal event will be versioned by the encoder</span></div><div class="line">			*internalEvent = versioned.InternalEvent(event)</div><div class="line">			<span class="keyword">if</span> err := e.Encode(internalEvent); err != <span class="literal">nil</span> &#123;</div><div class="line">				utilruntime.HandleError(fmt.Errorf(<span class="string">"unable to encode watch object: %v (%#v)"</span>, err, e))</div><div class="line">				<span class="comment">// client disconnect.</span></div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(ch) == <span class="number">0</span> &#123;</div><div class="line">				flusher.Flush()</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			buf.Reset()</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ServeHTTP()就是把从storeage的watch result channel获取数据，然后使用streamEncoder把数据发送到连接的数据流中。</p>
<h2 id="genericStore"><a href="#genericStore" class="headerlink" title="genericStore"></a>genericStore</h2><p>接着来看genericStore的List()和Watch()的实现，实现位于/pkg/registry/generic/registry/store.go中，先来看List()：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// List returns a list of items matching labels and field</span></div><div class="line"><span class="comment">//***list操作***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Store)</span> <span class="title">List</span><span class="params">(ctx api.Context, options *api.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</div><div class="line">	<span class="comment">//***处理label***//</span></div><div class="line">	label := labels.Everything()</div><div class="line">	<span class="keyword">if</span> options != <span class="literal">nil</span> &amp;&amp; options.LabelSelector != <span class="literal">nil</span> &#123;</div><div class="line">		label = options.LabelSelector</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//***处理field***//</span></div><div class="line">	field := fields.Everything()</div><div class="line">	<span class="keyword">if</span> options != <span class="literal">nil</span> &amp;&amp; options.FieldSelector != <span class="literal">nil</span> &#123;</div><div class="line">		field = options.FieldSelector</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//***调用ListPredicate()***//</span></div><div class="line">	out, err := e.ListPredicate(ctx, e.PredicateFunc(label, field), options)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> e.Decorator != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">if</span> err := e.Decorator(out); err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> out, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，List()调用了ListPredicate()：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ListPredicate returns a list of all the items matching m.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Store)</span> <span class="title">ListPredicate</span><span class="params">(ctx api.Context, p storage.SelectionPredicate, options *api.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> options == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="comment">// By default we should serve the request from etcd.</span></div><div class="line">		options = &amp;api.ListOptions&#123;ResourceVersion: <span class="string">""</span>&#125;</div><div class="line">	&#125;</div><div class="line">	list := e.NewListFunc()</div><div class="line">	<span class="comment">//***调用MatchesSingle()***//</span></div><div class="line">	<span class="keyword">if</span> name, ok := p.MatchesSingle(); ok &#123;</div><div class="line">		<span class="keyword">if</span> key, err := e.KeyFunc(ctx, name); err == <span class="literal">nil</span> &#123;</div><div class="line">			err := e.Storage.GetToList(ctx, key, options.ResourceVersion, p, list)</div><div class="line">			<span class="keyword">return</span> list, storeerr.InterpretListError(err, e.QualifiedResource)</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// if we cannot extract a key based on the current context, the optimization is skipped</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//***List***//</span></div><div class="line">	err := e.Storage.List(ctx, e.KeyRootFunc(ctx), options.ResourceVersion, p, list)</div><div class="line">	<span class="keyword">return</span> list, storeerr.InterpretListError(err, e.QualifiedResource)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ListPredicate()调用了底层storage的List()，其中p为SelectionPredicate可以匹配selector和label。<br>再来看Watch():<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Watch makes a matcher for the given label and field, and calls</span></div><div class="line"><span class="comment">// WatchPredicate. If possible, you should customize PredicateFunc to produre a</span></div><div class="line"><span class="comment">// matcher that matches by key. SelectionPredicate does this for you</span></div><div class="line"><span class="comment">// automatically.</span></div><div class="line"><span class="comment">//***Watch()的实现，其中有label的用法，可以学下***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Store)</span> <span class="title">Watch</span><span class="params">(ctx api.Context, options *api.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</div><div class="line">	label := labels.Everything()</div><div class="line">	<span class="keyword">if</span> options != <span class="literal">nil</span> &amp;&amp; options.LabelSelector != <span class="literal">nil</span> &#123;</div><div class="line">		label = options.LabelSelector</div><div class="line">	&#125;</div><div class="line">	field := fields.Everything()</div><div class="line">	<span class="keyword">if</span> options != <span class="literal">nil</span> &amp;&amp; options.FieldSelector != <span class="literal">nil</span> &#123;</div><div class="line">		field = options.FieldSelector</div><div class="line">	&#125;</div><div class="line">	resourceVersion := <span class="string">""</span></div><div class="line">	<span class="keyword">if</span> options != <span class="literal">nil</span> &#123;</div><div class="line">		resourceVersion = options.ResourceVersion</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//***调用WatchPredicate()***//</span></div><div class="line">	<span class="keyword">return</span> e.WatchPredicate(ctx, e.PredicateFunc(label, field), resourceVersion)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Watch()主要调用了WatchPredicate()：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// WatchPredicate starts a watch for the items that m matches.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Store)</span> <span class="title">WatchPredicate</span><span class="params">(ctx api.Context, p storage.SelectionPredicate, resourceVersion <span class="keyword">string</span>)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> name, ok := p.MatchesSingle(); ok &#123;</div><div class="line">		<span class="keyword">if</span> key, err := e.KeyFunc(ctx, name); err == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">			&#125;</div><div class="line">			<span class="comment">//***Watch单个元素***//</span></div><div class="line">			w, err := e.Storage.Watch(ctx, key, resourceVersion, p)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> e.Decorator != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> newDecoratedWatcher(w, e.Decorator), <span class="literal">nil</span></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> w, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// if we cannot extract a key based on the current context, the optimization is skipped</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//***watch list***//</span></div><div class="line">	w, err := e.Storage.WatchList(ctx, e.KeyRootFunc(ctx), resourceVersion, p)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> e.Decorator != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> newDecoratedWatcher(w, e.Decorator), <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> w, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>WatchPredicate()会判断监听的对象，如果是单个元素，那么调用的是底层storage的Watch()，否则调用WatchList()。</p>
<h2 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h2><p>现在来看底层storage的List(), Watch()和WatchList()，定义在/pkg/storeage/etcd/etcd_helper.go：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Implements storage.Interface.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *etcdHelper)</span> <span class="title">List</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, resourceVersion <span class="keyword">string</span>, pred storage.SelectionPredicate, listObj runtime.Object)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> ctx == <span class="literal">nil</span> &#123;</div><div class="line">		glog.Errorf(<span class="string">"Context is nil"</span>)</div><div class="line">	&#125;</div><div class="line">	trace := util.NewTrace(<span class="string">"List "</span> + getTypeName(listObj))</div><div class="line">	<span class="keyword">defer</span> trace.LogIfLong(<span class="number">400</span> * time.Millisecond)</div><div class="line">	listPtr, err := meta.GetItemsPtr(listObj)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	key = h.prefixEtcdKey(key)</div><div class="line">	startTime := time.Now()</div><div class="line">	trace.Step(<span class="string">"About to list etcd node"</span>)</div><div class="line">	<span class="comment">//***执行list操作***//</span></div><div class="line">	nodes, index, err := h.listEtcdNode(ctx, key)</div><div class="line">	trace.Step(<span class="string">"Etcd node listed"</span>)</div><div class="line">	metrics.RecordEtcdRequestLatency(<span class="string">"list"</span>, getTypeName(listPtr), startTime)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> err := h.decodeNodeList(nodes, storage.SimpleFilter(pred), listPtr); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	trace.Step(<span class="string">"Node list decoded"</span>)</div><div class="line">	<span class="keyword">if</span> err := h.versioner.UpdateList(listObj, index); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Watch()定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *etcdHelper)</span> <span class="title">Watch</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, resourceVersion <span class="keyword">string</span>, pred storage.SelectionPredicate)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> ctx == <span class="literal">nil</span> &#123;</div><div class="line">		glog.Errorf(<span class="string">"Context is nil"</span>)</div><div class="line">	&#125;</div><div class="line">	watchRV, err := storage.ParseWatchResourceVersion(resourceVersion)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	key = h.prefixEtcdKey(key)</div><div class="line">	w := newEtcdWatcher(<span class="literal">false</span>, h.quorum, <span class="literal">nil</span>, storage.SimpleFilter(pred), h.codec, h.versioner, <span class="literal">nil</span>, h)</div><div class="line">	<span class="keyword">go</span> w.etcdWatch(ctx, h.etcdKeysAPI, key, watchRV)</div><div class="line">	<span class="keyword">return</span> w, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>WatchList()定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Implements storage.Interface.</span></div><div class="line"><span class="comment">//***处理WatchList***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *etcdHelper)</span> <span class="title">WatchList</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, resourceVersion <span class="keyword">string</span>, pred storage.SelectionPredicate)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> ctx == <span class="literal">nil</span> &#123;</div><div class="line">		glog.Errorf(<span class="string">"Context is nil"</span>)</div><div class="line">	&#125;</div><div class="line">	watchRV, err := storage.ParseWatchResourceVersion(resourceVersion)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	key = h.prefixEtcdKey(key)</div><div class="line">	<span class="comment">//***调用etcd_watcher.go中的etcdWatch()***//</span></div><div class="line">	w := newEtcdWatcher(<span class="literal">true</span>, h.quorum, exceptKey(key), storage.SimpleFilter(pred), h.codec, h.versioner, <span class="literal">nil</span>, h)</div><div class="line">	<span class="keyword">go</span> w.etcdWatch(ctx, h.etcdKeysAPI, key, watchRV)</div><div class="line">	<span class="keyword">return</span> w, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于etcdwatcher，详见”storage解读(五)-etcdWatcher-v1.5.2”。这里需要注意下，ETCD中存储的obj的metadata是没有resourceVersion这个字段的，但通过kubectl get命令取得的就有，这是因为etcd_helper.go中的Get()，List()等函数调用了APIObjectVersioner的UpdateObject()或UpdateList()函数。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里只是分析了下listwatch的大概流程，很多细节并未展开分析，会在以后其他文章中逐渐补充。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://fankangbest.github.com/2017/12/14/kubernetes-listwatch机制-v1-5-2/" data-id="cjbqd5wvm0061hoqss2vb0bgv" class="article-share-link">分享</a><div class="tags"><a href="/tags/kubernetes/">kubernetes</a><a href="/tags/kubernetes-v1-5-2/">kubernetes-v1.5.2</a></div><div class="post-nav"><a href="/2017/12/15/storage解读(六)-strategy-v1-5-2/" class="pre">storage解读(六)-strategy-v1.5.2</a><a href="/2017/12/09/kubernetes-添加controller-demo-v1-5-2/" class="next">kubernetes-添加controller-demo-v1.5.2</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://fankangbest.github.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/GO语言/">GO语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/存储虚拟化/">存储虚拟化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/容器虚拟化/">容器虚拟化</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/containerd-v0-2-4/" style="font-size: 15px;">containerd-v0.2.4</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/docker-v1-12-3/" style="font-size: 15px;">docker-v1.12.3</a> <a href="/tags/GO语言/" style="font-size: 15px;">GO语言</a> <a href="/tags/containerd/" style="font-size: 15px;">containerd</a> <a href="/tags/kubernetes-v1-5-2/" style="font-size: 15px;">kubernetes-v1.5.2</a> <a href="/tags/gRPC/" style="font-size: 15px;">gRPC</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/runc/" style="font-size: 15px;">runc</a> <a href="/tags/runc-v1-0-0-rc2/" style="font-size: 15px;">runc-v1.0.0-rc2</a> <a href="/tags/ceph/" style="font-size: 15px;">ceph</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/12/28/Docker工具包分析-archive-v1-12-3/">Docker工具包分析-archive-v1.12.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/27/Docker命令行分析-cp-v1-12-3/">Docker命令行分析-cp-v1.12.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/26/tar-stream-demo/">tar-stream-demo</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/25/Docker命令分行分析-run-v1-12-3/">Docker命令分行分析-run-v1.12.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/23/kubelet分析(七)-dockerManager(2)-v1-5-2/">kubelet分析(七)-dockerManager(2)-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/23/kubelet分析(七)-dockerManager(1)-v1-5-2/">kubelet分析(七)-dockerManager(1)-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/20/kubelet分析(六)-proberManager-v1-5-2/">kubelet分析(六)-proberManager-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/18/kubelet分析(五)-podManager-v1-5-2/">kubelet分析(五)-podManager-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/17/kubelet分析(四)-statusManager-v1-5-2/">kubelet分析(四)-statusManager-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/17/kubelet分析(三)-volumeManager-v1-5-2/">kubelet分析(三)-volumeManager-v1.5.2</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/fankangbest" title="myGithub" target="_blank">myGithub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">fankangbest.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>