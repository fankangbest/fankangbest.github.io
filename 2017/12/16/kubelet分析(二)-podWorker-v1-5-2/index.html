<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>kubelet分析(二)-podWorker-v1.5.2 | fankangbest</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">kubelet分析(二)-podWorker-v1.5.2</h1><a id="logo" href="/.">fankangbest</a><p class="description">多听，少说，接受每一个人的责难，但是保留自己的最后裁决。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">kubelet分析(二)-podWorker-v1.5.2</h1><div class="post-meta">Dec 16, 2017<span> | </span><span class="category"><a href="/categories/容器虚拟化/">容器虚拟化</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p>上次分析了所有pod事件都会被处理后放置到updates channel中，即介绍了updates数据的生产者，本次分析将介绍updates数据的消费者。</p>
<h2 id="syncLoopIteration"><a href="#syncLoopIteration" class="headerlink" title="syncLoopIteration"></a>syncLoopIteration</h2><p>在/pkg/kbuelet/kubelet.go中，有：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***此updates就是PodConfig中的updates***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">Run</span><span class="params">(updates &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate)</span></span> &#123;</div><div class="line">	......</div><div class="line">	kl.syncLoop(updates, kl)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>syncLoop()就会消费updates中的数据，定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">syncLoop</span><span class="params">(updates &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler)</span></span> &#123;</div><div class="line">	glog.Info(<span class="string">"Starting kubelet main sync loop."</span>)</div><div class="line">	<span class="comment">// The resyncTicker wakes up kubelet to checks if there are any pod workers</span></div><div class="line">	<span class="comment">// that need to be sync'd. A one-second period is sufficient because the</span></div><div class="line">	<span class="comment">// sync interval is defaulted to 10s.</span></div><div class="line">	syncTicker := time.NewTicker(time.Second)</div><div class="line">	<span class="keyword">defer</span> syncTicker.Stop()</div><div class="line">	housekeepingTicker := time.NewTicker(housekeepingPeriod)</div><div class="line">	<span class="keyword">defer</span> housekeepingTicker.Stop()</div><div class="line">	plegCh := kl.pleg.Watch()</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">if</span> rs := kl.runtimeState.runtimeErrors(); <span class="built_in">len</span>(rs) != <span class="number">0</span> &#123;</div><div class="line">			glog.Infof(<span class="string">"skipping pod synchronization - %v"</span>, rs)</div><div class="line">			time.Sleep(<span class="number">5</span> * time.Second)</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> !kl.syncLoopIteration(updates, handler, syncTicker.C, housekeepingTicker.C, plegCh) &#123;</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>syncLoop()会调用syncLoopIteration()，定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">syncLoopIteration</span><span class="params">(configCh &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler,</span></span></div><div class="line">	syncCh &lt;-<span class="keyword">chan</span> time.Time, housekeepingCh &lt;-<span class="keyword">chan</span> time.Time, plegCh &lt;-<span class="keyword">chan</span> *pleg.PodLifecycleEvent) <span class="title">bool</span> &#123;</div><div class="line">	kl.syncLoopMonitor.Store(kl.clock.Now())</div><div class="line">	<span class="keyword">select</span> &#123;</div><div class="line">	<span class="comment">//***configCh是updates channel***//</span></div><div class="line">	<span class="comment">//***读取配置事件的管道，就是之前讲过的通过文件、URL 和 apiserver 汇聚起来的事件***//</span></div><div class="line">	<span class="keyword">case</span> u, open := &lt;-configCh:</div><div class="line">		<span class="comment">// Update from a config source; dispatch it to the right handler</span></div><div class="line">		<span class="comment">// callback.</span></div><div class="line">		<span class="keyword">if</span> !open &#123;</div><div class="line">			glog.Errorf(<span class="string">"Update channel is closed. Exiting the sync loop."</span>)</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">//***根据Op对update进行不同的处理***//</span></div><div class="line">		<span class="keyword">switch</span> u.Op &#123;</div><div class="line">		<span class="keyword">case</span> kubetypes.ADD:</div><div class="line">			glog.V(<span class="number">2</span>).Infof(<span class="string">"SyncLoop (ADD, %q): %q"</span>, u.Source, format.Pods(u.Pods))</div><div class="line">			<span class="comment">// After restarting, kubelet will get all existing pods through</span></div><div class="line">			<span class="comment">// ADD as if they are new pods. These pods will then go through the</span></div><div class="line">			<span class="comment">// admission process and *may* be rejected. This can be resolved</span></div><div class="line">			<span class="comment">// once we have checkpointing.</span></div><div class="line">			handler.HandlePodAdditions(u.Pods)</div><div class="line">		<span class="keyword">case</span> kubetypes.UPDATE:</div><div class="line">			glog.V(<span class="number">2</span>).Infof(<span class="string">"SyncLoop (UPDATE, %q): %q"</span>, u.Source, format.PodsWithDeletiontimestamps(u.Pods))</div><div class="line">			handler.HandlePodUpdates(u.Pods)</div><div class="line">		<span class="keyword">case</span> kubetypes.REMOVE:</div><div class="line">			glog.V(<span class="number">2</span>).Infof(<span class="string">"SyncLoop (REMOVE, %q): %q"</span>, u.Source, format.Pods(u.Pods))</div><div class="line">			handler.HandlePodRemoves(u.Pods)</div><div class="line">		<span class="keyword">case</span> kubetypes.RECONCILE:</div><div class="line">			glog.V(<span class="number">4</span>).Infof(<span class="string">"SyncLoop (RECONCILE, %q): %q"</span>, u.Source, format.Pods(u.Pods))</div><div class="line">			handler.HandlePodReconcile(u.Pods)</div><div class="line">		<span class="keyword">case</span> kubetypes.DELETE:</div><div class="line">			glog.V(<span class="number">2</span>).Infof(<span class="string">"SyncLoop (DELETE, %q): %q"</span>, u.Source, format.Pods(u.Pods))</div><div class="line">			<span class="comment">// DELETE is treated as a UPDATE because of graceful deletion.</span></div><div class="line">			handler.HandlePodUpdates(u.Pods)</div><div class="line">		<span class="keyword">case</span> kubetypes.SET:</div><div class="line">			<span class="comment">// <span class="doctag">TODO:</span> Do we want to support this?</span></div><div class="line">			glog.Errorf(<span class="string">"Kubelet does not support snapshot update"</span>)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// Mark the source ready after receiving at least one update from the</span></div><div class="line">		<span class="comment">// source. Once all the sources are marked ready, various cleanup</span></div><div class="line">		<span class="comment">// routines will start reclaiming resources. It is important that this</span></div><div class="line">		<span class="comment">// takes place only after kubelet calls the update handler to process</span></div><div class="line">		<span class="comment">// the update to ensure the internal pod cache is up-to-date.</span></div><div class="line">		kl.sourcesReady.AddSource(u.Source)</div><div class="line">		......</div><div class="line">	<span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>syncLoopIteration()会监听很多条channel，我们关注的是configCh这个分支。可以看到，事件类型与处理函数的对应的关系如下：</p>
<ul>
<li>kubetypes.ADD: HandlePodAdditions()</li>
<li>kubetypes.UPDATE: HandlePodUpdates()</li>
<li>kubetypes.REMOVE: HandlePodRemoves()</li>
<li>kubetypes.RECONCILE: HandlePodReconcile()</li>
<li>kubetypes.DELETE: HandlePodUpdates()</li>
<li>kubetypes.SET: 目前还未支持。</li>
</ul>
<p>由于podConfig一次分类处理的是全量的pods，所以在各handler一次也要处理多个pods，这样大大提高了效率。</p>
<h2 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h2><p>HandlePodAdditions()定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// HandlePodAdditions is the callback in SyncHandler for pods being added from</span></div><div class="line"><span class="comment">// a config source.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">HandlePodAdditions</span><span class="params">(pods []*api.Pod)</span></span> &#123;</div><div class="line">	start := kl.clock.Now()</div><div class="line"></div><div class="line">	<span class="comment">// Pass critical pods through admission check first.</span></div><div class="line">	<span class="keyword">var</span> criticalPods []*api.Pod</div><div class="line">	<span class="keyword">var</span> nonCriticalPods []*api.Pod</div><div class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> pods &#123;</div><div class="line">		<span class="keyword">if</span> kubetypes.IsCriticalPod(p) &#123;</div><div class="line">			criticalPods = <span class="built_in">append</span>(criticalPods, p)</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			nonCriticalPods = <span class="built_in">append</span>(nonCriticalPods, p)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	sort.Sort(sliceutils.PodsByCreationTime(criticalPods))</div><div class="line">	sort.Sort(sliceutils.PodsByCreationTime(nonCriticalPods))</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> <span class="built_in">append</span>(criticalPods, nonCriticalPods...) &#123;</div><div class="line">		existingPods := kl.podManager.GetPods()</div><div class="line">		<span class="comment">// Always add the pod to the pod manager. Kubelet relies on the pod</span></div><div class="line">		<span class="comment">// manager as the source of truth for the desired state. If a pod does</span></div><div class="line">		<span class="comment">// not exist in the pod manager, it means that it has been deleted in</span></div><div class="line">		<span class="comment">// the apiserver and no action (other than cleanup) is required.</span></div><div class="line">		kl.podManager.AddPod(pod)</div><div class="line"></div><div class="line">		<span class="keyword">if</span> kubepod.IsMirrorPod(pod) &#123;</div><div class="line">			kl.handleMirrorPod(pod, start)</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> !kl.podIsTerminated(pod) &#123;</div><div class="line">			<span class="comment">// Only go through the admission process if the pod is not</span></div><div class="line">			<span class="comment">// terminated.</span></div><div class="line"></div><div class="line">			<span class="comment">// We failed pods that we rejected, so activePods include all admitted</span></div><div class="line">			<span class="comment">// pods that are alive.</span></div><div class="line">			activePods := kl.filterOutTerminatedPods(existingPods)</div><div class="line"></div><div class="line">			<span class="comment">// Check if we can admit the pod; if not, reject it.</span></div><div class="line">			<span class="keyword">if</span> ok, reason, message := kl.canAdmitPod(activePods, pod); !ok &#123;</div><div class="line">				kl.rejectPod(pod, reason, message)</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		mirrorPod, _ := kl.podManager.GetMirrorPodByPod(pod)</div><div class="line">		kl.dispatchWork(pod, kubetypes.SyncPodCreate, mirrorPod, start)</div><div class="line">		kl.probeManager.AddPod(pod)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>HandlePodAdditions()会把pods分为criticalPods(还不清楚具体为具体功能)和nonCriticalPods，然后调用dispatchWork()处理各pod，设定处理方法为kubetypes.SyncPodCreate。</p>
<p>HandlePodUpdates()定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// HandlePodUpdates is the callback in the SyncHandler interface for pods</span></div><div class="line"><span class="comment">// being updated from a config source.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">HandlePodUpdates</span><span class="params">(pods []*api.Pod)</span></span> &#123;</div><div class="line">	start := kl.clock.Now()</div><div class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</div><div class="line">		kl.podManager.UpdatePod(pod)</div><div class="line">		<span class="keyword">if</span> kubepod.IsMirrorPod(pod) &#123;</div><div class="line">			kl.handleMirrorPod(pod, start)</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// <span class="doctag">TODO:</span> Evaluate if we need to validate and reject updates.</span></div><div class="line"></div><div class="line">		mirrorPod, _ := kl.podManager.GetMirrorPodByPod(pod)</div><div class="line">		kl.dispatchWork(pod, kubetypes.SyncPodUpdate, mirrorPod, start)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>HandlePodUpdates()会调用dispatchWork()处理各pods，设定处理方法为kubetypes.SyncPodUpdate。</p>
<p>HandlePodRemoves()定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// HandlePodRemoves is the callback in the SyncHandler interface for pods</span></div><div class="line"><span class="comment">// being removed from a config source.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">HandlePodRemoves</span><span class="params">(pods []*api.Pod)</span></span> &#123;</div><div class="line">	start := kl.clock.Now()</div><div class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</div><div class="line">		kl.podManager.DeletePod(pod)</div><div class="line">		<span class="keyword">if</span> kubepod.IsMirrorPod(pod) &#123;</div><div class="line">			kl.handleMirrorPod(pod, start)</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// Deletion is allowed to fail because the periodic cleanup routine</span></div><div class="line">		<span class="comment">// will trigger deletion again.</span></div><div class="line">		<span class="keyword">if</span> err := kl.deletePod(pod); err != <span class="literal">nil</span> &#123;</div><div class="line">			glog.V(<span class="number">2</span>).Infof(<span class="string">"Failed to delete pod %q, err: %v"</span>, format.Pod(pod), err)</div><div class="line">		&#125;</div><div class="line">		kl.probeManager.RemovePod(pod)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>HandlePodRemoves()直接调用deletePod()删除pod。</p>
<p>HandlePodReconcile()定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// HandlePodReconcile is the callback in the SyncHandler interface for pods</span></div><div class="line"><span class="comment">// that should be reconciled.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">HandlePodReconcile</span><span class="params">(pods []*api.Pod)</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</div><div class="line">		<span class="comment">// Update the pod in pod manager, status manager will do periodically reconcile according</span></div><div class="line">		<span class="comment">// to the pod manager.</span></div><div class="line">		kl.podManager.UpdatePod(pod)</div><div class="line"></div><div class="line">		<span class="comment">// After an evicted pod is synced, all dead containers in the pod can be removed.</span></div><div class="line">		<span class="keyword">if</span> eviction.PodIsEvicted(pod.Status) &#123;</div><div class="line">			<span class="keyword">if</span> podStatus, err := kl.podCache.Get(pod.UID); err == <span class="literal">nil</span> &#123;</div><div class="line">				kl.containerDeletor.deleteContainersInPod(<span class="string">""</span>, podStatus, <span class="literal">true</span>)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>HandlePodReconcile()会把pod状态更新到podManager中，然后statusManager会根据podManager的状态来作出处理。</p>
<p>再来看下dispatchWork():<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// dispatchWork starts the asynchronous sync of the pod in a pod worker.</span></div><div class="line"><span class="comment">// If the pod is terminated, dispatchWork</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">dispatchWork</span><span class="params">(pod *api.Pod, syncType kubetypes.SyncPodType, mirrorPod *api.Pod, start time.Time)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> kl.podIsTerminated(pod) &#123;</div><div class="line">		<span class="keyword">if</span> pod.DeletionTimestamp != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="comment">// If the pod is in a terminated state, there is no pod worker to</span></div><div class="line">			<span class="comment">// handle the work item. Check if the DeletionTimestamp has been</span></div><div class="line">			<span class="comment">// set, and force a status update to trigger a pod deletion request</span></div><div class="line">			<span class="comment">// to the apiserver.</span></div><div class="line">			kl.statusManager.TerminatePod(pod)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	<span class="comment">// Run the sync in an async worker.</span></div><div class="line">	kl.podWorkers.UpdatePod(&amp;UpdatePodOptions&#123;</div><div class="line">		Pod:        pod,</div><div class="line">		MirrorPod:  mirrorPod,</div><div class="line">		UpdateType: syncType,</div><div class="line">		OnCompleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123;</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				metrics.PodWorkerLatency.WithLabelValues(syncType.String()).Observe(metrics.SinceInMicroseconds(start))</div><div class="line">			&#125;</div><div class="line">		&#125;,</div><div class="line">	&#125;)</div><div class="line">	<span class="comment">// Note the number of containers for new pods.</span></div><div class="line">	<span class="keyword">if</span> syncType == kubetypes.SyncPodCreate &#123;</div><div class="line">		metrics.ContainersPerPodCount.Observe(<span class="keyword">float64</span>(<span class="built_in">len</span>(pod.Spec.Containers)))</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可见，dispatchWork()调用了podWorkers的UpdatePod()方法处理pod。</p>
<h2 id="podWorkers"><a href="#podWorkers" class="headerlink" title="podWorkers"></a>podWorkers</h2><p>podWorkers会为每一个pod都维护有一个workUpdate channel，对每一个workUpdate channel，都有一个managePodLoop()对该channel中的内容进行处理。podWorkers定义在/pkg/kubelet/pod_workers.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> podWorkers <span class="keyword">struct</span> &#123;</div><div class="line">	<span class="comment">// Protects all per worker fields.</span></div><div class="line">	podLock sync.Mutex</div><div class="line"></div><div class="line">	<span class="comment">// Tracks all running per-pod goroutines - per-pod goroutine will be</span></div><div class="line">	<span class="comment">// processing updates received through its corresponding channel.</span></div><div class="line">	podUpdates <span class="keyword">map</span>[types.UID]<span class="keyword">chan</span> UpdatePodOptions</div><div class="line">	<span class="comment">// Track the current state of per-pod goroutines.</span></div><div class="line">	<span class="comment">// Currently all update request for a given pod coming when another</span></div><div class="line">	<span class="comment">// update of this pod is being processed are ignored.</span></div><div class="line">	isWorking <span class="keyword">map</span>[types.UID]<span class="keyword">bool</span></div><div class="line">	<span class="comment">// Tracks the last undelivered work item for this pod - a work item is</span></div><div class="line">	<span class="comment">// undelivered if it comes in while the worker is working.</span></div><div class="line">	lastUndeliveredWorkUpdate <span class="keyword">map</span>[types.UID]UpdatePodOptions</div><div class="line"></div><div class="line">	workQueue queue.WorkQueue</div><div class="line"></div><div class="line">	<span class="comment">// This function is run to sync the desired stated of pod.</span></div><div class="line">	<span class="comment">// <span class="doctag">NOTE:</span> This function has to be thread-safe - it can be called for</span></div><div class="line">	<span class="comment">// different pods at the same time.</span></div><div class="line">	<span class="comment">//***在kubelet.go中，klet.podWorkers = newPodWorkers(runtimeCache, klet.syncPod, recorder)***//</span></div><div class="line">	<span class="comment">//***所以，一般来说，syncPodFn即为kubelet.go中的syncPod()，进而又调用dockertools的manager.go中的syncPod()***//</span></div><div class="line">	syncPodFn syncPodFnType</div><div class="line"></div><div class="line">	<span class="comment">// The EventRecorder to use</span></div><div class="line">	recorder record.EventRecorder</div><div class="line"></div><div class="line">	<span class="comment">// backOffPeriod is the duration to back off when there is a sync error.</span></div><div class="line">	backOffPeriod time.Duration</div><div class="line"></div><div class="line">	<span class="comment">// resyncInterval is the duration to wait until the next sync.</span></div><div class="line">	resyncInterval time.Duration</div><div class="line"></div><div class="line">	<span class="comment">// podCache stores kubecontainer.PodStatus for all pods.</span></div><div class="line">	podCache kubecontainer.Cache</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>podWorkers的主要字段如下：</p>
<ol>
<li>podUpdates：UpdatePodOptions(即后面函数的podUpdates) channel的存储地，key为pod的UID；</li>
<li>syncPodFn: pod的处理函数。</li>
</ol>
<p>可以使用newPodWorkers()生成podWorkers:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPodWorkers</span><span class="params">(syncPodFn syncPodFnType, recorder record.EventRecorder, workQueue queue.WorkQueue,</span></span></div><div class="line">	resyncInterval, backOffPeriod time.Duration, podCache kubecontainer.Cache) *<span class="title">podWorkers</span> &#123;</div><div class="line">	<span class="keyword">return</span> &amp;podWorkers&#123;</div><div class="line">		podUpdates:                <span class="keyword">map</span>[types.UID]<span class="keyword">chan</span> UpdatePodOptions&#123;&#125;,</div><div class="line">		isWorking:                 <span class="keyword">map</span>[types.UID]<span class="keyword">bool</span>&#123;&#125;,</div><div class="line">		lastUndeliveredWorkUpdate: <span class="keyword">map</span>[types.UID]UpdatePodOptions&#123;&#125;,</div><div class="line">		syncPodFn:                 syncPodFn,</div><div class="line">		recorder:                  recorder,</div><div class="line">		workQueue:                 workQueue,</div><div class="line">		resyncInterval:            resyncInterval,</div><div class="line">		backOffPeriod:             backOffPeriod,</div><div class="line">		podCache:                  podCache,</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再来看UpdatePod()：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *podWorkers)</span> <span class="title">UpdatePod</span><span class="params">(options *UpdatePodOptions)</span></span> &#123;</div><div class="line">	pod := options.Pod</div><div class="line">	uid := pod.UID</div><div class="line">	<span class="keyword">var</span> podUpdates <span class="keyword">chan</span> UpdatePodOptions</div><div class="line">	<span class="keyword">var</span> exists <span class="keyword">bool</span></div><div class="line"></div><div class="line">	p.podLock.Lock()</div><div class="line">	<span class="keyword">defer</span> p.podLock.Unlock()</div><div class="line">	<span class="comment">//***如果该pod在p.podUpdates[]中没有，则为该pod新建podUpdates channel***//</span></div><div class="line">	<span class="keyword">if</span> podUpdates, exists = p.podUpdates[uid]; !exists &#123;</div><div class="line">		<span class="comment">// We need to have a buffer here, because checkForUpdates() method that</span></div><div class="line">		<span class="comment">// puts an update into channel is called from the same goroutine where</span></div><div class="line">		<span class="comment">// the channel is consumed. However, it is guaranteed that in such case</span></div><div class="line">		<span class="comment">// the channel is empty, so buffer of size 1 is enough.</span></div><div class="line">		<span class="comment">//***channel的大小为1***//</span></div><div class="line">		podUpdates = <span class="built_in">make</span>(<span class="keyword">chan</span> UpdatePodOptions, <span class="number">1</span>)</div><div class="line">		p.podUpdates[uid] = podUpdates</div><div class="line"></div><div class="line">		<span class="comment">// Creating a new pod worker either means this is a new pod, or that the</span></div><div class="line">		<span class="comment">// kubelet just restarted. In either case the kubelet is willing to believe</span></div><div class="line">		<span class="comment">// the status of the pod for the first pod worker sync. See corresponding</span></div><div class="line">		<span class="comment">// comment in syncPod.</span></div><div class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">			<span class="keyword">defer</span> runtime.HandleCrash()</div><div class="line">			<span class="comment">//***开始处理podUpdates***//</span></div><div class="line">			p.managePodLoop(podUpdates)</div><div class="line">		&#125;()</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> !p.isWorking[pod.UID] &#123;</div><div class="line">		p.isWorking[pod.UID] = <span class="literal">true</span></div><div class="line">		<span class="comment">//***把options放入到podUpdates中***//</span></div><div class="line">		podUpdates &lt;- *options</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">// if a request to kill a pod is pending, we do not let anything overwrite that request.</span></div><div class="line">		update, found := p.lastUndeliveredWorkUpdate[pod.UID]</div><div class="line">		<span class="keyword">if</span> !found || update.UpdateType != kubetypes.SyncPodKill &#123;</div><div class="line">			p.lastUndeliveredWorkUpdate[pod.UID] = *options</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>UpdatePod()的流程如下：</p>
<ol>
<li>如果pod的uid在podUpdates中不存在，则新建podUpdates，然后启动managePodLoop()处理该podUpdates；</li>
<li>把options加入到podUpdates中。</li>
</ol>
<p>来看下managePodLoop()是如何处理podUpdates中的数据的：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***消费podUpdates chan中的workUpdate，并做处理***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *podWorkers)</span> <span class="title">managePodLoop</span><span class="params">(podUpdates &lt;-<span class="keyword">chan</span> UpdatePodOptions)</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> lastSyncTime time.Time</div><div class="line">	<span class="keyword">for</span> update := <span class="keyword">range</span> podUpdates &#123;</div><div class="line">		err := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">			podUID := update.Pod.UID</div><div class="line">			<span class="comment">// This is a blocking call that would return only if the cache</span></div><div class="line">			<span class="comment">// has an entry for the pod that is newer than minRuntimeCache</span></div><div class="line">			<span class="comment">// Time. This ensures the worker doesn't start syncing until</span></div><div class="line">			<span class="comment">// after the cache is at least newer than the finished time of</span></div><div class="line">			<span class="comment">// the previous sync.</span></div><div class="line">			status, err := p.podCache.GetNewerThan(podUID, lastSyncTime)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> err</div><div class="line">			&#125;</div><div class="line">			<span class="comment">//***此处调用syncPodFn()，即kubelet.go中的syncPod()***//</span></div><div class="line">			err = p.syncPodFn(syncPodOptions&#123;</div><div class="line">				mirrorPod:      update.MirrorPod,</div><div class="line">				pod:            update.Pod,</div><div class="line">				podStatus:      status,</div><div class="line">				killPodOptions: update.KillPodOptions,</div><div class="line">				updateType:     update.UpdateType,</div><div class="line">			&#125;)</div><div class="line">			lastSyncTime = time.Now()</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> err</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">		&#125;()</div><div class="line">		<span class="comment">// notify the call-back function if the operation succeeded or not</span></div><div class="line">		<span class="keyword">if</span> update.OnCompleteFunc != <span class="literal">nil</span> &#123;</div><div class="line">			update.OnCompleteFunc(err)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			glog.Errorf(<span class="string">"Error syncing pod %s, skipping: %v"</span>, update.Pod.UID, err)</div><div class="line">			p.recorder.Eventf(update.Pod, api.EventTypeWarning, events.FailedSync, <span class="string">"Error syncing pod, skipping: %v"</span>, err)</div><div class="line">		&#125;</div><div class="line">		p.wrapUp(update.Pod.UID, err)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>managePodLoop()会取出podUpdates中的内容，然后调用syncPodFn()处理内容。</p>
<h2 id="syncPodFn"><a href="#syncPodFn" class="headerlink" title="syncPodFn()"></a>syncPodFn()</h2><p>syncPodFn()这里就是/pkg/kubelet/kubelet.go中的syncPod()：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">syncPod</span><span class="params">(o syncPodOptions)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="comment">// pull out the required options</span></div><div class="line">	pod := o.pod</div><div class="line">	mirrorPod := o.mirrorPod</div><div class="line">	podStatus := o.podStatus</div><div class="line">	updateType := o.updateType</div><div class="line"></div><div class="line">	<span class="comment">// if we want to kill a pod, do it now!</span></div><div class="line">	<span class="keyword">if</span> updateType == kubetypes.SyncPodKill &#123;</div><div class="line">		killPodOptions := o.killPodOptions</div><div class="line">		<span class="keyword">if</span> killPodOptions == <span class="literal">nil</span> || killPodOptions.PodStatusFunc == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"kill pod options are required if update type is kill"</span>)</div><div class="line">		&#125;</div><div class="line">		apiPodStatus := killPodOptions.PodStatusFunc(pod, podStatus)</div><div class="line">		kl.statusManager.SetPodStatus(pod, apiPodStatus)</div><div class="line">		<span class="comment">// we kill the pod with the specified grace period since this is a termination</span></div><div class="line">		<span class="keyword">if</span> err := kl.killPod(pod, <span class="literal">nil</span>, podStatus, killPodOptions.PodTerminationGracePeriodSecondsOverride); err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="comment">// there was an error killing the pod, so we return that error directly</span></div><div class="line">			utilruntime.HandleError(err)</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Latency measurements for the main workflow are relative to the</span></div><div class="line">	<span class="comment">// first time the pod was seen by the API server.</span></div><div class="line">	<span class="keyword">var</span> firstSeenTime time.Time</div><div class="line">	<span class="keyword">if</span> firstSeenTimeStr, ok := pod.Annotations[kubetypes.ConfigFirstSeenAnnotationKey]; ok &#123;</div><div class="line">		firstSeenTime = kubetypes.ConvertToTimestamp(firstSeenTimeStr).Get()</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Record pod worker start latency if being created</span></div><div class="line">	<span class="comment">// <span class="doctag">TODO:</span> make pod workers record their own latencies</span></div><div class="line">	<span class="keyword">if</span> updateType == kubetypes.SyncPodCreate &#123;</div><div class="line">		<span class="keyword">if</span> !firstSeenTime.IsZero() &#123;</div><div class="line">			<span class="comment">// This is the first time we are syncing the pod. Record the latency</span></div><div class="line">			<span class="comment">// since kubelet first saw the pod if firstSeenTime is set.</span></div><div class="line">			metrics.PodWorkerStartLatency.Observe(metrics.SinceInMicroseconds(firstSeenTime))</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			glog.V(<span class="number">3</span>).Infof(<span class="string">"First seen time not recorded for pod %q"</span>, pod.UID)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Generate final API pod status with pod and status manager status</span></div><div class="line">	apiPodStatus := kl.generateAPIPodStatus(pod, podStatus)</div><div class="line">	<span class="comment">// The pod IP may be changed in generateAPIPodStatus if the pod is using host network. (See #24576)</span></div><div class="line">	<span class="comment">// TODO(random-liu): After writing pod spec into container labels, check whether pod is using host network, and</span></div><div class="line">	<span class="comment">// set pod IP to hostIP directly in runtime.GetPodStatus</span></div><div class="line">	podStatus.IP = apiPodStatus.PodIP</div><div class="line"></div><div class="line">	<span class="comment">// Record the time it takes for the pod to become running.</span></div><div class="line">	existingStatus, ok := kl.statusManager.GetPodStatus(pod.UID)</div><div class="line">	<span class="keyword">if</span> !ok || existingStatus.Phase == api.PodPending &amp;&amp; apiPodStatus.Phase == api.PodRunning &amp;&amp;</div><div class="line">		!firstSeenTime.IsZero() &#123;</div><div class="line">		metrics.PodStartLatency.Observe(metrics.SinceInMicroseconds(firstSeenTime))</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	runnable := kl.canRunPod(pod)</div><div class="line">	<span class="keyword">if</span> !runnable.Admit &#123;</div><div class="line">		<span class="comment">// Pod is not runnable; update the Pod and Container statuses to why.</span></div><div class="line">		apiPodStatus.Reason = runnable.Reason</div><div class="line">		apiPodStatus.Message = runnable.Message</div><div class="line">		<span class="comment">// Waiting containers are not creating.</span></div><div class="line">		<span class="keyword">const</span> waitingReason = <span class="string">"Blocked"</span></div><div class="line">		<span class="keyword">for</span> _, cs := <span class="keyword">range</span> apiPodStatus.InitContainerStatuses &#123;</div><div class="line">			<span class="keyword">if</span> cs.State.Waiting != <span class="literal">nil</span> &#123;</div><div class="line">				cs.State.Waiting.Reason = waitingReason</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> _, cs := <span class="keyword">range</span> apiPodStatus.ContainerStatuses &#123;</div><div class="line">			<span class="keyword">if</span> cs.State.Waiting != <span class="literal">nil</span> &#123;</div><div class="line">				cs.State.Waiting.Reason = waitingReason</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Update status in the status manager</span></div><div class="line">	kl.statusManager.SetPodStatus(pod, apiPodStatus)</div><div class="line"></div><div class="line">	<span class="comment">// Kill pod if it should not be running</span></div><div class="line">	<span class="keyword">if</span> !runnable.Admit || pod.DeletionTimestamp != <span class="literal">nil</span> || apiPodStatus.Phase == api.PodFailed &#123;</div><div class="line">		<span class="keyword">var</span> syncErr error</div><div class="line">		<span class="keyword">if</span> err := kl.killPod(pod, <span class="literal">nil</span>, podStatus, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</div><div class="line">			syncErr = fmt.Errorf(<span class="string">"error killing pod: %v"</span>, err)</div><div class="line">			utilruntime.HandleError(syncErr)</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">if</span> !runnable.Admit &#123;</div><div class="line">				<span class="comment">// There was no error killing the pod, but the pod cannot be run.</span></div><div class="line">				<span class="comment">// Return an error to signal that the sync loop should back off.</span></div><div class="line">				syncErr = fmt.Errorf(<span class="string">"pod cannot be run: %s"</span>, runnable.Message)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> syncErr</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// If the network plugin is not ready, only start the pod if it uses the host network</span></div><div class="line">	<span class="keyword">if</span> rs := kl.runtimeState.networkErrors(); <span class="built_in">len</span>(rs) != <span class="number">0</span> &amp;&amp; !podUsesHostNetwork(pod) &#123;</div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"network is not ready: %v"</span>, rs)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Create Cgroups for the pod and apply resource parameters</span></div><div class="line">	<span class="comment">// to them if cgroup-per-qos flag is enabled.</span></div><div class="line">	pcm := kl.containerManager.NewPodContainerManager()</div><div class="line">	<span class="comment">// If pod has already been terminated then we need not create</span></div><div class="line">	<span class="comment">// or update the pod's cgroup</span></div><div class="line">	<span class="keyword">if</span> !kl.podIsTerminated(pod) &#123;</div><div class="line">		<span class="comment">// When the kubelet is restarted with the cgroup-per-qos</span></div><div class="line">		<span class="comment">// flag enabled, all the pod's running containers</span></div><div class="line">		<span class="comment">// should be killed intermittently and brought back up</span></div><div class="line">		<span class="comment">// under the qos cgroup hierarchy.</span></div><div class="line">		<span class="comment">// Check if this is the pod's first sync</span></div><div class="line">		firstSync := <span class="literal">true</span></div><div class="line">		<span class="keyword">for</span> _, containerStatus := <span class="keyword">range</span> apiPodStatus.ContainerStatuses &#123;</div><div class="line">			<span class="keyword">if</span> containerStatus.State.Running != <span class="literal">nil</span> &#123;</div><div class="line">				firstSync = <span class="literal">false</span></div><div class="line">				<span class="keyword">break</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// Don't kill containers in pod if pod's cgroups already</span></div><div class="line">		<span class="comment">// exists or the pod is running for the first time</span></div><div class="line">		podKilled := <span class="literal">false</span></div><div class="line">		<span class="keyword">if</span> !pcm.Exists(pod) &amp;&amp; !firstSync &#123;</div><div class="line">			kl.killPod(pod, <span class="literal">nil</span>, podStatus, <span class="literal">nil</span>)</div><div class="line">			podKilled = <span class="literal">true</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// Create and Update pod's Cgroups</span></div><div class="line">		<span class="comment">// Don't create cgroups for run once pod if it was killed above</span></div><div class="line">		<span class="comment">// The current policy is not to restart the run once pods when</span></div><div class="line">		<span class="comment">// the kubelet is restarted with the new flag as run once pods are</span></div><div class="line">		<span class="comment">// expected to run only once and if the kubelet is restarted then</span></div><div class="line">		<span class="comment">// they are not expected to run again.</span></div><div class="line">		<span class="comment">// We don't create and apply updates to cgroup if its a run once pod and was killed above</span></div><div class="line">		<span class="keyword">if</span> !(podKilled &amp;&amp; pod.Spec.RestartPolicy == api.RestartPolicyNever) &#123;</div><div class="line">			<span class="keyword">if</span> err := pcm.EnsureExists(pod); err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to ensure that the pod: %v cgroups exist and are correctly applied: %v"</span>, pod.UID, err)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Create Mirror Pod for Static Pod if it doesn't already exist</span></div><div class="line">	<span class="keyword">if</span> kubepod.IsStaticPod(pod) &#123;</div><div class="line">		podFullName := kubecontainer.GetPodFullName(pod)</div><div class="line">		deleted := <span class="literal">false</span></div><div class="line">		<span class="keyword">if</span> mirrorPod != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">if</span> mirrorPod.DeletionTimestamp != <span class="literal">nil</span> || !kl.podManager.IsMirrorPodOf(mirrorPod, pod) &#123;</div><div class="line">				<span class="comment">// The mirror pod is semantically different from the static pod. Remove</span></div><div class="line">				<span class="comment">// it. The mirror pod will get recreated later.</span></div><div class="line">				glog.Warningf(<span class="string">"Deleting mirror pod %q because it is outdated"</span>, format.Pod(mirrorPod))</div><div class="line">				<span class="keyword">if</span> err := kl.podManager.DeleteMirrorPod(podFullName); err != <span class="literal">nil</span> &#123;</div><div class="line">					glog.Errorf(<span class="string">"Failed deleting mirror pod %q: %v"</span>, format.Pod(mirrorPod), err)</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					deleted = <span class="literal">true</span></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//***创建mirror pod***//</span></div><div class="line">		<span class="keyword">if</span> mirrorPod == <span class="literal">nil</span> || deleted &#123;</div><div class="line">			glog.V(<span class="number">3</span>).Infof(<span class="string">"Creating a mirror pod for static pod %q"</span>, format.Pod(pod))</div><div class="line">			<span class="keyword">if</span> err := kl.podManager.CreateMirrorPod(pod); err != <span class="literal">nil</span> &#123;</div><div class="line">				glog.Errorf(<span class="string">"Failed creating a mirror pod for %q: %v"</span>, format.Pod(pod), err)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Make data directories for the pod</span></div><div class="line">	<span class="keyword">if</span> err := kl.makePodDataDirs(pod); err != <span class="literal">nil</span> &#123;</div><div class="line">		glog.Errorf(<span class="string">"Unable to make pod data directories for pod %q: %v"</span>, format.Pod(pod), err)</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Wait for volumes to attach/mount</span></div><div class="line">	<span class="comment">//***等待挂载完成***//</span></div><div class="line">	<span class="keyword">if</span> err := kl.volumeManager.WaitForAttachAndMount(pod); err != <span class="literal">nil</span> &#123;</div><div class="line">		kl.recorder.Eventf(pod, api.EventTypeWarning, events.FailedMountVolume, <span class="string">"Unable to mount volumes for pod %q: %v"</span>, format.Pod(pod), err)</div><div class="line">		glog.Errorf(<span class="string">"Unable to mount volumes for pod %q: %v; skipping pod"</span>, format.Pod(pod), err)</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Fetch the pull secrets for the pod</span></div><div class="line">	pullSecrets, err := kl.getPullSecretsForPod(pod)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		glog.Errorf(<span class="string">"Unable to get pull secrets for pod %q: %v"</span>, format.Pod(pod), err)</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Call the container runtime's SyncPod callback</span></div><div class="line">	<span class="comment">//***此处containerRuntime为*dockertools.DockerManager***//</span></div><div class="line">	<span class="comment">//***即调用了dockertools/docker_manager.go中的SyncPod()***//</span></div><div class="line">	result := kl.containerRuntime.SyncPod(pod, apiPodStatus, podStatus, pullSecrets, kl.backOff)</div><div class="line">	kl.reasonCache.Update(pod.UID, result)</div><div class="line">	<span class="keyword">if</span> err = result.Error(); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// early successful exit if pod is not bandwidth-constrained</span></div><div class="line">	<span class="keyword">if</span> !kl.shapingEnabled() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Update the traffic shaping for the pod's ingress and egress limits</span></div><div class="line">	ingress, egress, err := bandwidth.ExtractPodBandwidthResources(pod.Annotations)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> egress != <span class="literal">nil</span> || ingress != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">if</span> podUsesHostNetwork(pod) &#123;</div><div class="line">			kl.recorder.Event(pod, api.EventTypeWarning, events.HostNetworkNotSupported, <span class="string">"Bandwidth shaping is not currently supported on the host network"</span>)</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> kl.shaper != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(apiPodStatus.PodIP) &gt; <span class="number">0</span> &#123;</div><div class="line">				err = kl.shaper.ReconcileCIDR(fmt.Sprintf(<span class="string">"%s/32"</span>, apiPodStatus.PodIP), egress, ingress)</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			kl.recorder.Event(pod, api.EventTypeWarning, events.UndefinedShaper, <span class="string">"Pod requests bandwidth shaping, but the shaper is undefined"</span>)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>syncPod就整个kubelet的核心，pod的创建与删除都由它来处理。由于syncPod()涉及到太多的kubelet中功能包，所以等volumeManager, podManager等介绍完毕再详细分析。现在只需知道syncPod()会处理传进来的pod，维护物理机上的pod和etcd中的pod的一致性。</p>
<h2 id="podWorker的管理"><a href="#podWorker的管理" class="headerlink" title="podWorker的管理"></a>podWorker的管理</h2><p>最后让我们来看下kubelet是如何管理podWoker的。<br>在/pkg/kubelet/kubelet.go的NewMainKubelet()函数中，有：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***pod worker的syncPodFn为syncPod()***//</span></div><div class="line">klet.podWorkers = newPodWorkers(klet.syncPod, kubeDeps.Recorder, klet.workQueue, klet.resyncInterval, backOffPeriod, klet.podCache)</div></pre></td></tr></table></figure></p>
<p>可以看到，传给newPodWorkers()的syncPodFn为syncPod。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://fankangbest.github.com/2017/12/16/kubelet分析(二)-podWorker-v1-5-2/" data-id="cje7qu84i005v9wqsjgsjx2mq" class="article-share-link">分享</a><div class="tags"><a href="/tags/kubernetes/">kubernetes</a><a href="/tags/kubernetes-v1-5-2/">kubernetes-v1.5.2</a></div><div class="post-nav"><a href="/2017/12/17/kubelet分析(三)-volumeManager-v1-5-2/" class="pre">kubelet分析(三)-volumeManager-v1.5.2</a><a href="/2017/12/16/kubelet分析(一)-config-v1-5-2/" class="next">kubelet分析(一)-config-v1.5.2</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://fankangbest.github.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/GO语言/">GO语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/存储虚拟化/">存储虚拟化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/容器虚拟化/">容器虚拟化</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/containerd-v0-2-4/" style="font-size: 15px;">containerd-v0.2.4</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/docker-v1-12-3/" style="font-size: 15px;">docker-v1.12.3</a> <a href="/tags/GO语言/" style="font-size: 15px;">GO语言</a> <a href="/tags/containerd/" style="font-size: 15px;">containerd</a> <a href="/tags/kubernetes-v1-5-2/" style="font-size: 15px;">kubernetes-v1.5.2</a> <a href="/tags/gRPC/" style="font-size: 15px;">gRPC</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/runc/" style="font-size: 15px;">runc</a> <a href="/tags/runc-v1-0-0-rc2/" style="font-size: 15px;">runc-v1.0.0-rc2</a> <a href="/tags/ceph/" style="font-size: 15px;">ceph</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/02/26/Kubernetes-cni网络调用分析-v1-5-2/">Kubernetes-cni网络调用分析-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/10/Docker命令行分析-load-save-v1-12-3/">Docker命令行分析-load-save-v1.12.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/03/Dockerd的server启动流程分析-v1-12-3/">Dockerd的server启动流程分析-v1.12.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/21/GO语言-切片原理/">GO语言-切片原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/16/Kubernetes-resourceVersion机制分析/">Kubernetes-resourceVersion机制分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/04/Kubernetes-Ingress使用-v1-5-2/">Kubernetes-Ingress使用-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/02/kube-controller分析(五)-QuotaController-v1-5-2/">kube-controller分析(五)-QuotaController-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/01/runc源码分析(二)-namespace设置流程-v1-0-0-rc2/">runc源码分析(二)-namespace设置流程-v1.0.0-rc2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/30/Docker创建spec文件分析-v1-12-3/">Docker创建spec文件分析-v1.12.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/28/Docker工具包分析-archive-v1-12-3/">Docker工具包分析-archive-v1.12.3</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/fankangbest" title="myGithub" target="_blank">myGithub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">fankangbest.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>