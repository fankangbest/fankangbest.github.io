<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>kubernetes-controller分析(四)-garbagecollector-v1.5.2 | fankangbest</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">kubernetes-controller分析(四)-garbagecollector-v1.5.2</h1><a id="logo" href="/.">fankangbest</a><p class="description">多听，少说，接受每一个人的责难，但是保留自己的最后裁决。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">kubernetes-controller分析(四)-garbagecollector-v1.5.2</h1><div class="post-meta">Oct 31, 2017<span> | </span><span class="category"><a href="/categories/容器虚拟化/">容器虚拟化</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p>garbagecollector的功能主要有以下三点：</p>
<ol>
<li>执行联级删除时(资源删除由apiserver完成)，回收子资源；</li>
<li>执行非联级删除时，删除子资源的联级关系，再回收资源；</li>
<li>维护有资源之间的联级关系表。</li>
</ol>
<p>为了更好地说明garbagecollector的机制，将以replicationController和Pods为例，在Kubernetes v1.5.2中，可以使用<br><code>curl -XDELETE http://kubernetes:8080/api/v1/namespaces/default/replicationcontrollers/ubuntu?orphanDependents=false</code><br>执行联级删除，即删除replicationController时，后台会自动回收Pods。<br>具体见”finalizer机制”的分析。</p>
<h2 id="garbagecollector"><a href="#garbagecollector" class="headerlink" title="garbagecollector"></a>garbagecollector</h2><p>先来看下garbagecollector的定义，在/pkg/controller/garbagecollector/garbagecollector.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// GarbageCollector is responsible for carrying out cascading deletion, and</span></div><div class="line"><span class="comment">// removing ownerReferences from the dependents if the owner is deleted with</span></div><div class="line"><span class="comment">// DeleteOptions.OrphanDependents=true.</span></div><div class="line"><span class="keyword">type</span> GarbageCollector <span class="keyword">struct</span> &#123;</div><div class="line">	restMapper meta.RESTMapper</div><div class="line">	<span class="comment">// metaOnlyClientPool uses a special codec, which removes fields except for</span></div><div class="line">	<span class="comment">// apiVersion, kind, and metadata during decoding.</span></div><div class="line">	metaOnlyClientPool dynamic.ClientPool</div><div class="line">	<span class="comment">// clientPool uses the regular dynamicCodec. We need it to update</span></div><div class="line">	<span class="comment">// finalizers. It can be removed if we support patching finalizers.</span></div><div class="line">	clientPool                       dynamic.ClientPool</div><div class="line">	dirtyQueue                       *workqueue.TimedWorkQueue</div><div class="line">	orphanQueue                      *workqueue.TimedWorkQueue</div><div class="line">	monitors                         []monitor</div><div class="line">	propagator                       *Propagator</div><div class="line">	clock                            clock.Clock</div><div class="line">	registeredRateLimiter            *RegisteredRateLimiter</div><div class="line">	registeredRateLimiterForMonitors *RegisteredRateLimiter</div><div class="line">	<span class="comment">// GC caches the owners that do not exist according to the API server.</span></div><div class="line">	absentOwnerCache *UIDCache</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，主要字段的含义为：</p>
<ul>
<li>dirtyQueue: 如果某object的owner不存在，则把该object加入到dirtyQueue进行检查，如果该object所有的owner都不存在，则把object删除；</li>
<li>orphanQueue: 如果某object被标记为”orphan”，则把object的子资源的联级关系删除，然后再把object删除；</li>
<li>monitors: 对某种资源变化的监控；</li>
<li>propagator: 联级关系维护者。</li>
</ul>
<h4 id="NewGarbageCollector"><a href="#NewGarbageCollector" class="headerlink" title="NewGarbageCollector()"></a>NewGarbageCollector()</h4><p>NewGarbageCollector()可以生成一个新的GarbageCollector。在GarbageCollector中，会对某类资源生成一个monitor对其变化进行监控。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGarbageCollector</span><span class="params">(metaOnlyClientPool dynamic.ClientPool, clientPool dynamic.ClientPool, mapper meta.RESTMapper, resources []unversioned.GroupVersionResource)</span> <span class="params">(*GarbageCollector, error)</span></span> &#123;</div><div class="line">	gc := &amp;GarbageCollector&#123;</div><div class="line">		metaOnlyClientPool:               metaOnlyClientPool,</div><div class="line">		clientPool:                       clientPool,</div><div class="line">		restMapper:                       mapper,</div><div class="line">		clock:                            clock.RealClock&#123;&#125;,</div><div class="line">		dirtyQueue:                       workqueue.NewTimedWorkQueue(),</div><div class="line">		orphanQueue:                      workqueue.NewTimedWorkQueue(),</div><div class="line">		registeredRateLimiter:            NewRegisteredRateLimiter(resources),</div><div class="line">		registeredRateLimiterForMonitors: NewRegisteredRateLimiter(resources),</div><div class="line">		absentOwnerCache:                 NewUIDCache(<span class="number">500</span>),</div><div class="line">	&#125;</div><div class="line">	gc.propagator = &amp;Propagator&#123;</div><div class="line">		eventQueue: workqueue.NewTimedWorkQueue(),</div><div class="line">		uidToNode: &amp;concurrentUIDToNode&#123;</div><div class="line">			RWMutex:   &amp;sync.RWMutex&#123;&#125;,</div><div class="line">			uidToNode: <span class="built_in">make</span>(<span class="keyword">map</span>[types.UID]*node),</div><div class="line">		&#125;,</div><div class="line">		gc: gc,</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> _, resource := <span class="keyword">range</span> resources &#123;</div><div class="line">		<span class="keyword">if</span> _, ok := ignoredResources[resource]; ok &#123;</div><div class="line">			glog.V(<span class="number">6</span>).Infof(<span class="string">"ignore resource %#v"</span>, resource)</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line">		kind, err := gc.restMapper.KindFor(resource)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">if</span> _, ok := err.(*meta.NoResourceMatchError); ok &#123;</div><div class="line">				<span class="comment">// ignore NoResourceMatchErrors for now because TPRs won't be registered</span></div><div class="line">				<span class="comment">// and hence the RestMapper does not know about them. The deletableResources</span></div><div class="line">				<span class="comment">// though are using discovery which included TPRs.</span></div><div class="line">				<span class="comment">// <span class="doctag">TODO:</span> use dynamic discovery for RestMapper and deletableResources</span></div><div class="line">				glog.Warningf(<span class="string">"ignore NoResourceMatchError for %v"</span>, resource)</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">		&#125;</div><div class="line">		monitor, err := gc.monitorFor(resource, kind)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">		&#125;</div><div class="line">		gc.monitors = <span class="built_in">append</span>(gc.monitors, monitor)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> gc, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Run"><a href="#Run" class="headerlink" title="Run()"></a>Run()</h4><p>Run()可以启动GarbageCollector。主要流程是：</p>
<ol>
<li>启动monitors中的各monitor；</li>
<li>启动propagator.processEvent();</li>
<li>启动i个worker及i个orphanFinalizer；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">func (gc *GarbageCollector) Run(workers int, stopCh &lt;-chan struct&#123;&#125;) &#123;</div><div class="line">	glog.Infof(&quot;Garbage Collector: Initializing&quot;)</div><div class="line">	//***启动各种资源的monitor，以监听资源事件***//</div><div class="line">	//***把事件放入eventQueue***//</div><div class="line">	for _, monitor := range gc.monitors &#123;</div><div class="line">		go monitor.controller.Run(stopCh)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	wait.PollInfinite(10*time.Second, func() (bool, error) &#123;</div><div class="line">		for _, monitor := range gc.monitors &#123;</div><div class="line">			if !monitor.controller.HasSynced() &#123;</div><div class="line">				glog.Infof(&quot;Garbage Collector: Waiting for resource monitors to be synced...&quot;)</div><div class="line">				return false, nil</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return true, nil</div><div class="line">	&#125;)</div><div class="line">	glog.Infof(&quot;Garbage Collector: All monitored resources synced. Proceeding to collect garbage&quot;)</div><div class="line"></div><div class="line">	// worker</div><div class="line">	//***启动processEvent***//</div><div class="line">	//***从eventQueue中获取item，并存入orphanQueue中***//</div><div class="line">	go wait.Until(gc.propagator.processEvent, 0, stopCh)</div><div class="line"></div><div class="line">	//***启动workers个worker***//</div><div class="line">	for i := 0; i &lt; workers; i++ &#123;</div><div class="line">		//***检查owner存不存在，如果不存在，则回该资源***//</div><div class="line">		go wait.Until(gc.worker, 0, stopCh)</div><div class="line"></div><div class="line">		//***从orphanQueue中获取item，并执行联级删除***//</div><div class="line">		go wait.Until(gc.orphanFinalizer, 0, stopCh)</div><div class="line">	&#125;</div><div class="line">	Register()</div><div class="line">	&lt;-stopCh</div><div class="line">	glog.Infof(&quot;Garbage Collector: Shutting down&quot;)</div><div class="line">	gc.dirtyQueue.ShutDown()</div><div class="line">	gc.orphanQueue.ShutDown()</div><div class="line">	gc.propagator.eventQueue.ShutDown()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="monitorFor"><a href="#monitorFor" class="headerlink" title="monitorFor()"></a>monitorFor()</h4><p>monitorFor()可以生成一个monitor:<br>monitor的定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> monitor <span class="keyword">struct</span> &#123;</div><div class="line">	store      cache.Store</div><div class="line">	controller *cache.Controller</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>monitorFor()方法如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***监视某resource的事件，并加入到eventQueue中***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gc *GarbageCollector)</span> <span class="title">monitorFor</span><span class="params">(resource unversioned.GroupVersionResource, kind unversioned.GroupVersionKind)</span> <span class="params">(monitor, error)</span></span> &#123;</div><div class="line">	<span class="comment">// <span class="doctag">TODO:</span> consider store in one storage.</span></div><div class="line">	glog.V(<span class="number">6</span>).Infof(<span class="string">"create storage for resource %s"</span>, resource)</div><div class="line">	<span class="keyword">var</span> monitor monitor</div><div class="line">	client, err := gc.metaOnlyClientPool.ClientForGroupVersionKind(kind)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> monitor, err</div><div class="line">	&#125;</div><div class="line">	gc.registeredRateLimiterForMonitors.registerIfNotPresent(resource.GroupVersion(), client, <span class="string">"garbage_collector_monitoring"</span>)</div><div class="line">	setObjectTypeMeta := <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">		runtimeObject, ok := obj.(runtime.Object)</div><div class="line">		<span class="keyword">if</span> !ok &#123;</div><div class="line">			utilruntime.HandleError(fmt.Errorf(<span class="string">"expected runtime.Object, got %#v"</span>, obj))</div><div class="line">		&#125;</div><div class="line">		runtimeObject.GetObjectKind().SetGroupVersionKind(kind)</div><div class="line">	&#125;</div><div class="line">	monitor.store, monitor.controller = cache.NewInformer(</div><div class="line">		gcListWatcher(client, resource),</div><div class="line">		<span class="literal">nil</span>,</div><div class="line">		ResourceResyncTime,</div><div class="line">		cache.ResourceEventHandlerFuncs&#123;</div><div class="line">			<span class="comment">// add the event to the propagator's eventQueue.</span></div><div class="line">			AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">				setObjectTypeMeta(obj)</div><div class="line">				event := &amp;event&#123;</div><div class="line">					eventType: addEvent,</div><div class="line">					obj:       obj,</div><div class="line">				&#125;</div><div class="line">				gc.propagator.eventQueue.Add(&amp;workqueue.TimedWorkQueueItem&#123;StartTime: gc.clock.Now(), Object: event&#125;)</div><div class="line">			&#125;,</div><div class="line">			UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(oldObj, newObj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">				setObjectTypeMeta(newObj)</div><div class="line">				event := &amp;event&#123;updateEvent, newObj, oldObj&#125;</div><div class="line">				gc.propagator.eventQueue.Add(&amp;workqueue.TimedWorkQueueItem&#123;StartTime: gc.clock.Now(), Object: event&#125;)</div><div class="line">			&#125;,</div><div class="line">			DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">				<span class="comment">// delta fifo may wrap the object in a cache.DeletedFinalStateUnknown, unwrap it</span></div><div class="line">				<span class="keyword">if</span> deletedFinalStateUnknown, ok := obj.(cache.DeletedFinalStateUnknown); ok &#123;</div><div class="line">					obj = deletedFinalStateUnknown.Obj</div><div class="line">				&#125;</div><div class="line">				setObjectTypeMeta(obj)</div><div class="line">				event := &amp;event&#123;</div><div class="line">					eventType: deleteEvent,</div><div class="line">					obj:       obj,</div><div class="line">				&#125;</div><div class="line">				gc.propagator.eventQueue.Add(&amp;workqueue.TimedWorkQueueItem&#123;StartTime: gc.clock.Now(), Object: event&#125;)</div><div class="line">			&#125;,</div><div class="line">		&#125;,</div><div class="line">	)</div><div class="line">	<span class="keyword">return</span> monitor, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，monitor中的store和controller就是对应informer返回的store和controller。controller的handler就是把事件加入到gc.propagator.eventQueue。现在，我们找到了eventQueue的生产者，即monitor。</p>
<h4 id="worker"><a href="#worker" class="headerlink" title="worker()"></a>worker()</h4><p>worker()的作用就是消费dirtyQueue中的object，然后调用processItem()对object进行处理。<br>processItem()会检查object的owner，如果所有owner都不存在，则把object删除，以完成联级删除。<br>现在我们有了dirtyQueue的消费者，即worker。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gc *GarbageCollector)</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</div><div class="line">	timedItem, quit := gc.dirtyQueue.Get()</div><div class="line">	<span class="keyword">if</span> quit &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">defer</span> gc.dirtyQueue.Done(timedItem)</div><div class="line">	<span class="comment">//***调用processItem()处理item***//</span></div><div class="line">	err := gc.processItem(timedItem.Object.(*node))</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"Error syncing item %#v: %v"</span>, timedItem.Object, err))</div><div class="line">		<span class="comment">// retry if garbage collection of an object failed.</span></div><div class="line">		gc.dirtyQueue.Add(timedItem)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	DirtyProcessingLatency.Observe(sinceInMicroseconds(gc.clock, timedItem.StartTime))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//***检查item对应的owner是否存在，如果都不存在，则把item删除***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gc *GarbageCollector)</span> <span class="title">processItem</span><span class="params">(item *node)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="comment">// Get the latest item from the API server</span></div><div class="line">	latest, err := gc.getObject(item.identity)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">if</span> errors.IsNotFound(err) &#123;</div><div class="line">			<span class="comment">// the Propagator can add "virtual" node for an owner that doesn't</span></div><div class="line">			<span class="comment">// exist yet, so we need to enqueue a virtual Delete event to remove</span></div><div class="line">			<span class="comment">// the virtual node from Propagator.uidToNode.</span></div><div class="line">			glog.V(<span class="number">6</span>).Infof(<span class="string">"item %v not found, generating a virtual delete event"</span>, item.identity)</div><div class="line">			event := &amp;event&#123;</div><div class="line">				eventType: deleteEvent,</div><div class="line">				obj:       objectReferenceToMetadataOnlyObject(item.identity),</div><div class="line">			&#125;</div><div class="line">			glog.V(<span class="number">6</span>).Infof(<span class="string">"generating virtual delete event for %s\n\n"</span>, event.obj)</div><div class="line">			gc.propagator.eventQueue.Add(&amp;workqueue.TimedWorkQueueItem&#123;StartTime: gc.clock.Now(), Object: event&#125;)</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> latest.GetUID() != item.identity.UID &#123;</div><div class="line">		glog.V(<span class="number">6</span>).Infof(<span class="string">"UID doesn't match, item %v not found, generating a virtual delete event"</span>, item.identity)</div><div class="line">		event := &amp;event&#123;</div><div class="line">			eventType: deleteEvent,</div><div class="line">			obj:       objectReferenceToMetadataOnlyObject(item.identity),</div><div class="line">		&#125;</div><div class="line">		glog.V(<span class="number">6</span>).Infof(<span class="string">"generating virtual delete event for %s\n\n"</span>, event.obj)</div><div class="line">		gc.propagator.eventQueue.Add(&amp;workqueue.TimedWorkQueueItem&#123;StartTime: gc.clock.Now(), Object: event&#125;)</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="comment">//***获取ownerReferences***//</span></div><div class="line">	ownerReferences := latest.GetOwnerReferences()</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(ownerReferences) == <span class="number">0</span> &#123;</div><div class="line">		glog.V(<span class="number">6</span>).Infof(<span class="string">"object %s's doesn't have an owner, continue on next item"</span>, item.identity)</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="comment">// <span class="doctag">TODO:</span> we need to remove dangling references if the object is not to be</span></div><div class="line">	<span class="comment">// deleted.</span></div><div class="line">	<span class="keyword">for</span> _, reference := <span class="keyword">range</span> ownerReferences &#123;</div><div class="line">		<span class="keyword">if</span> gc.absentOwnerCache.Has(reference.UID) &#123;</div><div class="line">			glog.V(<span class="number">6</span>).Infof(<span class="string">"according to the absentOwnerCache, object %s's owner %s/%s, %s does not exist"</span>, item.identity.UID, reference.APIVersion, reference.Kind, reference.Name)</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// <span class="doctag">TODO:</span> we need to verify the reference resource is supported by the</span></div><div class="line">		<span class="comment">// system. If it's not a valid resource, the garbage collector should i)</span></div><div class="line">		<span class="comment">// ignore the reference when decide if the object should be deleted, and</span></div><div class="line">		<span class="comment">// ii) should update the object to remove such references. This is to</span></div><div class="line">		<span class="comment">// prevent objects having references to an old resource from being</span></div><div class="line">		<span class="comment">// deleted during a cluster upgrade.</span></div><div class="line">		fqKind := unversioned.FromAPIVersionAndKind(reference.APIVersion, reference.Kind)</div><div class="line">		client, err := gc.clientPool.ClientForGroupVersionKind(fqKind)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line">		resource, err := gc.apiResource(reference.APIVersion, reference.Kind, <span class="built_in">len</span>(item.identity.Namespace) != <span class="number">0</span>)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//***获取资源的owner***//</span></div><div class="line">		<span class="comment">//***如果能获取到owner，则该资源不删除***//</span></div><div class="line">		owner, err := client.Resource(resource, item.identity.Namespace).Get(reference.Name)</div><div class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">if</span> owner.GetUID() != reference.UID &#123;</div><div class="line">				glog.V(<span class="number">6</span>).Infof(<span class="string">"object %s's owner %s/%s, %s is not found, UID mismatch"</span>, item.identity.UID, reference.APIVersion, reference.Kind, reference.Name)</div><div class="line">				gc.absentOwnerCache.Add(reference.UID)</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">			glog.V(<span class="number">6</span>).Infof(<span class="string">"object %s has at least an existing owner, will not garbage collect"</span>, item.identity.UID)</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> errors.IsNotFound(err) &#123;</div><div class="line">			gc.absentOwnerCache.Add(reference.UID)</div><div class="line">			glog.V(<span class="number">6</span>).Infof(<span class="string">"object %s's owner %s/%s, %s is not found"</span>, item.identity.UID, reference.APIVersion, reference.Kind, reference.Name)</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//***如果所有的owner都不存在，则把资源回收删除***//</span></div><div class="line">	glog.V(<span class="number">2</span>).Infof(<span class="string">"none of object %s's owners exist any more, will garbage collect it"</span>, item.identity)</div><div class="line">	<span class="keyword">return</span> gc.deleteObject(item.identity)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="orphanFinalizer"><a href="#orphanFinalizer" class="headerlink" title="orphanFinalizer()"></a>orphanFinalizer()</h4><p>orphanFinalizer()会消费orphanQueue中的object，然后调用ophanDependents()删除对应dependents的联级关系，最后调用removeOrphanFinalizer()移除该object的”orphan” finalizer，并使用Update()删除该object。关于Update()删除功能，可以看/registry/generic包中的相关代码。<br>orphanDependents()会把dependent中的ownerReference中对应的owner清除。orphanDependents()是如何用patch实现删除list中的一个值的，还有待详细研究。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***执行普通删除***//</span></div><div class="line"><span class="comment">//***先清理dependents中的联级关系，再通过Update删除资源***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gc *GarbageCollector)</span> <span class="title">orphanFinalizer</span><span class="params">()</span></span> &#123;</div><div class="line">	timedItem, quit := gc.orphanQueue.Get()</div><div class="line">	<span class="keyword">if</span> quit &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">defer</span> gc.orphanQueue.Done(timedItem)</div><div class="line">	owner, ok := timedItem.Object.(*node)</div><div class="line">	<span class="keyword">if</span> !ok &#123;</div><div class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"expect *node, got %#v"</span>, timedItem.Object))</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// we don't need to lock each element, because they never get updated</span></div><div class="line">	<span class="comment">//***获取owner的dependents列表***//</span></div><div class="line">	owner.dependentsLock.RLock()</div><div class="line">	dependents := <span class="built_in">make</span>([]*node, <span class="number">0</span>, <span class="built_in">len</span>(owner.dependents))</div><div class="line">	<span class="keyword">for</span> dependent := <span class="keyword">range</span> owner.dependents &#123;</div><div class="line">		dependents = <span class="built_in">append</span>(dependents, dependent)</div><div class="line">	&#125;</div><div class="line">	owner.dependentsLock.RUnlock()</div><div class="line"></div><div class="line">	err := gc.orhpanDependents(owner.identity, dependents)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		glog.V(<span class="number">6</span>).Infof(<span class="string">"orphanDependents for %s failed with %v"</span>, owner.identity, err)</div><div class="line">		gc.orphanQueue.Add(timedItem)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	<span class="comment">// update the owner, remove "orphaningFinalizer" from its finalizers list</span></div><div class="line">	<span class="comment">//***删除orphaningFinalizer***//</span></div><div class="line">	err = gc.removeOrphanFinalizer(owner)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		glog.V(<span class="number">6</span>).Infof(<span class="string">"removeOrphanFinalizer for %s failed with %v"</span>, owner.identity, err)</div><div class="line">		gc.orphanQueue.Add(timedItem)</div><div class="line">	&#125;</div><div class="line">	OrphanProcessingLatency.Observe(sinceInMicroseconds(gc.clock, timedItem.StartTime))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//***清理dependents的ownerReference***//</span></div><div class="line"><span class="comment">//***此处orphanDependents写错了***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gc *GarbageCollector)</span> <span class="title">orhpanDependents</span><span class="params">(owner objectReference, dependents []*node)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> failedDependents []objectReference</div><div class="line">	<span class="keyword">var</span> errorsSlice []error</div><div class="line">	<span class="keyword">for</span> _, dependent := <span class="keyword">range</span> dependents &#123;</div><div class="line">		<span class="comment">// the dependent.identity.UID is used as precondition</span></div><div class="line">		deleteOwnerRefPatch := fmt.Sprintf(<span class="string">`&#123;"metadata":&#123;"ownerReferences":[&#123;"$patch":"delete","uid":"%s"&#125;],"uid":"%s"&#125;&#125;`</span>, owner.UID, dependent.identity.UID)</div><div class="line">		_, err := gc.patchObject(dependent.identity, []<span class="keyword">byte</span>(deleteOwnerRefPatch))</div><div class="line">		<span class="comment">// note that if the target ownerReference doesn't exist in the</span></div><div class="line">		<span class="comment">// dependent, strategic merge patch will NOT return an error.</span></div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; !errors.IsNotFound(err) &#123;</div><div class="line">			errorsSlice = <span class="built_in">append</span>(errorsSlice, fmt.Errorf(<span class="string">"orphaning %s failed with %v"</span>, dependent.identity, err))</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(failedDependents) != <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to orphan dependents of owner %s, got errors: %s"</span>, owner, utilerrors.NewAggregate(errorsSlice).Error())</div><div class="line">	&#125;</div><div class="line">	glog.V(<span class="number">6</span>).Infof(<span class="string">"successfully updated all dependents"</span>)</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="removeOrphanFinalizer"><a href="#removeOrphanFinalizer" class="headerlink" title="removeOrphanFinalizer()"></a>removeOrphanFinalizer()</h4><p>removeOrphanFinalizer()可以删除”orphan” finalizer，然后更新该object，注意更新操作在某些条件是删除。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***移除"orphan" finalizer***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gc *GarbageCollector)</span> <span class="title">removeOrphanFinalizer</span><span class="params">(owner *node)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">const</span> retries = <span class="number">5</span></div><div class="line">	<span class="keyword">for</span> count := <span class="number">0</span>; count &lt; retries; count++ &#123;</div><div class="line">		ownerObject, err := gc.getObject(owner.identity)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"cannot finalize owner %s, because cannot get it. The garbage collector will retry later."</span>, owner.identity)</div><div class="line">		&#125;</div><div class="line">		accessor, err := meta.Accessor(ownerObject)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"cannot access the owner object: %v. The garbage collector will retry later."</span>, err)</div><div class="line">		&#125;</div><div class="line">		finalizers := accessor.GetFinalizers()</div><div class="line">		<span class="keyword">var</span> newFinalizers []<span class="keyword">string</span></div><div class="line">		found := <span class="literal">false</span></div><div class="line">		<span class="keyword">for</span> _, f := <span class="keyword">range</span> finalizers &#123;</div><div class="line">			<span class="keyword">if</span> f == api.FinalizerOrphan &#123;</div><div class="line">				found = <span class="literal">true</span></div><div class="line">				<span class="keyword">break</span></div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				newFinalizers = <span class="built_in">append</span>(newFinalizers, f)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> !found &#123;</div><div class="line">			glog.V(<span class="number">6</span>).Infof(<span class="string">"the orphan finalizer is already removed from object %s"</span>, owner.identity)</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// remove the owner from dependent's OwnerReferences</span></div><div class="line">		ownerObject.SetFinalizers(newFinalizers)</div><div class="line">		<span class="comment">//***更新的时候在一定条件下会删除资源***//</span></div><div class="line">		_, err = gc.updateObject(owner.identity, ownerObject)</div><div class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; !errors.IsConflict(err) &#123;</div><div class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"cannot update the finalizers of owner %s, with error: %v, tried %d times"</span>, owner.identity, err, count+<span class="number">1</span>)</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// retry if it's a conflict</span></div><div class="line">		glog.V(<span class="number">6</span>).Infof(<span class="string">"got conflict updating the owner object %s, tried %d times"</span>, owner.identity, count+<span class="number">1</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> fmt.Errorf(<span class="string">"updateMaxRetries(%d) has reached. The garbage collector will retry later for owner %v."</span>, retries, owner.identity)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来，我们来看下联级关系维护者-Propagator。</p>
<h2 id="Propagator"><a href="#Propagator" class="headerlink" title="Propagator"></a>Propagator</h2><p>Propagator维护结构体值间的联级关系，定义在/pkg/controller/garbagecollector/garbagecollector.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Propagator <span class="keyword">struct</span> &#123;</div><div class="line">	eventQueue *workqueue.TimedWorkQueue</div><div class="line">	<span class="comment">// uidToNode doesn't require a lock to protect, because only the</span></div><div class="line">	<span class="comment">// single-threaded Propagator.processEvent() reads/writes it.</span></div><div class="line">	uidToNode *concurrentUIDToNode</div><div class="line">	gc        *GarbageCollector</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结构体间的联级关系是通过node的概念来维护的，node定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// node does not require a lock to protect. The single-threaded</span></div><div class="line"><span class="comment">// Propagator.processEvent() is the sole writer of the nodes. The multi-threaded</span></div><div class="line"><span class="comment">// GarbageCollector.processItem() reads the nodes, but it only reads the fields</span></div><div class="line"><span class="comment">// that never get changed by Propagator.processEvent().</span></div><div class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</div><div class="line">	identity objectReference</div><div class="line">	<span class="comment">// dependents will be read by the orphan() routine, we need to protect it with a lock.</span></div><div class="line">	dependentsLock sync.RWMutex</div><div class="line">	dependents     <span class="keyword">map</span>[*node]<span class="keyword">struct</span>&#123;&#125;</div><div class="line">	<span class="comment">// When processing an Update event, we need to compare the updated</span></div><div class="line">	<span class="comment">// ownerReferences with the owners recorded in the graph.</span></div><div class="line">	owners []metatypes.OwnerReference</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，node的dependents字段表示该node的dependents；owners字段表示该node的owners。</p>
<h4 id="insertNode"><a href="#insertNode" class="headerlink" title="insertNode()"></a>insertNode()</h4><p>insertNode()可以更新node及其联级关系。<br>insertNode()会调用addDependentToOwners()。addDependentToOwners()会检查该node的owner是否存在，如有不存在的情况，则把该node加入到dirtyQueue中供worker消费。所以dirtyQueue的生产者是insertNode()，消费者是worker()。insertNode()在<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***把资源加入到owners的依赖表中***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Propagator)</span> <span class="title">insertNode</span><span class="params">(n *node)</span></span> &#123;</div><div class="line">	p.uidToNode.Write(n)</div><div class="line">	p.addDependentToOwners(n, n.owners)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//***把资源加到owner的dependents list中***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Propagator)</span> <span class="title">addDependentToOwners</span><span class="params">(n *node, owners []metatypes.OwnerReference)</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> _, owner := <span class="keyword">range</span> owners &#123;</div><div class="line">		ownerNode, ok := p.uidToNode.Read(owner.UID)</div><div class="line">		<span class="keyword">if</span> !ok &#123;</div><div class="line">			<span class="comment">// Create a "virtual" node in the graph for the owner if it doesn't</span></div><div class="line">			<span class="comment">// exist in the graph yet. Then enqueue the virtual node into the</span></div><div class="line">			<span class="comment">// dirtyQueue. The garbage processor will enqueue a virtual delete</span></div><div class="line">			<span class="comment">// event to delete it from the graph if API server confirms this</span></div><div class="line">			<span class="comment">// owner doesn't exist.</span></div><div class="line">			ownerNode = &amp;node&#123;</div><div class="line">				identity: objectReference&#123;</div><div class="line">					OwnerReference: owner,</div><div class="line">					Namespace:      n.identity.Namespace,</div><div class="line">				&#125;,</div><div class="line">				dependents: <span class="built_in">make</span>(<span class="keyword">map</span>[*node]<span class="keyword">struct</span>&#123;&#125;),</div><div class="line">			&#125;</div><div class="line">			glog.V(<span class="number">6</span>).Infof(<span class="string">"add virtual node.identity: %s\n\n"</span>, ownerNode.identity)</div><div class="line">			p.uidToNode.Write(ownerNode)</div><div class="line">			<span class="comment">//***如果有owner不存在，则把node加入到dirtyQueue做检查***//</span></div><div class="line">			<span class="comment">//***因为该node可能具备回收的条件***//</span></div><div class="line">			p.gc.dirtyQueue.Add(&amp;workqueue.TimedWorkQueueItem&#123;StartTime: p.gc.clock.Now(), Object: ownerNode&#125;)</div><div class="line">		&#125;</div><div class="line">		ownerNode.addDependent(n)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="processEvent"><a href="#processEvent" class="headerlink" title="processEvent()"></a>processEvent()</h4><p>processEvent()从eventQueue中取得item并进行处理。处理的过程主要是维护联级关系及在适当的时候调用了insertNode和把object加入到orphanQueue中。所以，processEvent()是orphanQueue的生产者。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***从eventQueue中获取item并处理***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Propagator)</span> <span class="title">processEvent</span><span class="params">()</span></span> &#123;</div><div class="line">	timedItem, quit := p.eventQueue.Get()</div><div class="line">	<span class="keyword">if</span> quit &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">defer</span> p.eventQueue.Done(timedItem)</div><div class="line">	event, ok := timedItem.Object.(*event)</div><div class="line">	<span class="keyword">if</span> !ok &#123;</div><div class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"expect a *event, got %v"</span>, timedItem.Object))</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	obj := event.obj</div><div class="line">	accessor, err := meta.Accessor(obj)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"cannot access obj: %v"</span>, err))</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	typeAccessor, err := meta.TypeAccessor(obj)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"cannot access obj: %v"</span>, err))</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	glog.V(<span class="number">6</span>).Infof(<span class="string">"Propagator process object: %s/%s, namespace %s, name %s, event type %s"</span>, typeAccessor.GetAPIVersion(), typeAccessor.GetKind(), accessor.GetNamespace(), accessor.GetName(), event.eventType)</div><div class="line">	<span class="comment">// Check if the node already exsits</span></div><div class="line">	existingNode, found := p.uidToNode.Read(accessor.GetUID())</div><div class="line">	<span class="keyword">switch</span> &#123;</div><div class="line">	<span class="keyword">case</span> (event.eventType == addEvent || event.eventType == updateEvent) &amp;&amp; !found:</div><div class="line">		newNode := &amp;node&#123;</div><div class="line">			identity: objectReference&#123;</div><div class="line">				OwnerReference: metatypes.OwnerReference&#123;</div><div class="line">					APIVersion: typeAccessor.GetAPIVersion(),</div><div class="line">					Kind:       typeAccessor.GetKind(),</div><div class="line">					UID:        accessor.GetUID(),</div><div class="line">					Name:       accessor.GetName(),</div><div class="line">				&#125;,</div><div class="line">				Namespace: accessor.GetNamespace(),</div><div class="line">			&#125;,</div><div class="line">			dependents: <span class="built_in">make</span>(<span class="keyword">map</span>[*node]<span class="keyword">struct</span>&#123;&#125;),</div><div class="line">			owners:     accessor.GetOwnerReferences(),</div><div class="line">		&#125;</div><div class="line">		p.insertNode(newNode)</div><div class="line">		<span class="comment">// the underlying delta_fifo may combine a creation and deletion into one event</span></div><div class="line">		<span class="keyword">if</span> shouldOrphanDependents(event, accessor) &#123;</div><div class="line">			glog.V(<span class="number">6</span>).Infof(<span class="string">"add %s to the orphanQueue"</span>, newNode.identity)</div><div class="line">			<span class="comment">//***把object加入到orphanQueue中***//</span></div><div class="line">			p.gc.orphanQueue.Add(&amp;workqueue.TimedWorkQueueItem&#123;StartTime: p.gc.clock.Now(), Object: newNode&#125;)</div><div class="line">		&#125;</div><div class="line">	<span class="keyword">case</span> (event.eventType == addEvent || event.eventType == updateEvent) &amp;&amp; found:</div><div class="line">		<span class="comment">// caveat: if GC observes the creation of the dependents later than the</span></div><div class="line">		<span class="comment">// deletion of the owner, then the orphaning finalizer won't be effective.</span></div><div class="line">		<span class="keyword">if</span> shouldOrphanDependents(event, accessor) &#123;</div><div class="line">			glog.V(<span class="number">6</span>).Infof(<span class="string">"add %s to the orphanQueue"</span>, existingNode.identity)</div><div class="line">			p.gc.orphanQueue.Add(&amp;workqueue.TimedWorkQueueItem&#123;StartTime: p.gc.clock.Now(), Object: existingNode&#125;)</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// add/remove owner refs</span></div><div class="line">		added, removed := referencesDiffs(existingNode.owners, accessor.GetOwnerReferences())</div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(added) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(removed) == <span class="number">0</span> &#123;</div><div class="line">			glog.V(<span class="number">6</span>).Infof(<span class="string">"The updateEvent %#v doesn't change node references, ignore"</span>, event)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// update the node itself</span></div><div class="line">		existingNode.owners = accessor.GetOwnerReferences()</div><div class="line">		<span class="comment">// Add the node to its new owners' dependent lists.</span></div><div class="line">		p.addDependentToOwners(existingNode, added)</div><div class="line">		<span class="comment">// remove the node from the dependent list of node that are no long in</span></div><div class="line">		<span class="comment">// the node's owners list.</span></div><div class="line">		p.removeDependentFromOwners(existingNode, removed)</div><div class="line">	<span class="keyword">case</span> event.eventType == deleteEvent:</div><div class="line">		<span class="keyword">if</span> !found &#123;</div><div class="line">			glog.V(<span class="number">6</span>).Infof(<span class="string">"%v doesn't exist in the graph, this shouldn't happen"</span>, accessor.GetUID())</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">		p.removeNode(existingNode)</div><div class="line">		existingNode.dependentsLock.RLock()</div><div class="line">		<span class="keyword">defer</span> existingNode.dependentsLock.RUnlock()</div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(existingNode.dependents) &gt; <span class="number">0</span> &#123;</div><div class="line">			p.gc.absentOwnerCache.Add(accessor.GetUID())</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> dep := <span class="keyword">range</span> existingNode.dependents &#123;</div><div class="line">			p.gc.dirtyQueue.Add(&amp;workqueue.TimedWorkQueueItem&#123;StartTime: p.gc.clock.Now(), Object: dep&#125;)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	EventProcessingLatency.Observe(sinceInMicroseconds(p.gc.clock, timedItem.StartTime))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h2><p>最后来看下shouldOrphanDependents()。</p>
<h4 id="shouldOrphanDependents"><a href="#shouldOrphanDependents" class="headerlink" title="shouldOrphanDependents()"></a>shouldOrphanDependents()</h4><p>shouldOrphanDependents()检查object是否有”orphan” finalizer，如果存在，则返回true。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">shouldOrphanDependents</span><span class="params">(e *event, accessor meta.Object)</span> <span class="title">bool</span></span> &#123;</div><div class="line">	<span class="comment">// The delta_fifo may combine the creation and update of the object into one</span></div><div class="line">	<span class="comment">// event, so we need to check AddEvent as well.</span></div><div class="line">	<span class="keyword">if</span> e.oldObj == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">if</span> accessor.GetDeletionTimestamp() == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span></div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		oldAccessor, err := meta.Accessor(e.oldObj)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			utilruntime.HandleError(fmt.Errorf(<span class="string">"cannot access oldObj: %v"</span>, err))</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// ignore the event if it's not updating DeletionTimestamp from non-nil to nil.</span></div><div class="line">		<span class="keyword">if</span> accessor.GetDeletionTimestamp() == <span class="literal">nil</span> || oldAccessor.GetDeletionTimestamp() != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//***如果存在"orphan" finalizer，则返回true***//</span></div><div class="line">	finalizers := accessor.GetFinalizers()</div><div class="line">	<span class="keyword">for</span> _, finalizer := <span class="keyword">range</span> finalizers &#123;</div><div class="line">		<span class="keyword">if</span> finalizer == api.FinalizerOrphan &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个garbagecollector可以看成是三个channel的交互：<br>eventQueue：用于存放资源的事件。<br>生产者：monitor<br>消费者：Progator的processEvent()</p>
<p>orphanQueue：用于存放需要需要”orphan”操作(即解除联级关系)的object。<br>生产者：Progator的processEvent()<br>消费者：GarbageCollector的orphanFinalizer()</p>
<p>dirtyQueue: 用于存放需要owner检查(所有owner都不存在，则删除，即联级删除)的object。<br>生产者：Progator的insertNode()，在processEvent()中有调用<br>消费者：GarbageCollector的worker</p>
<p>那么，Pod是如何和ReplicationController关联起来的呢，在replication_controller上会把ReplicationController的信息作为ownerReference加入到Pod中。而整个GarbageCollector也就是通过object的ownerReference来维护整个联级关系表的。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://fankangbest.github.com/2017/10/31/kubernetes-controller分析(四)-garbagecollector-v1-5-2/" data-id="cjadhapce005y9kqs4f9la7lq" class="article-share-link">分享</a><div class="tags"><a href="/tags/kubernetes/">kubernetes</a><a href="/tags/kubernetes-v1-5-2/">kubernetes-v1.5.2</a></div><div class="post-nav"><a href="/2017/11/11/gRPC-demo/" class="pre">gRPC-demo</a><a href="/2017/10/30/Docker镜像存储代码分析-layerStore-v1-12-3/" class="next">Docker镜像存储代码分析-layerStore-v1.12.3</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://fankangbest.github.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/GO语言/">GO语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/存储虚拟化/">存储虚拟化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/容器虚拟化/">容器虚拟化</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/containerd-v0-2-4/" style="font-size: 15px;">containerd-v0.2.4</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/docker-v1-12-3/" style="font-size: 15px;">docker-v1.12.3</a> <a href="/tags/GO语言/" style="font-size: 15px;">GO语言</a> <a href="/tags/containerd/" style="font-size: 15px;">containerd</a> <a href="/tags/kubernetes-v1-5-2/" style="font-size: 15px;">kubernetes-v1.5.2</a> <a href="/tags/gRPC/" style="font-size: 15px;">gRPC</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/ceph/" style="font-size: 15px;">ceph</a> <a href="/tags/runc/" style="font-size: 15px;">runc</a> <a href="/tags/runc-v1-0-0-rc2/" style="font-size: 15px;">runc-v1.0.0-rc2</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/11/24/containerd-containerd-shim和runc的依存关系/">containerd,containerd-shim和runc的依存关系</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/22/runc源码分析(一)-create和start流程-v1-0-0-rc2/">runc源码分析(一)-create和start流程-v1.0.0-rc2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/19/containerd-shim源码分析-v0-2-4/">containerd-shim源码分析-v0.2.4</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/19/containerd-container和process-v0-2-4/">containerd-container和process-v0.2.4</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/16/containerd执行流程分析-v0-2-4/">containerd执行流程分析-v0.2.4</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/13/containerd-crt命令行使用-v0-2-4/">containerd-crt命令行使用-v0.2.4</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/11/gRPC-demo/">gRPC-demo</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/31/kubernetes-controller分析(四)-garbagecollector-v1-5-2/">kubernetes-controller分析(四)-garbagecollector-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/Docker镜像存储代码分析-layerStore-v1-12-3/">Docker镜像存储代码分析-layerStore-v1.12.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/Docker镜像存储代码分析-referenceStore-v1-12-3/">Docker镜像存储代码分析-referenceStore-v1.12.3</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/fankangbest" title="myGithub" target="_blank">myGithub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">fankangbest.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>