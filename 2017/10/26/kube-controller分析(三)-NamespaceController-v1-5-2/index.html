<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>kube-controller分析(三)-NamespaceController-v1.5.2 | fankangbest</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">kube-controller分析(三)-NamespaceController-v1.5.2</h1><a id="logo" href="/.">fankangbest</a><p class="description">多听，少说，接受每一个人的责难，但是保留自己的最后裁决。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">kube-controller分析(三)-NamespaceController-v1.5.2</h1><div class="post-meta">Oct 26, 2017<span> | </span><span class="category"><a href="/categories/容器虚拟化/">容器虚拟化</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h2 id="什么是NamespaceController"><a href="#什么是NamespaceController" class="headerlink" title="什么是NamespaceController"></a>什么是NamespaceController</h2><p>NamespaceController负责Namespace的删除。我们知道，当我们删除Namespace的时候，Apiserver并不会删除Namespace，仅仅设置了deletionTimestamp字段。所以，整个Namespace的删除工作由NamespaceController完成。NamespaceController会轮询并处理每一个Namespace。</p>
<h2 id="NamespaceController定义"><a href="#NamespaceController定义" class="headerlink" title="NamespaceController定义"></a>NamespaceController定义</h2><p>NamespaceController定义在/pkg/controller/namespace/namespace_controller.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NamespaceController is responsible for performing actions dependent upon a namespace phase</span></div><div class="line"><span class="keyword">type</span> NamespaceController <span class="keyword">struct</span> &#123;</div><div class="line">	<span class="comment">// client that purges namespace content, must have list/delete privileges on all content</span></div><div class="line">	kubeClient clientset.Interface</div><div class="line">	<span class="comment">// clientPool manages a pool of dynamic clients</span></div><div class="line">	clientPool dynamic.ClientPool</div><div class="line">	<span class="comment">// store that holds the namespaces</span></div><div class="line">	store cache.Store</div><div class="line">	<span class="comment">// controller that observes the namespaces</span></div><div class="line">	controller *cache.Controller</div><div class="line">	<span class="comment">// namespaces that have been queued up for processing by workers</span></div><div class="line">	queue workqueue.RateLimitingInterface</div><div class="line">	<span class="comment">// function to list of preferred group versions and their corresponding resource set for namespace deletion</span></div><div class="line">	groupVersionResourcesFn <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">([]unversioned.GroupVersionResource, error)</span></span></div><div class="line">	// <span class="title">opCache</span> <span class="title">is</span> <span class="title">a</span> <span class="title">cache</span> <span class="title">to</span> <span class="title">remember</span> <span class="title">if</span> <span class="title">a</span> <span class="title">particular</span> <span class="title">operation</span> <span class="title">is</span> <span class="title">not</span> <span class="title">supported</span> <span class="title">to</span> <span class="title">aid</span> <span class="title">dynamic</span> <span class="title">client</span>.</div><div class="line">	<span class="title">opCache</span> *<span class="title">operationNotSupportedCache</span></div><div class="line">	// <span class="title">finalizerToken</span> <span class="title">is</span> <span class="title">the</span> <span class="title">finalizer</span> <span class="title">token</span> <span class="title">managed</span> <span class="title">by</span> <span class="title">this</span> <span class="title">controller</span></div><div class="line">	<span class="title">finalizerToken</span> <span class="title">api</span>.<span class="title">FinalizerName</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>各字段涵义如下：<br>kubeClient: 给controller用；<br>clientPool: 用来生成dynamicClient；<br>store: 存储namespace用，namespace的informer的store返回值；<br>controller: namespace的informer的controller返回值；<br>queue: 待处理的namespace队列；</p>
<p>再来看下NamespaceController的生成函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NewNamespaceController creates a new NamespaceController</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNamespaceController</span><span class="params">(</span></span></div><div class="line">	kubeClient clientset.Interface,</div><div class="line">	clientPool dynamic.ClientPool,</div><div class="line">	groupVersionResourcesFn <span class="keyword">func</span>() <span class="params">([]unversioned.GroupVersionResource, error)</span>,</div><div class="line">	<span class="title">resyncPeriod</span> <span class="title">time</span>.<span class="title">Duration</span>,</div><div class="line">	<span class="title">finalizerToken</span> <span class="title">api</span>.<span class="title">FinalizerName</span>) *<span class="title">NamespaceController</span> &#123;</div><div class="line"></div><div class="line">	<span class="comment">// the namespace deletion code looks at the discovery document to enumerate the set of resources on the server.</span></div><div class="line">	<span class="comment">// it then finds all namespaced resources, and in response to namespace deletion, will call delete on all of them.</span></div><div class="line">	<span class="comment">// unfortunately, the discovery information does not include the list of supported verbs/methods.  if the namespace</span></div><div class="line">	<span class="comment">// controller calls LIST/DELETECOLLECTION for a resource, it will get a 405 error from the server and cache that that was the case.</span></div><div class="line">	<span class="comment">// we found in practice though that some auth engines when encountering paths they don't know about may return a 50x.</span></div><div class="line">	<span class="comment">// until we have verbs, we pre-populate resources that do not support list or delete for well-known apis rather than</span></div><div class="line">	<span class="comment">// probing the server once in order to be told no.</span></div><div class="line">	opCache := &amp;operationNotSupportedCache&#123;</div><div class="line">		m: <span class="built_in">make</span>(<span class="keyword">map</span>[operationKey]<span class="keyword">bool</span>),</div><div class="line">	&#125;</div><div class="line">	ignoredGroupVersionResources := []unversioned.GroupVersionResource&#123;</div><div class="line">		&#123;Group: <span class="string">""</span>, Version: <span class="string">"v1"</span>, Resource: <span class="string">"bindings"</span>&#125;,</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> _, ignoredGroupVersionResource := <span class="keyword">range</span> ignoredGroupVersionResources &#123;</div><div class="line">		opCache.setNotSupported(operationKey&#123;op: operationDeleteCollection, gvr: ignoredGroupVersionResource&#125;)</div><div class="line">		opCache.setNotSupported(operationKey&#123;op: operationList, gvr: ignoredGroupVersionResource&#125;)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// create the controller so we can inject the enqueue function</span></div><div class="line">	<span class="comment">//***生成新的NamespaceController***//</span></div><div class="line">	namespaceController := &amp;NamespaceController&#123;</div><div class="line">		kubeClient: kubeClient,</div><div class="line">		clientPool: clientPool,</div><div class="line">		queue:      workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">"namespace"</span>),</div><div class="line">		groupVersionResourcesFn: groupVersionResourcesFn,</div><div class="line">		opCache:                 opCache,</div><div class="line">		finalizerToken:          finalizerToken,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> kubeClient != <span class="literal">nil</span> &amp;&amp; kubeClient.Core().RESTClient().GetRateLimiter() != <span class="literal">nil</span> &#123;</div><div class="line">		metrics.RegisterMetricAndTrackRateLimiterUsage(<span class="string">"namespace_controller"</span>, kubeClient.Core().RESTClient().GetRateLimiter())</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// configure the backing store/controller</span></div><div class="line">	<span class="comment">//***生成namespace store和namespace controller***//</span></div><div class="line">	store, controller := cache.NewInformer(</div><div class="line">		&amp;cache.ListWatch&#123;</div><div class="line">			ListFunc: <span class="function"><span class="keyword">func</span><span class="params">(options api.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</div><div class="line">				<span class="keyword">return</span> kubeClient.Core().Namespaces().List(options)</div><div class="line">			&#125;,</div><div class="line">			WatchFunc: <span class="function"><span class="keyword">func</span><span class="params">(options api.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</div><div class="line">				<span class="keyword">return</span> kubeClient.Core().Namespaces().Watch(options)</div><div class="line">			&#125;,</div><div class="line">		&#125;,</div><div class="line">		&amp;api.Namespace&#123;&#125;,</div><div class="line">		resyncPeriod,</div><div class="line">		cache.ResourceEventHandlerFuncs&#123;</div><div class="line">			AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">				namespace := obj.(*api.Namespace)</div><div class="line">				namespaceController.enqueueNamespace(namespace)</div><div class="line">			&#125;,</div><div class="line">			UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(oldObj, newObj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">				namespace := newObj.(*api.Namespace)</div><div class="line">				namespaceController.enqueueNamespace(namespace)</div><div class="line">			&#125;,</div><div class="line">		&#125;,</div><div class="line">	)</div><div class="line"></div><div class="line">	namespaceController.store = store</div><div class="line">	namespaceController.controller = controller</div><div class="line">	<span class="keyword">return</span> namespaceController</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>生成函数比较简单，使用enqueueNamespace()方法作为Informer的处理函数，即Informer中controller获取到的item在存储到store中的同时，也会调用enqueuenamespace()来处理。关于Informer，详见<a href="https://fankangbest.github.io/2017/08/25/cache%E8%A7%A3%E8%AF%BB(%E4%B8%89)-Controller-v1-5-2/" target="_blank" rel="external">https://fankangbest.github.io/2017/08/25/cache%E8%A7%A3%E8%AF%BB(%E4%B8%89)-Controller-v1-5-2/</a> 。</p>
<h2 id="queue的生成者"><a href="#queue的生成者" class="headerlink" title="queue的生成者"></a>queue的生成者</h2><p>queue的生产者为enqueueNamespace()，定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***把namespace加入到queue中***//</span></div><div class="line"><span class="comment">//***作为namespace informer的处理函数***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nm *NamespaceController)</span> <span class="title">enqueueNamespace</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">	key, err := controller.KeyFunc(obj)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		glog.Errorf(<span class="string">"Couldn't get key for object %+v: %v"</span>, obj, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	<span class="comment">// delay processing namespace events to allow HA api servers to observe namespace deletion,</span></div><div class="line">	<span class="comment">// and HA etcd servers to observe last minute object creations inside the namespace</span></div><div class="line">	nm.queue.AddAfter(key, namespaceDeletionGracePeriod)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，enqueueNamespace()会把namespace的key放入到queue中。</p>
<h2 id="queue的消费者"><a href="#queue的消费者" class="headerlink" title="queue的消费者"></a>queue的消费者</h2><p>queue由worker()消费。worker()定义在/pkg/controller/namespace/namespace_controller.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// worker processes the queue of namespace objects.</span></div><div class="line"><span class="comment">// Each namespace can be in the queue at most once.</span></div><div class="line"><span class="comment">// The system ensures that no two workers can process</span></div><div class="line"><span class="comment">// the same namespace at the same time.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nm *NamespaceController)</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</div><div class="line">	workFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</div><div class="line">		<span class="comment">//***从queue中获取数据***//</span></div><div class="line">		key, quit := nm.queue.Get()</div><div class="line">		<span class="keyword">if</span> quit &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">defer</span> nm.queue.Done(key)</div><div class="line"></div><div class="line">		<span class="comment">//***处理namespace***//</span></div><div class="line">		err := nm.syncNamespaceFromKey(key.(<span class="keyword">string</span>))</div><div class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="comment">// no error, forget this entry and return</span></div><div class="line">			nm.queue.Forget(key)</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> estimate, ok := err.(*contentRemainingError); ok &#123;</div><div class="line">			t := estimate.Estimate/<span class="number">2</span> + <span class="number">1</span></div><div class="line">			glog.V(<span class="number">4</span>).Infof(<span class="string">"Content remaining in namespace %s, waiting %d seconds"</span>, key, t)</div><div class="line">			nm.queue.AddAfter(key, time.Duration(t)*time.Second)</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">// rather than wait for a full resync, re-add the namespace to the queue to be processed</span></div><div class="line">			nm.queue.AddRateLimited(key)</div><div class="line">			utilruntime.HandleError(err)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		quit := workFunc()</div><div class="line"></div><div class="line">		<span class="keyword">if</span> quit &#123;</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>worker()会从queue中获取一个key，然后使用syncNamespaceFromKey()对该key所对应的Namespace进行处理。</p>
<p>先来看下worker()是如何启动的。</p>
<h2 id="Run"><a href="#Run" class="headerlink" title="Run()"></a>Run()</h2><p>Run()负责启动NamespaceController的controller和worker。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Run starts observing the system with the specified number of workers.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nm *NamespaceController)</span> <span class="title">Run</span><span class="params">(workers <span class="keyword">int</span>, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</div><div class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</div><div class="line">	<span class="comment">//***启动controller***//</span></div><div class="line">	<span class="keyword">go</span> nm.controller.Run(stopCh)</div><div class="line">	<span class="comment">//***启动workers***//</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</div><div class="line">		<span class="keyword">go</span> wait.Until(nm.worker, time.Second, stopCh)</div><div class="line">	&#125;</div><div class="line">	&lt;-stopCh</div><div class="line">	glog.Infof(<span class="string">"Shutting down NamespaceController"</span>)</div><div class="line">	nm.queue.ShutDown()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再来看Namespace的处理函数syncNamespaceFromKey()。</p>
<h2 id="syncNamespaceFromKey"><a href="#syncNamespaceFromKey" class="headerlink" title="syncNamespaceFromKey()"></a>syncNamespaceFromKey()</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// syncNamespaceFromKey looks for a namespace with the specified key in its store and synchronizes it</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nm *NamespaceController)</span> <span class="title">syncNamespaceFromKey</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</div><div class="line">	startTime := time.Now()</div><div class="line">	<span class="keyword">defer</span> glog.V(<span class="number">4</span>).Infof(<span class="string">"Finished syncing namespace %q (%v)"</span>, key, time.Now().Sub(startTime))</div><div class="line"></div><div class="line">	<span class="comment">//***通过key获取具体namespace***//</span></div><div class="line">	obj, exists, err := nm.store.GetByKey(key)</div><div class="line">	<span class="keyword">if</span> !exists &#123;</div><div class="line">		glog.Infof(<span class="string">"Namespace has been deleted %v"</span>, key)</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		glog.Errorf(<span class="string">"Unable to retrieve namespace %v from store: %v"</span>, key, err)</div><div class="line">		nm.queue.Add(key)</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	namespace := obj.(*api.Namespace)</div><div class="line">	<span class="comment">//***调用syncNamespace()清除删除的namespace的资源***//</span></div><div class="line">	<span class="keyword">return</span> syncNamespace(nm.kubeClient, nm.clientPool, nm.opCache, nm.groupVersionResourcesFn, namespace, nm.finalizerToken)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>syncNamespaceFromKey()依据key从store中获取具体的namespace，然后调用syncNamespace()对Namespace进行处理。</p>
<h2 id="syncNamespace"><a href="#syncNamespace" class="headerlink" title="syncNamespace()"></a>syncNamespace()</h2><p>syncNamespace()定义在/pkg/controller/namespace/namespace_controller_utils.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***清理删除的Namespace的资源***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">syncNamespace</span><span class="params">(</span></span></div><div class="line">	kubeClient clientset.Interface,</div><div class="line">	clientPool dynamic.ClientPool,</div><div class="line">	opCache *operationNotSupportedCache,</div><div class="line">	groupVersionResourcesFn <span class="keyword">func</span>() <span class="params">([]unversioned.GroupVersionResource, error)</span>,</div><div class="line">	<span class="title">namespace</span> *<span class="title">api</span>.<span class="title">Namespace</span>,</div><div class="line">	<span class="title">finalizerToken</span> <span class="title">api</span>.<span class="title">FinalizerName</span>,</div><div class="line">) <span class="title">error</span> &#123;</div><div class="line">	<span class="comment">//***未被标记为删除，则直接返回***//</span></div><div class="line">	<span class="keyword">if</span> namespace.DeletionTimestamp == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// multiple controllers may edit a namespace during termination</span></div><div class="line">	<span class="comment">// first get the latest state of the namespace before proceeding</span></div><div class="line">	<span class="comment">// if the namespace was deleted already, don't do anything</span></div><div class="line">	<span class="comment">//***如果namespace不存在，则直接返回***//</span></div><div class="line">	namespace, err := kubeClient.Core().Namespaces().Get(namespace.Name)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">if</span> errors.IsNotFound(err) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	glog.V(<span class="number">5</span>).Infof(<span class="string">"namespace controller - syncNamespace - namespace: %s, finalizerToken: %s"</span>, namespace.Name, finalizerToken)</div><div class="line"></div><div class="line">	<span class="comment">// ensure that the status is up to date on the namespace</span></div><div class="line">	<span class="comment">// if we get a not found error, we assume the namespace is truly gone</span></div><div class="line">	namespace, err = retryOnConflictError(kubeClient, namespace, updateNamespaceStatusFunc)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">if</span> errors.IsNotFound(err) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// the latest view of the namespace asserts that namespace is no longer deleting..</span></div><div class="line">	<span class="keyword">if</span> namespace.DeletionTimestamp.IsZero() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// if the namespace is already finalized, delete it</span></div><div class="line">	<span class="comment">//***如果该namespace的kubernetes已经被移除，则直接删除namespace***//</span></div><div class="line">	<span class="keyword">if</span> finalized(namespace) &#123;</div><div class="line">		<span class="keyword">var</span> opts *api.DeleteOptions</div><div class="line">		uid := namespace.UID</div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(uid) &gt; <span class="number">0</span> &#123;</div><div class="line">			opts = &amp;api.DeleteOptions&#123;Preconditions: &amp;api.Preconditions&#123;UID: &amp;uid&#125;&#125;</div><div class="line">		&#125;</div><div class="line">		err = kubeClient.Core().Namespaces().Delete(namespace.Name, opts)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; !errors.IsNotFound(err) &#123;</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// there may still be content for us to remove</span></div><div class="line">	groupVersionResources, err := groupVersionResourcesFn()</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//***删除namespace下的资源***//</span></div><div class="line">	estimate, err := deleteAllContent(kubeClient, clientPool, opCache, groupVersionResources, namespace.Name, *namespace.DeletionTimestamp)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> estimate &gt; <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> &amp;contentRemainingError&#123;estimate&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// we have removed content, so mark it finalized by us</span></div><div class="line">	<span class="comment">//***移除namespace的kubernetes标签***//</span></div><div class="line">	result, err := retryOnConflictError(kubeClient, namespace, finalizeNamespaceFunc(finalizerToken))</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="comment">// in normal practice, this should not be possible, but if a deployment is running</span></div><div class="line">		<span class="comment">// two controllers to do namespace deletion that share a common finalizer token it's</span></div><div class="line">		<span class="comment">// possible that a not found could occur since the other controller would have finished the delete.</span></div><div class="line">		<span class="keyword">if</span> errors.IsNotFound(err) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// now check if all finalizers have reported that we delete now</span></div><div class="line">	<span class="comment">//***删除Namespace***//</span></div><div class="line">	<span class="keyword">if</span> finalized(result) &#123;</div><div class="line">		err = kubeClient.Core().Namespaces().Delete(namespace.Name, <span class="literal">nil</span>)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; !errors.IsNotFound(err) &#123;</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>syncNamespace()的逻辑如下：</p>
<ol>
<li>如果Namespace的DeletionTimestamp未设置，则不对该Namespace做任何处理；</li>
<li>如果Namespace不存在，则不做任何处理；</li>
<li>检查kubernetes标签，如果该namespace的kubernetes已经被移除，则直接删除namespace；</li>
<li>删除Namespace下的资源，然后移除Namespace中的kubernetes标签；</li>
<li>检查kubernetes标签，如果不存在，则删除namespace。</li>
</ol>
<p>可以看出，只有Namespace中没有kubernetes标签的情况下才会删除Namespace，而只有该Namespace下所有资源都被清除时，才会移除kubernetes标签。这就是finalizer机制。</p>
<h2 id="deleteAllContent"><a href="#deleteAllContent" class="headerlink" title="deleteAllContent()"></a>deleteAllContent()</h2><p>deleteAllContent()可以删除Namespace下的所有资源，定义在/pkg/controller/namespace/namespace_controller_utils.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// deleteAllContent will use the dynamic client to delete each resource identified in groupVersionResources.</span></div><div class="line"><span class="comment">// It returns an estimate of the time remaining before the remaining resources are deleted.</span></div><div class="line"><span class="comment">// If estimate &gt; 0, not all resources are guaranteed to be gone.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteAllContent</span><span class="params">(</span></span></div><div class="line">	kubeClient clientset.Interface,</div><div class="line">	clientPool dynamic.ClientPool,</div><div class="line">	opCache *operationNotSupportedCache,</div><div class="line">	groupVersionResources []unversioned.GroupVersionResource,</div><div class="line">	namespace <span class="keyword">string</span>,</div><div class="line">	namespaceDeletedAt unversioned.Time,</div><div class="line">) <span class="params">(<span class="keyword">int64</span>, error)</span> &#123;</div><div class="line">	estimate := <span class="keyword">int64</span>(<span class="number">0</span>)</div><div class="line">	glog.V(<span class="number">4</span>).Infof(<span class="string">"namespace controller - deleteAllContent - namespace: %s, gvrs: %v"</span>, namespace, groupVersionResources)</div><div class="line">	<span class="comment">// iterate over each group version, and attempt to delete all of its resources</span></div><div class="line">	<span class="comment">// we sort resources to delete in a priority order that deletes pods LAST</span></div><div class="line">	sort.Sort(sortableGroupVersionResources(groupVersionResources))</div><div class="line">	<span class="comment">//***循环处理每一种namespace下的资源***//</span></div><div class="line">	<span class="keyword">for</span> _, gvr := <span class="keyword">range</span> groupVersionResources &#123;</div><div class="line">		<span class="comment">//***调用deleteAllContentForGroupVersionResource()删除namespace具体资源类***//</span></div><div class="line">		gvrEstimate, err := deleteAllContentForGroupVersionResource(kubeClient, clientPool, opCache, gvr, namespace, namespaceDeletedAt)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> estimate, err</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> gvrEstimate &gt; estimate &#123;</div><div class="line">			estimate = gvrEstimate</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	glog.V(<span class="number">4</span>).Infof(<span class="string">"namespace controller - deleteAllContent - namespace: %s, estimate: %v"</span>, namespace, estimate)</div><div class="line">	<span class="keyword">return</span> estimate, <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteAllContentForGroupVersionResource</span><span class="params">(</span></span></div><div class="line">	kubeClient clientset.Interface,</div><div class="line">	clientPool dynamic.ClientPool,</div><div class="line">	opCache *operationNotSupportedCache,</div><div class="line">	gvr unversioned.GroupVersionResource,</div><div class="line">	namespace <span class="keyword">string</span>,</div><div class="line">	namespaceDeletedAt unversioned.Time,</div><div class="line">) <span class="params">(<span class="keyword">int64</span>, error)</span> &#123;</div><div class="line">	glog.V(<span class="number">5</span>).Infof(<span class="string">"namespace controller - deleteAllContentForGroupVersionResource - namespace: %s, gvr: %v"</span>, namespace, gvr)</div><div class="line"></div><div class="line">	<span class="comment">// estimate how long it will take for the resource to be deleted (needed for objects that support graceful delete)</span></div><div class="line">	estimate, err := estimateGracefulTermination(kubeClient, gvr, namespace, namespaceDeletedAt)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		glog.V(<span class="number">5</span>).Infof(<span class="string">"namespace controller - deleteAllContentForGroupVersionResource - unable to estimate - namespace: %s, gvr: %v, err: %v"</span>, namespace, gvr, err)</div><div class="line">		<span class="keyword">return</span> estimate, err</div><div class="line">	&#125;</div><div class="line">	glog.V(<span class="number">5</span>).Infof(<span class="string">"namespace controller - deleteAllContentForGroupVersionResource - estimate - namespace: %s, gvr: %v, estimate: %v"</span>, namespace, gvr, estimate)</div><div class="line"></div><div class="line">	<span class="comment">// get a client for this group version...</span></div><div class="line">	dynamicClient, err := clientPool.ClientForGroupVersionResource(gvr)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		glog.V(<span class="number">5</span>).Infof(<span class="string">"namespace controller - deleteAllContentForGroupVersionResource - unable to get client - namespace: %s, gvr: %v, err: %v"</span>, namespace, gvr, err)</div><div class="line">		<span class="keyword">return</span> estimate, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// first try to delete the entire collection</span></div><div class="line">	deleteCollectionSupported, err := deleteCollection(dynamicClient, opCache, gvr, namespace)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> estimate, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// delete collection was not supported, so we list and delete each item...</span></div><div class="line">	<span class="keyword">if</span> !deleteCollectionSupported &#123;</div><div class="line">		err = deleteEachItem(dynamicClient, opCache, gvr, namespace)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> estimate, err</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// verify there are no more remaining items</span></div><div class="line">	<span class="comment">// it is not an error condition for there to be remaining items if local estimate is non-zero</span></div><div class="line">	glog.V(<span class="number">5</span>).Infof(<span class="string">"namespace controller - deleteAllContentForGroupVersionResource - checking for no more items in namespace: %s, gvr: %v"</span>, namespace, gvr)</div><div class="line">	unstructuredList, listSupported, err := listCollection(dynamicClient, opCache, gvr, namespace)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		glog.V(<span class="number">5</span>).Infof(<span class="string">"namespace controller - deleteAllContentForGroupVersionResource - error verifying no items in namespace: %s, gvr: %v, err: %v"</span>, namespace, gvr, err)</div><div class="line">		<span class="keyword">return</span> estimate, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> !listSupported &#123;</div><div class="line">		<span class="keyword">return</span> estimate, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	glog.V(<span class="number">5</span>).Infof(<span class="string">"namespace controller - deleteAllContentForGroupVersionResource - items remaining - namespace: %s, gvr: %v, items: %v"</span>, namespace, gvr, <span class="built_in">len</span>(unstructuredList.Items))</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(unstructuredList.Items) != <span class="number">0</span> &amp;&amp; estimate == <span class="keyword">int64</span>(<span class="number">0</span>) &#123;</div><div class="line">		<span class="comment">// if any item has a finalizer, we treat that as a normal condition, and use a default estimation to allow for GC to complete.</span></div><div class="line">		<span class="keyword">for</span> _, item := <span class="keyword">range</span> unstructuredList.Items &#123;</div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(item.GetFinalizers()) &gt; <span class="number">0</span> &#123;</div><div class="line">				glog.V(<span class="number">5</span>).Infof(<span class="string">"namespace controller - deleteAllContentForGroupVersionResource - items remaining with finalizers - namespace: %s, gvr: %v, finalizers: %v"</span>, namespace, gvr, item.GetFinalizers())</div><div class="line">				<span class="keyword">return</span> finalizerEstimateSeconds, <span class="literal">nil</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// nothing reported a finalizer, so something was unexpected as it should have been deleted.</span></div><div class="line">		<span class="keyword">return</span> estimate, fmt.Errorf(<span class="string">"unexpected items still remain in namespace: %s for gvr: %v"</span>, namespace, gvr)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> estimate, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>deleteAllContent()会按资源清空整个Namespace。而Namespace下有多少种资源是通过discoveryClient的ServerPreferredNamespacedResources()获取的，discoveryClient还有待详细研究。</p>
<p>分析完毕。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://fankangbest.github.com/2017/10/26/kube-controller分析(三)-NamespaceController-v1-5-2/" data-id="cjbqdjbau004640qsdv1hgngu" class="article-share-link">分享</a><div class="tags"><a href="/tags/kubernetes/">kubernetes</a><a href="/tags/kubernetes-v1-5-2/">kubernetes-v1.5.2</a></div><div class="post-nav"><a href="/2017/10/29/Docker镜像存储代码分析-imageStore-v1-12-3/" class="pre">Docker镜像存储代码分析-imageStore-v1.12.3</a><a href="/2017/10/25/kubernetes-watcher-demo/" class="next">kubernetes-watcher-demo</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://fankangbest.github.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/GO语言/">GO语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/存储虚拟化/">存储虚拟化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/容器虚拟化/">容器虚拟化</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/containerd-v0-2-4/" style="font-size: 15px;">containerd-v0.2.4</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/docker-v1-12-3/" style="font-size: 15px;">docker-v1.12.3</a> <a href="/tags/GO语言/" style="font-size: 15px;">GO语言</a> <a href="/tags/containerd/" style="font-size: 15px;">containerd</a> <a href="/tags/kubernetes-v1-5-2/" style="font-size: 15px;">kubernetes-v1.5.2</a> <a href="/tags/gRPC/" style="font-size: 15px;">gRPC</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/runc/" style="font-size: 15px;">runc</a> <a href="/tags/runc-v1-0-0-rc2/" style="font-size: 15px;">runc-v1.0.0-rc2</a> <a href="/tags/ceph/" style="font-size: 15px;">ceph</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/12/28/Docker工具包分析-archive-v1-12-3/">Docker工具包分析-archive-v1.12.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/27/Docker命令行分析-cp-v1-12-3/">Docker命令行分析-cp-v1.12.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/26/tar-stream-demo/">tar-stream-demo</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/25/Docker命令分行分析-run-v1-12-3/">Docker命令分行分析-run-v1.12.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/23/kubelet分析(七)-dockerManager(2)-v1-5-2/">kubelet分析(七)-dockerManager(2)-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/23/kubelet分析(七)-dockerManager(1)-v1-5-2/">kubelet分析(七)-dockerManager(1)-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/20/kubelet分析(六)-proberManager-v1-5-2/">kubelet分析(六)-proberManager-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/18/kubelet分析(五)-podManager-v1-5-2/">kubelet分析(五)-podManager-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/17/kubelet分析(四)-statusManager-v1-5-2/">kubelet分析(四)-statusManager-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/17/kubelet分析(三)-volumeManager-v1-5-2/">kubelet分析(三)-volumeManager-v1.5.2</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/fankangbest" title="myGithub" target="_blank">myGithub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">fankangbest.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>