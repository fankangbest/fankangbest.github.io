<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>containerd,containerd-shim和runc的依存关系 | fankangbest</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">containerd,containerd-shim和runc的依存关系</h1><a id="logo" href="/.">fankangbest</a><p class="description">多听，少说，接受每一个人的责难，但是保留自己的最后裁决。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">containerd,containerd-shim和runc的依存关系</h1><div class="post-meta">Nov 24, 2017<span> | </span><span class="category"><a href="/categories/容器虚拟化/">容器虚拟化</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p>我们知道，以现在dockerd的架构，起容器需要有containerd，containerd-shim和容器进程(即容器主进程)三个进程。那么，这三个进程的依存关系如何？本次分析将介绍这方面的内容。<br>需要说明的是，由于不同shell中的内容并不是连贯执行的，所以进程号可能会不一致。</p>
<h2 id="整体关系"><a href="#整体关系" class="headerlink" title="整体关系"></a>整体关系</h2><p>首先，我们来看下containerd，containerd-shim和容器进程的关系：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root      2156  1733  0 13:17 pts/0    00:00:00 ./bin/containerd -l unix:///var/run/docker/libcontainerd/docker-containerd.sock --shim /home/fankang/docker/containerd-0.2.4/src/github.com/docker/containerd/bin/containerd-shim --metrics-interval=0 --start-timeout 2m --state-dir /var/run/docker/libcontainerd/containerd --runtime docker-runc</div><div class="line">root      2198  2156  0 13:45 pts/0    00:00:00 /home/fankang/docker/containerd-0.2.4/src/github.com/docker/containerd/bin/containerd-shim nginx /home/fankang/mycontainer runc</div><div class="line">root      2214  2198  0 13:45 ?        00:00:00 /usr/bin/python /usr/bin/supervisord</div></pre></td></tr></table></figure></p>
<p>可以看出，containerd是containerd-shim的父进程，contaienrd-shim是容器进程的父进程。<br>而杀死containerd进程后，contaienrd-shim和容器进程依然存在，只是containerd进程成孤儿进程后，被1进程接收了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root      2301     1  0 13:50 pts/0    00:00:00 /home/fankang/docker/containerd-0.2.4/src/github.com/docker/containerd/bin/containerd-shim nginx /home/fankang/mycontainer runc</div><div class="line">root      2317  2301  1 13:50 ?        00:00:00 /usr/bin/python /usr/bin/supervisord</div></pre></td></tr></table></figure></p>
<p>所以，为了简化三个进程的关系，我们从下面4种情况来分析：</p>
<ol>
<li>containerd进程存在的情况下，杀死containerd-shim进程；</li>
<li>containerd进程存在的情况下，杀死容器进程；</li>
<li>containerd进程不存在的情况下，杀死containerd-shim进程，然后启动containerd进程；</li>
<li>containerd进程不存在的情况下，杀死容器进程，然后启动containerd进程；</li>
</ol>
<h2 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h2><p>第一种情况：containerd进程存在的情况下，杀死containerd-shim进程<br>containerd运行中，containerd-shim和容器进程如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root      2414  2383  0 14:02 pts/0    00:00:00 /home/fankang/docker/containerd-0.2.4/src/github.com/docker/containerd/bin/containerd-shim nginx /home/fankang/mycontainer runc</div><div class="line">root      2429  2414  1 14:02 ?        00:00:00 /usr/bin/python /usr/bin/supervisord</div></pre></td></tr></table></figure></p>
<p>现在使用<code>kill -9 2414</code>杀死cotnainerd-shim进程。<br>现在可以得出结论：容器进程退出。在containerd运行的情况下，杀死containerd-shim，容器进程会退出。</p>
<p>所以，现在来看下为什么容器进程会退出。<br>之前分析过，创建容器时会调用container的Start()方法，定义在containerd/runtime/container.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *container)</span> <span class="title">Start</span><span class="params">(checkpointPath <span class="keyword">string</span>, s Stdio)</span> <span class="params">(Process, error)</span></span> &#123;</div><div class="line">	<span class="comment">//***processRoot:  /var/run/docker/libcontainerd/containerd/mynginx/init***//</span></div><div class="line">	processRoot := filepath.Join(c.root, c.id, InitProcessID)</div><div class="line">	<span class="keyword">if</span> err := os.Mkdir(processRoot, <span class="number">0755</span>); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//***构建cmd，调用的是containerd-shim***//</span></div><div class="line">	<span class="comment">//***docker-containerd-shim nginx /home/fankang/mycontainer runc***//</span></div><div class="line">	cmd := exec.Command(c.shim,</div><div class="line">		c.id, c.bundle, c.runtime,</div><div class="line">	)</div><div class="line">	cmd.Dir = processRoot</div><div class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</div><div class="line">		Setpgid: <span class="literal">true</span>,</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//***读取bundle目录下的config.json文件***//</span></div><div class="line">	spec, err := c.readSpec()</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//***InitProcessID = "init"***//</span></div><div class="line">	config := &amp;processConfig&#123;</div><div class="line">		checkpoint:  checkpointPath,</div><div class="line">		root:        processRoot,</div><div class="line">		id:          InitProcessID,</div><div class="line">		c:           c,</div><div class="line">		stdio:       s,</div><div class="line">		spec:        spec,</div><div class="line">		processSpec: specs.ProcessSpec(spec.Process),</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//****生成process**//</span></div><div class="line">	p, err := newProcess(config)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//***执行cmd***//</span></div><div class="line">	<span class="keyword">if</span> err := c.createCmd(InitProcessID, cmd, p); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> p, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而Start()方法又会调用createCmd()方法执行命令：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *container)</span> <span class="title">createCmd</span><span class="params">(pid <span class="keyword">string</span>, cmd *exec.Cmd, p *process)</span> <span class="title">error</span></span> &#123;</div><div class="line">	p.cmd = cmd</div><div class="line">	<span class="comment">//***执行cmd***//</span></div><div class="line">	<span class="keyword">if</span> err := cmd.Start(); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">close</span>(p.cmdDoneCh)</div><div class="line">		<span class="keyword">if</span> exErr, ok := err.(*exec.Error); ok &#123;</div><div class="line">			<span class="keyword">if</span> exErr.Err == exec.ErrNotFound || exErr.Err == os.ErrNotExist &#123;</div><div class="line">				<span class="keyword">return</span> fmt.Errorf(<span class="string">"%s not installed on system"</span>, c.shim)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// We need the pid file to have been written to run</span></div><div class="line">	<span class="comment">//***defer中执行***//</span></div><div class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="comment">//***起一个go routine等待shim结束***//</span></div><div class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">			<span class="comment">//***等待cmd执行完成***//</span></div><div class="line">			err := p.cmd.Wait()</div><div class="line">			<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">				p.cmdSuccess = <span class="literal">true</span></div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">//***此处在调用ctr kill时或直接杀死shim进程时，会执行到，表明shim进程退出时所要做的处理***//</span></div><div class="line">			<span class="comment">//***系统中进程的启动时间和内存中记录的时间比较，查看是否为同一process***//</span></div><div class="line">			<span class="comment">//***此处如果是正常退出的话，则linux系统上进程已经不存在，所以linux系统上进程时间为空***//</span></div><div class="line">			<span class="comment">//***如果是异常退出的话，如kill -9 shim进程，则linux系统上进程仍存在，此时same为true***//</span></div><div class="line">			<span class="keyword">if</span> same, err := p.isSameProcess(); same &amp;&amp; p.pid &gt; <span class="number">0</span> &#123;</div><div class="line">				<span class="comment">// The process changed its PR_SET_PDEATHSIG, so force</span></div><div class="line">				<span class="comment">// kill it</span></div><div class="line">				logrus.Infof(<span class="string">"containerd: %s:%s (pid %v) has become an orphan, killing it"</span>, p.container.id, p.id, p.pid)</div><div class="line">				err = unix.Kill(p.pid, syscall.SIGKILL)</div><div class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != syscall.ESRCH &#123;</div><div class="line">					logrus.Errorf(<span class="string">"containerd: unable to SIGKILL %s:%s (pid %v): %v"</span>, p.container.id, p.id, p.pid, err)</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					<span class="keyword">for</span> &#123;</div><div class="line">						err = unix.Kill(p.pid, <span class="number">0</span>)</div><div class="line">						<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">							<span class="keyword">break</span></div><div class="line">						&#125;</div><div class="line">						time.Sleep(<span class="number">5</span> * time.Millisecond)</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="built_in">close</span>(p.cmdDoneCh)</div><div class="line">		&#125;()</div><div class="line">	&#125;()</div><div class="line">	<span class="comment">//***等待进行创建完成***//</span></div><div class="line">	<span class="keyword">if</span> err := c.waitForCreate(p, cmd); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	c.processes[pid] = p</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，createCmd()在启动进程后，在defer中会起一个go routine，如果containerd-shim异常退出，那么cmd.wait()阻塞消除，如果容器进程存在，则执行<code>unix.Kill(p.pid, syscall.SIGKILL)</code>操作杀死容器进程。</p>
<p>所以，containerd存在的情况下，手动杀死containerd-shim进程，容器进程将会被containerd中创建容器时留下的go routine杀死。</p>
<h2 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h2><p>第二种情况：containerd进程存在的情况下，杀死容器进程<br>一方面，在容器进程退出时，containerd-shim也会捕获到信号退出，这将在第四种情况下详细分析。<br>另一方面，容器进程退出，containerd中的monitor会会捕获到该事件，从而触发容器进程退出流程，这是本小节详细分析的内容。<br>之前分析过，monitor会把容器退出事件放到monitor的exits channel中，在containerd/supevisor/monitor_linux.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Monitor)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> events [<span class="number">128</span>]syscall.EpollEvent</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="comment">//***EpollWait()收集在epoll监控的事件中已经发送的事件***//</span></div><div class="line">		n, err := archutils.EpollWait(m.epollFd, events[:], <span class="number">-1</span>)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">if</span> err == syscall.EINTR &#123;</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">			logrus.WithField(<span class="string">"error"</span>, err).Fatal(<span class="string">"containerd: epoll wait"</span>)</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// process events</span></div><div class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</div><div class="line">			fd := <span class="keyword">int</span>(events[i].Fd)</div><div class="line">			m.m.Lock()</div><div class="line">			r := m.receivers[fd]</div><div class="line">			<span class="keyword">switch</span> t := r.(<span class="keyword">type</span>) &#123;</div><div class="line">			<span class="comment">//***process类型***//</span></div><div class="line">			<span class="keyword">case</span> runtime.Process:</div><div class="line">				<span class="keyword">if</span> events[i].Events == syscall.EPOLLHUP &#123;</div><div class="line">					<span class="built_in">delete</span>(m.receivers, fd)</div><div class="line">					<span class="keyword">if</span> err = syscall.EpollCtl(m.epollFd, syscall.EPOLL_CTL_DEL, fd, &amp;syscall.EpollEvent&#123;</div><div class="line">						Events: syscall.EPOLLHUP,</div><div class="line">						Fd:     <span class="keyword">int32</span>(fd),</div><div class="line">					&#125;); err != <span class="literal">nil</span> &#123;</div><div class="line">						logrus.WithField(<span class="string">"error"</span>, err).Error(<span class="string">"containerd: epoll remove fd"</span>)</div><div class="line">					&#125;</div><div class="line">					<span class="keyword">if</span> err := t.Close(); err != <span class="literal">nil</span> &#123;</div><div class="line">						logrus.WithField(<span class="string">"error"</span>, err).Error(<span class="string">"containerd: close process IO"</span>)</div><div class="line">					&#125;</div><div class="line">					EpollFdCounter.Dec(<span class="number">1</span>)</div><div class="line">					<span class="comment">//***放入exits channel中***//</span></div><div class="line">					m.exits &lt;- t</div><div class="line">				&#125;</div><div class="line">			<span class="comment">//***被OOM***//</span></div><div class="line">			<span class="keyword">case</span> runtime.OOM:</div><div class="line">				<span class="comment">// always flush the event fd</span></div><div class="line">				t.Flush()</div><div class="line">				<span class="keyword">if</span> t.Removed() &#123;</div><div class="line">					<span class="built_in">delete</span>(m.receivers, fd)</div><div class="line">					<span class="comment">// epoll will remove the fd from its set after it has been closed</span></div><div class="line">					t.Close()</div><div class="line">					EpollFdCounter.Dec(<span class="number">1</span>)</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					<span class="comment">//***放入到ooms channel中***//</span></div><div class="line">					m.ooms &lt;- t.ContainerID()</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			m.m.Unlock()</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而在containerd的supervisor启动时，会启动eixthandler()，在containerd/supervisor/supervisor.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(stateDir <span class="keyword">string</span>, runtimeName, shimName <span class="keyword">string</span>, runtimeArgs []<span class="keyword">string</span>, timeout time.Duration, retainCount <span class="keyword">int</span>)</span> <span class="params">(*Supervisor, error)</span></span> &#123;</div><div class="line">	startTasks := <span class="built_in">make</span>(<span class="keyword">chan</span> *startTask, <span class="number">10</span>)</div><div class="line">	<span class="keyword">if</span> err := os.MkdirAll(stateDir, <span class="number">0755</span>); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	machine, err := CollectMachineInformation()</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	monitor, err := NewMonitor()</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	s := &amp;Supervisor&#123;</div><div class="line">		stateDir:    stateDir,</div><div class="line">		containers:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*containerInfo),</div><div class="line">		startTasks:  startTasks,</div><div class="line">		machine:     machine,</div><div class="line">		subscribers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">chan</span> Event]<span class="keyword">struct</span>&#123;&#125;),</div><div class="line">		tasks:       <span class="built_in">make</span>(<span class="keyword">chan</span> Task, defaultBufferSize),</div><div class="line">		monitor:     monitor,</div><div class="line">		runtime:     runtimeName,</div><div class="line">		runtimeArgs: runtimeArgs,</div><div class="line">		shim:        shimName,</div><div class="line">		timeout:     timeout,</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//***处理event日志***//</span></div><div class="line">	<span class="keyword">if</span> err := setupEventLog(s, retainCount); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">go</span> s.exitHandler()</div><div class="line">	<span class="keyword">go</span> s.oomHandler()</div><div class="line">	<span class="keyword">if</span> err := s.restore(); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> s, <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Supervisor)</span> <span class="title">exitHandler</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> p := <span class="keyword">range</span> s.monitor.Exits() &#123;</div><div class="line">		e := &amp;ExitTask&#123;</div><div class="line">			Process: p,</div><div class="line">		&#125;</div><div class="line">		s.SendTask(e)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，exitHandler()会消费monitor exits channel中的事件，然后包装成ExitTask，然后发送到supervisor的tasks中以进一步处理。<br>所以，容器进程退出会触发containerd对容器进行exit处理。在exit处理中会调用delete处理，这些就不再细展开。</p>
<p>所以，containerd存在的情况下，杀死容器进程，conainerd-shim主动退出，containerd触发exit事件以清理该容器。</p>
<h2 id="第三种情况"><a href="#第三种情况" class="headerlink" title="第三种情况"></a>第三种情况</h2><p>第三种情况：containerd进程不存在的情况下，杀死containerd-shim进程，然后启动containerd进程<br>现在容器在运行，containerd关闭，进程如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root      2522     1  0 15:33 pts/0    00:00:00 /home/fankang/docker/containerd-0.2.4/src/github.com/docker/containerd/bin/containerd-shim nginx /home/fankang/mycontainer runc</div><div class="line">root      2537  2522  0 15:33 ?        00:00:00 /usr/bin/python /usr/bin/supervisord</div></pre></td></tr></table></figure></p>
<p>现在调用<code>kill -9 2522</code>杀死2522。可以看到容器进程还在，成为孤儿进程，被进程1接收。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root      2537     1  0 15:33 ?        00:00:00 /usr/bin/python /usr/bin/supervisord</div><div class="line">root      2571  2537  0 15:33 ?        00:00:00 /usr/sbin/sshd -D</div></pre></td></tr></table></figure></p>
<p>启动containerd，容器进程消失。</p>
<p>所以containerd在启动时会清理残留的容器进程(对应的containerd-shim不存在)。</p>
<p>那么，这清理工作的流程是怎样的呢？supervisor在启动的时候会调用restore()方法，supervisor的restore()定义在containerd/supervisor/supervisor.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Supervisor)</span> <span class="title">restore</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">	dirs, err := ioutil.ReadDir(s.stateDir)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> _, d := <span class="keyword">range</span> dirs &#123;</div><div class="line">		<span class="keyword">if</span> !d.IsDir() &#123;</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line">		id := d.Name()</div><div class="line">		container, err := runtime.Load(s.stateDir, id, s.shim, s.timeout)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line">		processes, err := container.Processes()</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		ContainersCounter.Inc(<span class="number">1</span>)</div><div class="line">		s.containers[id] = &amp;containerInfo&#123;</div><div class="line">			container: container,</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> err := s.monitor.MonitorOOM(container); err != <span class="literal">nil</span> &amp;&amp; err != runtime.ErrContainerExited &#123;</div><div class="line">			logrus.WithField(<span class="string">"error"</span>, err).Error(<span class="string">"containerd: notify OOM events"</span>)</div><div class="line">		&#125;</div><div class="line">		logrus.WithField(<span class="string">"id"</span>, id).Debug(<span class="string">"containerd: container restored"</span>)</div><div class="line">		<span class="keyword">var</span> exitedProcesses []runtime.Process</div><div class="line">		<span class="keyword">for</span> _, p := <span class="keyword">range</span> processes &#123;</div><div class="line">			<span class="keyword">if</span> p.State() == runtime.Running &#123;</div><div class="line">				<span class="keyword">if</span> err := s.monitorProcess(p); err != <span class="literal">nil</span> &#123;</div><div class="line">					<span class="keyword">return</span> err</div><div class="line">				&#125;</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				exitedProcesses = <span class="built_in">append</span>(exitedProcesses, p)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(exitedProcesses) &gt; <span class="number">0</span> &#123;</div><div class="line">			<span class="comment">// sort processes so that init is fired last because that is how the kernel sends the</span></div><div class="line">			<span class="comment">// exit events</span></div><div class="line">			sortProcesses(exitedProcesses)</div><div class="line">			<span class="keyword">for</span> _, p := <span class="keyword">range</span> exitedProcesses &#123;</div><div class="line">				e := &amp;ExitTask&#123;</div><div class="line">					Process: p,</div><div class="line">				&#125;</div><div class="line">				s.SendTask(e)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>restore()会读取contaienrd主目录下各容器目录，调用runtime.Load()导入容器。如果容器不为runnning，则触发exit事件。<br>所以，现在的关键是看如何导入容器，runtime.Load()定义在containerd/runtime/container.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Load return a new container from the matchin state file on disk.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Load</span><span class="params">(root, id, shimName <span class="keyword">string</span>, timeout time.Duration)</span> <span class="params">(Container, error)</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> s state</div><div class="line">	<span class="comment">//***StateFile = "state.json"***//</span></div><div class="line">	f, err := os.Open(filepath.Join(root, id, StateFile))</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">defer</span> f.Close()</div><div class="line">	<span class="keyword">if</span> err := json.NewDecoder(f).Decode(&amp;s); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	c := &amp;container&#123;</div><div class="line">		root:        root,</div><div class="line">		id:          id,</div><div class="line">		bundle:      s.Bundle,</div><div class="line">		labels:      s.Labels,</div><div class="line">		runtime:     s.Runtime,</div><div class="line">		runtimeArgs: s.RuntimeArgs,</div><div class="line">		shim:        s.Shim,</div><div class="line">		noPivotRoot: s.NoPivotRoot,</div><div class="line">		processes:   <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*process),</div><div class="line">		timeout:     timeout,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> c.shim == <span class="string">""</span> &#123;</div><div class="line">		c.shim = shimName</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	dirs, err := ioutil.ReadDir(filepath.Join(root, id))</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//***一个目录代表一个进程***//</span></div><div class="line">	<span class="keyword">for</span> _, d := <span class="keyword">range</span> dirs &#123;</div><div class="line">		<span class="keyword">if</span> !d.IsDir() &#123;</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line">		pid := d.Name()</div><div class="line">		s, err := readProcessState(filepath.Join(root, id, pid))</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">		&#125;</div><div class="line">		p, err := loadProcess(filepath.Join(root, id, pid), pid, c, s)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			logrus.WithField(<span class="string">"id"</span>, id).WithField(<span class="string">"pid"</span>, pid).Debug(<span class="string">"containerd: error loading process %s"</span>, err)</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line">		c.processes[pid] = p</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> c, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Load()中先通过loadProcess()导入容器目录下的进程。loadProcess()定义在containerd/runtime/process.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***从process.json中还原process***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadProcess</span><span class="params">(root, id <span class="keyword">string</span>, c *container, s *ProcessState)</span> <span class="params">(*process, error)</span></span> &#123;</div><div class="line">	p := &amp;process&#123;</div><div class="line">		root:      root,</div><div class="line">		id:        id,</div><div class="line">		container: c,</div><div class="line">		spec:      s.ProcessSpec,</div><div class="line">		stdio: Stdio&#123;</div><div class="line">			Stdin:  s.Stdin,</div><div class="line">			Stdout: s.Stdout,</div><div class="line">			Stderr: s.Stderr,</div><div class="line">		&#125;,</div><div class="line">		state: Stopped,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	startTime, err := ioutil.ReadFile(filepath.Join(p.root, StartTimeFile))</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; !os.IsNotExist(err) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	p.startTime = <span class="keyword">string</span>(startTime)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> _, err := p.getPidFromFile(); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//***此处调用ExitStatus()，会走到handleSigkilledShim()的p.updateExitStatusFile(128 + uint32(syscall.SIGKILL))***//</span></div><div class="line">	<span class="comment">//***即往exit中写入数据***//</span></div><div class="line">	<span class="comment">//***在exit.go中调用ExitStatus()时，就可以提取exit中的数据***//</span></div><div class="line">	<span class="keyword">if</span> _, err := p.ExitStatus(); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">if</span> err == ErrProcessNotExited &#123;</div><div class="line">			exit, err := getExitPipe(filepath.Join(root, ExitFile))</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">			&#125;</div><div class="line">			p.exitPipe = exit</div><div class="line"></div><div class="line">			control, err := getControlPipe(filepath.Join(root, ControlFile))</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">			&#125;</div><div class="line">			p.controlPipe = control</div><div class="line"></div><div class="line">			p.state = Running</div><div class="line">			<span class="keyword">return</span> p, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> p, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>loadProcess()最重要的调用是p.ExitStatus()，如果出错，则状态为Running。所以琰看ExitStatus()：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***使用exit管道判断shim是否退出***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *process)</span> <span class="title">ExitStatus</span><span class="params">()</span> <span class="params">(rst <span class="keyword">uint32</span>, rerr error)</span></span> &#123;</div><div class="line">	data, err := ioutil.ReadFile(filepath.Join(p.root, ExitStatusFile))</div><div class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">if</span> rerr != <span class="literal">nil</span> &#123;</div><div class="line">			rst, rerr = p.handleSigkilledShim(rst, rerr)</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">if</span> os.IsNotExist(err) &#123;</div><div class="line">			<span class="keyword">return</span> UnknownStatus, ErrProcessNotExited</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> UnknownStatus, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> UnknownStatus, ErrProcessNotExited</div><div class="line">	&#125;</div><div class="line">	p.stateLock.Lock()</div><div class="line">	p.state = Stopped</div><div class="line">	p.stateLock.Unlock()</div><div class="line"></div><div class="line">	i, err := strconv.ParseUint(<span class="keyword">string</span>(data), <span class="number">10</span>, <span class="number">32</span>)</div><div class="line">	<span class="keyword">return</span> <span class="keyword">uint32</span>(i), err</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ExitStatus()会去读exit pipe。此时exit中没有数据，所以会出错。这里的ExitStatus()参数很特别，rerr先获取ExitStatus()主流程的错误，然后在defer中把rerr交给handleSigkilledShim()处理，最后把handleSigkilledShim()的结果错误作为rerr返回。现在流程会转移到handleSigkilledShim()：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *process)</span> <span class="title">handleSigkilledShim</span><span class="params">(rst <span class="keyword">uint32</span>, rerr error)</span> <span class="params">(<span class="keyword">uint32</span>, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> p.cmd == <span class="literal">nil</span> || p.cmd.Process == <span class="literal">nil</span> </div><div class="line">		<span class="comment">//***此处向容器进程发送0信号***//</span></div><div class="line">		e := unix.Kill(p.pid, <span class="number">0</span>)</div><div class="line">		<span class="comment">//***第二次执行的时候，容器进程已经不存在，ESRCH表示参数 pid 所指定的进程或进程组不存在***//</span></div><div class="line">		<span class="keyword">if</span> e == syscall.ESRCH &#123;</div><div class="line">			logrus.Warnf(<span class="string">"containerd: %s:%s (pid %d) does not exist"</span>, p.container.id, p.id, p.pid)</div><div class="line">			<span class="comment">// The process died while containerd was down (probably of</span></div><div class="line">			<span class="comment">// SIGKILL, but no way to be sure)</span></div><div class="line">			<span class="keyword">return</span> p.updateExitStatusFile(UnknownStatus)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// If it's not the same process, just mark it stopped and set</span></div><div class="line">		<span class="comment">// the status to the UnknownStatus value (i.e. 255)</span></div><div class="line">		<span class="keyword">if</span> same, err := p.isSameProcess(); !same &#123;</div><div class="line">			logrus.Warnf(<span class="string">"containerd: %s:%s (pid %d) is not the same process anymore (%v)"</span>, p.container.id, p.id, p.pid, err)</div><div class="line">			<span class="comment">// Create the file so we get the exit event generated once monitor kicks in</span></div><div class="line">			<span class="comment">// without having to go through all this process again</span></div><div class="line">			<span class="keyword">return</span> p.updateExitStatusFile(UnknownStatus)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		ppid, err := readProcStatField(p.pid, <span class="number">4</span>)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> rst, fmt.Errorf(<span class="string">"could not check process ppid: %v (%v)"</span>, err, rerr)</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//***容器进程为1，则表明容器的守护进程shim意外退出***//</span></div><div class="line">		<span class="keyword">if</span> ppid == <span class="string">"1"</span> &#123;</div><div class="line">			logrus.Warnf(<span class="string">"containerd: %s:%s shim died, killing associated process"</span>, p.container.id, p.id)</div><div class="line">			<span class="comment">//***真正杀死容器进程的地方***//</span></div><div class="line">			unix.Kill(p.pid, syscall.SIGKILL)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != syscall.ESRCH &#123;</div><div class="line">				<span class="keyword">return</span> UnknownStatus, fmt.Errorf(<span class="string">"containerd: unable to SIGKILL %s:%s (pid %v): %v"</span>, p.container.id, p.id, p.pid, err)</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">// wait for the process to die</span></div><div class="line">			<span class="keyword">for</span> &#123;</div><div class="line">				e := unix.Kill(p.pid, <span class="number">0</span>)</div><div class="line">				<span class="keyword">if</span> e == syscall.ESRCH &#123;</div><div class="line">					<span class="keyword">break</span></div><div class="line">				&#125;</div><div class="line">				time.Sleep(<span class="number">5</span> * time.Millisecond)</div><div class="line">			&#125;</div><div class="line">			<span class="comment">// Create the file so we get the exit event generated once monitor kicks in</span></div><div class="line">			<span class="comment">// without having to go through all this process again</span></div><div class="line">			<span class="keyword">return</span> p.updateExitStatusFile(<span class="number">128</span> + <span class="keyword">uint32</span>(syscall.SIGKILL))</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> rst, rerr</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Possible that the shim was SIGKILLED</span></div><div class="line">	e := unix.Kill(p.cmd.Process.Pid, <span class="number">0</span>)</div><div class="line">	<span class="keyword">if</span> e != syscall.ESRCH &#123;</div><div class="line">		<span class="keyword">return</span> rst, rerr</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Ensure we got the shim ProcessState</span></div><div class="line">	&lt;-p.cmdDoneCh</div><div class="line"></div><div class="line">	shimStatus := p.cmd.ProcessState.Sys().(syscall.WaitStatus)</div><div class="line">	<span class="keyword">if</span> shimStatus.Signaled() &amp;&amp; shimStatus.Signal() == syscall.SIGKILL &#123;</div><div class="line">		logrus.Debugf(<span class="string">"containerd: ExitStatus(container: %s, process: %s): shim was SIGKILL'ed reaping its child with pid %d"</span>, p.container.id, p.id, p.pid)</div><div class="line"></div><div class="line">		rerr = <span class="literal">nil</span></div><div class="line">		rst = <span class="number">128</span> + <span class="keyword">uint32</span>(shimStatus.Signal())</div><div class="line"></div><div class="line">		p.stateLock.Lock()</div><div class="line">		p.state = Stopped</div><div class="line">		p.stateLock.Unlock()</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> rst, rerr</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>handleSigkilledShim()的<code>if p.cmd == nil || p.cmd.Process == nil</code>流程如下：</p>
<ol>
<li>如果容器进程不存在，则返回；</li>
<li>如果容器进程发生改变，则交由monitor处理，返回；</li>
<li>如果容器进程的父进程为1，则表明shim退出，杀死容器进程，并调用updateExitStatusFile()把内容写到exit，返回；</li>
<li>返回。</li>
</ol>
<p>现在，按我们分析的流程，handleSigkilledShim()将运行到步骤3。由于ExitStatus()的rerr接收了handleSigkilledShim()的返回值，所以rerr为nil，所以process的状态不为running。</p>
<p>所以supervisor的restore()会对该容器作exit操作。</p>
<p>exit操作中也会调用ExitStatus()，但此时exit中是有内容的；也会走到handleSigkilledShim()流程，但会在步骤1就返回，因为容器进程在之前的流程中已经被删除。</p>
<p>如果容器中containerd-shim和容器进程都存在，则从步骤4返回。</p>
<h2 id="第四种情况"><a href="#第四种情况" class="headerlink" title="第四种情况"></a>第四种情况</h2><p>第四种情况：containerd进程不存在的情况下，杀死容器进程，然后启动containerd进程<br>杀死容器进程，containerd-shim进程主动退出。containerd在restore()中对该容器做exit操作。</p>
<p>这时提供一个demo，来看下go语言使用exec包启动进程的方法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span>  (</div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"os/signal"</span></div><div class="line">	<span class="string">"os/exec"</span></div><div class="line">	<span class="string">"syscall"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	signals := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">2048</span>)</div><div class="line">	signal.Notify(signals)</div><div class="line">	cmd1 := exec.Command(<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, <span class="string">"sleep 50"</span>)</div><div class="line">	cmd1.SysProcAttr = &amp;syscall.SysProcAttr&#123;Setpgid: <span class="literal">true</span>&#125;</div><div class="line">	cmd1.Start()</div><div class="line">	cmd2 := exec.Command(<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, <span class="string">"sleep 50"</span>)</div><div class="line">	cmd2.SysProcAttr = &amp;syscall.SysProcAttr&#123;Setpgid: <span class="literal">true</span>&#125;</div><div class="line">        cmd2.Start()</div><div class="line">	<span class="keyword">select</span> &#123;</div><div class="line">	<span class="keyword">case</span> &lt;-signals:</div><div class="line">		syscall.Kill(-cmd1.Process.Pid, syscall.SIGKILL)</div><div class="line">		syscall.Kill(-cmd2.Process.Pid, syscall.SIGKILL)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译执行的结果如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root      5838  1733  0 17:16 pts/0    00:00:00 ./test</div><div class="line">root      5843  5838  0 17:16 pts/0    00:00:00 /bin/sh -c sleep 50</div><div class="line">root      5844  5838  0 17:16 pts/0    00:00:00 /bin/sh -c sleep 50</div></pre></td></tr></table></figure></p>
<p>执行<code>kill 5843</code>后，所有进程都不存在。<br>所以，在Go中，默认子进程的退出会引起父进程的退出。</p>
<p>分析完毕。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://fankangbest.github.com/2017/11/24/containerd-containerd-shim和runc的依存关系/" data-id="cjb7l1zgm002ttkqs4rkudpbi" class="article-share-link">分享</a><div class="tags"><a href="/tags/containerd/">containerd</a><a href="/tags/containerd-v0-2-4/">containerd-v0.2.4</a></div><div class="post-nav"><a href="/2017/11/26/Docker-reexec机制分析-v1-12-3/" class="pre">Docker-reexec机制分析-v1.12.3</a><a href="/2017/11/22/runc源码分析(一)-create和start流程-v1-0-0-rc2/" class="next">runc源码分析(一)-create和start流程-v1.0.0-rc2</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://fankangbest.github.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/GO语言/">GO语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/存储虚拟化/">存储虚拟化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/容器虚拟化/">容器虚拟化</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/containerd-v0-2-4/" style="font-size: 15px;">containerd-v0.2.4</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/docker-v1-12-3/" style="font-size: 15px;">docker-v1.12.3</a> <a href="/tags/GO语言/" style="font-size: 15px;">GO语言</a> <a href="/tags/containerd/" style="font-size: 15px;">containerd</a> <a href="/tags/kubernetes-v1-5-2/" style="font-size: 15px;">kubernetes-v1.5.2</a> <a href="/tags/gRPC/" style="font-size: 15px;">gRPC</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/runc/" style="font-size: 15px;">runc</a> <a href="/tags/runc-v1-0-0-rc2/" style="font-size: 15px;">runc-v1.0.0-rc2</a> <a href="/tags/ceph/" style="font-size: 15px;">ceph</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/12/15/storage解读(六)-strategy-v1-5-2/">storage解读(六)-strategy-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/14/kubernetes-listwatch机制-v1-5-2/">kubernetes-listwatch机制-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/09/kubernetes-添加controller-demo-v1-5-2/">kubernetes-添加controller-demo-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/09/kubernetes-添加资源-demo-v1-5-2/">kubernetes-添加资源-demo-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/04/libnetwork源码分析(二)-network-v1-12-3/">libnetwork源码分析(二)-network-v1-12-3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/03/libnetwork源码分析(一)-controller(5)-v1-12-3/">libnetwork源码分析(一)-controller(5)-v1-12-3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/03/libnetwork源码分析(一)-controller(4)-v1-12-3/">libnetwork源码分析(一)-controller(4)-v1-12-3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/03/libnetwork源码分析(一)-controller(3)-v1-12-3/">libnetwork源码分析(一)-controller(3)-v1-12-3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/02/libnetwork源码分析(一)-controller(2)-v1-12-3/">libnetwork源码分析(一)-controller(2)-v1.12.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/02/libnetwork源码分析(一)-controller(1)-v1-12-3/">libnetwork源码分析(一)-controller(1)-v1.12.3</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/fankangbest" title="myGithub" target="_blank">myGithub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">fankangbest.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>