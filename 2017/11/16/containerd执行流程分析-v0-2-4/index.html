<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>containerd执行流程分析-v0.2.4 | fankangbest</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">containerd执行流程分析-v0.2.4</h1><a id="logo" href="/.">fankangbest</a><p class="description">多听，少说，接受每一个人的责难，但是保留自己的最后裁决。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">containerd执行流程分析-v0.2.4</h1><div class="post-meta">Nov 16, 2017<span> | </span><span class="category"><a href="/categories/容器虚拟化/">容器虚拟化</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><p>containerd的main()函数定义在/containerd/main.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	logrus.SetFormatter(&amp;logrus.TextFormatter&#123;TimestampFormat: time.RFC3339Nano&#125;)</div><div class="line">	app := cli.NewApp()</div><div class="line">	app.Name = <span class="string">"containerd"</span></div><div class="line">	<span class="keyword">if</span> containerd.GitCommit != <span class="string">""</span> &#123;</div><div class="line">		app.Version = fmt.Sprintf(<span class="string">"%s commit: %s"</span>, containerd.Version, containerd.GitCommit)</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		app.Version = containerd.Version</div><div class="line">	&#125;</div><div class="line">	app.Usage = usage</div><div class="line">	app.Flags = daemonFlags</div><div class="line">	app.Before = <span class="function"><span class="keyword">func</span><span class="params">(context *cli.Context)</span> <span class="title">error</span></span> &#123;</div><div class="line">		setupDumpStacksTrap()</div><div class="line">		<span class="keyword">if</span> context.GlobalBool(<span class="string">"debug"</span>) &#123;</div><div class="line">			logrus.SetLevel(logrus.DebugLevel)</div><div class="line">			<span class="keyword">if</span> context.GlobalDuration(<span class="string">"metrics-interval"</span>) &gt; <span class="number">0</span> &#123;</div><div class="line">				<span class="keyword">if</span> err := debugMetrics(context.GlobalDuration(<span class="string">"metrics-interval"</span>), context.GlobalString(<span class="string">"graphite-address"</span>)); err != <span class="literal">nil</span> &#123;</div><div class="line">					<span class="keyword">return</span> err</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> p := context.GlobalString(<span class="string">"pprof-address"</span>); <span class="built_in">len</span>(p) &gt; <span class="number">0</span> &#123;</div><div class="line">			pprof.Enable(p)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> err := checkLimits(); err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	app.Action = <span class="function"><span class="keyword">func</span><span class="params">(context *cli.Context)</span></span> &#123;</div><div class="line">		<span class="keyword">if</span> err := daemon(context); err != <span class="literal">nil</span> &#123;</div><div class="line">			logrus.Fatal(err)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> err := app.Run(os.Args); err != <span class="literal">nil</span> &#123;</div><div class="line">		logrus.Fatal(err)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>containerd使用的是”github.com/codegangsta/cli”包，该包的用法如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	app := cli.NewApp()</div><div class="line">	app.Name = <span class="string">"greet"</span></div><div class="line">	app.Usage = <span class="string">"say a greeting"</span></div><div class="line">	app.Action = <span class="function"><span class="keyword">func</span><span class="params">(c *cli.Context)</span></span> &#123;</div><div class="line">		<span class="built_in">println</span>(<span class="string">"Greetings"</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	app.Run(os.Args)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以使用cli.Context把命令行的参数传给整个程序。</p>
<p>可以从main()函数看出，containerd的启动核心是daemon(context)。所以我们来看下daemon()函数，daemon()函数同样定义在main.go()中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">daemon</span><span class="params">(context *cli.Context)</span> <span class="title">error</span></span> &#123;</div><div class="line">	s := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">2048</span>)</div><div class="line">	<span class="comment">//***第一个参数表示接收信号的管道, 第二个及后面的参数表示设置要监听的信号，如果不设置表示监听所有的信号***//</span></div><div class="line">	signal.Notify(s, syscall.SIGTERM, syscall.SIGINT)</div><div class="line">	<span class="comment">//***生成supervisor***//</span></div><div class="line">	sv, err := supervisor.New(</div><div class="line">		context.String(<span class="string">"state-dir"</span>),</div><div class="line">		context.String(<span class="string">"runtime"</span>),</div><div class="line">		context.String(<span class="string">"shim"</span>),</div><div class="line">		context.StringSlice(<span class="string">"runtime-args"</span>),</div><div class="line">		context.Duration(<span class="string">"start-timeout"</span>),</div><div class="line">		context.Int(<span class="string">"retain-count"</span>))</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	wg := &amp;sync.WaitGroup&#123;&#125;</div><div class="line">	<span class="comment">//***启动10个worker***//</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</div><div class="line">		wg.Add(<span class="number">1</span>)</div><div class="line">		w := supervisor.NewWorker(sv, wg)</div><div class="line">		<span class="keyword">go</span> w.Start()</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//***启动supervisor***//</span></div><div class="line">	<span class="keyword">if</span> err := sv.Start(); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// Split the listen string of the form proto://addr</span></div><div class="line">	listenSpec := context.String(<span class="string">"listen"</span>)</div><div class="line">	listenParts := strings.SplitN(listenSpec, <span class="string">"://"</span>, <span class="number">2</span>)</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(listenParts) != <span class="number">2</span> &#123;</div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"bad listen address format %s, expected proto://address"</span>, listenSpec)</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//***启动gRPC server***//</span></div><div class="line">	server, err := startServer(listenParts[<span class="number">0</span>], listenParts[<span class="number">1</span>], sv)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//***处理信号***//</span></div><div class="line">	<span class="keyword">for</span> ss := <span class="keyword">range</span> s &#123;</div><div class="line">		<span class="keyword">switch</span> ss &#123;</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			logrus.Infof(<span class="string">"stopping containerd after receiving %s"</span>, ss)</div><div class="line">			server.Stop()</div><div class="line">			os.Exit(<span class="number">0</span>)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在daemon()中，主要完成以下几件事情：</p>
<ol>
<li>启动gRPCServer；</li>
<li>生成并启动supervisor；</li>
<li>生成并启动10个worker。</li>
</ol>
<p>我们来先看gRPCServer。</p>
<h2 id="启动gRPCServer"><a href="#启动gRPCServer" class="headerlink" title="启动gRPCServer"></a>启动gRPCServer</h2><p>daemon()使用下面代码启动gRPCServer:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">server, err := startServer(listenParts[<span class="number">0</span>], listenParts[<span class="number">1</span>], sv)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">	<span class="keyword">return</span> err</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>来看startServer()函数，定义在/main.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***启动gRPC server***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">startServer</span><span class="params">(protocol, address <span class="keyword">string</span>, sv *supervisor.Supervisor)</span> <span class="params">(*grpc.Server, error)</span></span> &#123;</div><div class="line">	<span class="comment">// <span class="doctag">TODO:</span> We should use TLS.</span></div><div class="line">	<span class="comment">// <span class="doctag">TODO:</span> Add an option for the SocketGroup.</span></div><div class="line">	<span class="comment">//***1 生成socket***//</span></div><div class="line">	sockets, err := listeners.Init(protocol, address, <span class="string">""</span>, <span class="literal">nil</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(sockets) != <span class="number">1</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"incorrect number of listeners"</span>)</div><div class="line">	&#125;</div><div class="line">	l := sockets[<span class="number">0</span>]</div><div class="line">	<span class="comment">//***2 生成gRPC server***//</span></div><div class="line">	s := grpc.NewServer()</div><div class="line">	<span class="comment">//***3 注册消息处理结构体***//</span></div><div class="line">	types.RegisterAPIServer(s, server.NewServer(sv))</div><div class="line">	healthServer := health.NewHealthServer()</div><div class="line">	grpc_health_v1.RegisterHealthServer(s, healthServer)</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		logrus.Debugf(<span class="string">"containerd: grpc api on %s"</span>, address)</div><div class="line">		<span class="comment">//***4 监听***//</span></div><div class="line">		<span class="keyword">if</span> err := s.Serve(l); err != <span class="literal">nil</span> &#123;</div><div class="line">			logrus.WithField(<span class="string">"error"</span>, err).Fatal(<span class="string">"containerd: serve grpc"</span>)</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">return</span> s, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>启动gRPCServer主要有以下几个步骤：</p>
<ol>
<li>生成socket;</li>
<li>生成gRPC server;</li>
<li>注册消息处理结构体；</li>
<li>启动gRPCServer，监听。</li>
</ol>
<p>关于gRPC的具体用法，见”gRPC-demo”。</p>
<p>gRPCServer的消息处理结构体定义在/api/grpc/server/server.go中，可以使用NewServer()获取：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NewServer returns grpc server instance</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(sv *supervisor.Supervisor)</span> <span class="title">types</span>.<span class="title">APIServer</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> &amp;apiServer&#123;</div><div class="line">		sv: sv,</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line">在apiserver结构体中，定义有各处理方法，如CreateContainer(), AddProcess(), Signal(), State(), Stats()等。这些将在以后分析。</div><div class="line"></div><div class="line">## supervisor</div><div class="line">supervisor是containerd的核心，处理系统中的各种task，及记录着并监视着系统中每个container。supervisor定义在/supervisor/supervisor.go中：</div><div class="line">`<span class="string">``</span> Go</div><div class="line"><span class="comment">// Supervisor represents a container supervisor</span></div><div class="line"><span class="keyword">type</span> Supervisor <span class="keyword">struct</span> &#123;</div><div class="line">	<span class="comment">// stateDir is the directory on the system to store container runtime state information.</span></div><div class="line">	stateDir <span class="keyword">string</span></div><div class="line">	<span class="comment">// name of the OCI compatible runtime used to execute containers</span></div><div class="line">	runtime     <span class="keyword">string</span></div><div class="line">	runtimeArgs []<span class="keyword">string</span></div><div class="line">	shim        <span class="keyword">string</span></div><div class="line">	containers  <span class="keyword">map</span>[<span class="keyword">string</span>]*containerInfo</div><div class="line">	startTasks  <span class="keyword">chan</span> *startTask</div><div class="line">	<span class="comment">// we need a lock around the subscribers map only because additions and deletions from</span></div><div class="line">	<span class="comment">// the map are via the API so we cannot really control the concurrency</span></div><div class="line">	subscriberLock sync.RWMutex</div><div class="line">	subscribers    <span class="keyword">map</span>[<span class="keyword">chan</span> Event]<span class="keyword">struct</span>&#123;&#125;</div><div class="line">	machine        Machine</div><div class="line">	tasks          <span class="keyword">chan</span> Task</div><div class="line">	monitor        *Monitor</div><div class="line">	eventLog       []Event</div><div class="line">	eventLock      sync.Mutex</div><div class="line">	timeout        time.Duration</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li>stateDir: containerd的工作目录，如/var/run/docker/libcontainerd/containerd；</li>
<li>runtime: 一般为runc；</li>
<li>shim: containerd-shim路径，shim为containerd和runtime之间的桥梁；</li>
<li>containers: 系统中的containers，key为id；</li>
<li>startTasks: startTask的channel，worker会自动处理该channel中的startTask；</li>
<li>subscribers: 管理event处理者，每个event处理者传进来的是一个channel，通过notifySubscribers()方法分发事件；</li>
<li>machine: 物理机相关信息；</li>
<li>tasks：task的channel；</li>
<li>monitor: 容器进程监视器；</li>
<li>eventLog: 记录系统中的event；</li>
</ul>
<p>可以通过New()生成一个新的supervisor：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// New returns an initialized Process supervisor.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(stateDir <span class="keyword">string</span>, runtimeName, shimName <span class="keyword">string</span>, runtimeArgs []<span class="keyword">string</span>, timeout time.Duration, retainCount <span class="keyword">int</span>)</span> <span class="params">(*Supervisor, error)</span></span> &#123;</div><div class="line">	startTasks := <span class="built_in">make</span>(<span class="keyword">chan</span> *startTask, <span class="number">10</span>)</div><div class="line">	<span class="keyword">if</span> err := os.MkdirAll(stateDir, <span class="number">0755</span>); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	machine, err := CollectMachineInformation()</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	monitor, err := NewMonitor()</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	s := &amp;Supervisor&#123;</div><div class="line">		stateDir:    stateDir,</div><div class="line">		containers:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*containerInfo),</div><div class="line">		startTasks:  startTasks,</div><div class="line">		machine:     machine,</div><div class="line">		subscribers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">chan</span> Event]<span class="keyword">struct</span>&#123;&#125;),</div><div class="line">		tasks:       <span class="built_in">make</span>(<span class="keyword">chan</span> Task, defaultBufferSize),</div><div class="line">		monitor:     monitor,</div><div class="line">		runtime:     runtimeName,</div><div class="line">		runtimeArgs: runtimeArgs,</div><div class="line">		shim:        shimName,</div><div class="line">		timeout:     timeout,</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//***处理event日志***//</span></div><div class="line">	<span class="keyword">if</span> err := setupEventLog(s, retainCount); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">go</span> s.exitHandler()</div><div class="line">	<span class="keyword">go</span> s.oomHandler()</div><div class="line">	<span class="keyword">if</span> err := s.restore(); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> s, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在New()函数中，会生成supervisor的monitor等，并启动exitHandler()及oomHandler()分别对被挂起的进程及被oom容器的处理。monitor会监控被挂起的容器进程及被oom的容器。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***处理被挂起的process***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Supervisor)</span> <span class="title">exitHandler</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> p := <span class="keyword">range</span> s.monitor.Exits() &#123;</div><div class="line">		e := &amp;ExitTask&#123;</div><div class="line">			Process: p,</div><div class="line">		&#125;</div><div class="line">		s.SendTask(e)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//***处理已经oom的process***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Supervisor)</span> <span class="title">oomHandler</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> id := <span class="keyword">range</span> s.monitor.OOMs() &#123;</div><div class="line">		e := &amp;OOMTask&#123;</div><div class="line">			ID: id,</div><div class="line">		&#125;</div><div class="line">		s.SendTask(e)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>supervisor通过Start()方法启动，Start()定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***处理tasks channel中的task***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Supervisor)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">	logrus.WithFields(logrus.Fields&#123;</div><div class="line">		<span class="string">"stateDir"</span>:    s.stateDir,</div><div class="line">		<span class="string">"runtime"</span>:     s.runtime,</div><div class="line">		<span class="string">"runtimeArgs"</span>: s.runtimeArgs,</div><div class="line">		<span class="string">"memory"</span>:      s.machine.Memory,</div><div class="line">		<span class="string">"cpus"</span>:        s.machine.Cpus,</div><div class="line">	&#125;).Debug(<span class="string">"containerd: supervisor running"</span>)</div><div class="line">	<span class="comment">//***调用handleTask()处理tasks channel中的task***//</span></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> s.tasks &#123;</div><div class="line">			s.handleTask(i)</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Start()中，会启动一个goroutine调用handleTask()方法处理tasks channel中的task。所以，只要把task放到supervisor的tasks channel中，supervisor就会处理该task。</p>
<p>handleTask()方法定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Supervisor)</span> <span class="title">handleTask</span><span class="params">(i Task)</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> err error</div><div class="line">	<span class="keyword">switch</span> t := i.(<span class="keyword">type</span>) &#123;</div><div class="line">	<span class="keyword">case</span> *AddProcessTask:</div><div class="line">		err = s.addProcess(t)</div><div class="line">	<span class="keyword">case</span> *CreateCheckpointTask:</div><div class="line">		err = s.createCheckpoint(t)</div><div class="line">	<span class="keyword">case</span> *DeleteCheckpointTask:</div><div class="line">		err = s.deleteCheckpoint(t)</div><div class="line">	<span class="comment">//***如果类型为StartTask，那么调用Start()处理task***//</span></div><div class="line">	<span class="comment">//***start()定义在create.go中***//</span></div><div class="line">	<span class="keyword">case</span> *StartTask:</div><div class="line">		err = s.start(t)</div><div class="line">	<span class="comment">//***如果类型为DeleteTask，那么调用delete()处理task***//</span></div><div class="line">	<span class="keyword">case</span> *DeleteTask:</div><div class="line">		err = s.<span class="built_in">delete</span>(t)</div><div class="line">	<span class="keyword">case</span> *ExitTask:</div><div class="line">		err = s.exit(t)</div><div class="line">	<span class="keyword">case</span> *GetContainersTask:</div><div class="line">		err = s.getContainers(t)</div><div class="line">	<span class="keyword">case</span> *SignalTask:</div><div class="line">		err = s.signal(t)</div><div class="line">	<span class="keyword">case</span> *StatsTask:</div><div class="line">		err = s.stats(t)</div><div class="line">	<span class="keyword">case</span> *UpdateTask:</div><div class="line">		err = s.updateContainer(t)</div><div class="line">	<span class="keyword">case</span> *UpdateProcessTask:</div><div class="line">		err = s.updateProcess(t)</div><div class="line">	<span class="keyword">case</span> *OOMTask:</div><div class="line">		err = s.oom(t)</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		err = ErrUnknownTask</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> err != errDeferredResponse &#123;</div><div class="line">		i.ErrorCh() &lt;- err</div><div class="line">		<span class="built_in">close</span>(i.ErrorCh())</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，handleTask()会依据task的类型来调用不同的处理函数。这里以StartTask来举例。</p>
<h2 id="StartTask"><a href="#StartTask" class="headerlink" title="StartTask"></a>StartTask</h2><p>StartTask定义在/supervisor/create.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***StarkTask***//</span></div><div class="line"><span class="keyword">type</span> StartTask <span class="keyword">struct</span> &#123;</div><div class="line">	baseTask</div><div class="line">	ID            <span class="keyword">string</span></div><div class="line">	BundlePath    <span class="keyword">string</span></div><div class="line">	Stdout        <span class="keyword">string</span></div><div class="line">	Stderr        <span class="keyword">string</span></div><div class="line">	Stdin         <span class="keyword">string</span></div><div class="line">	StartResponse <span class="keyword">chan</span> StartResponse</div><div class="line">	Labels        []<span class="keyword">string</span></div><div class="line">	NoPivotRoot   <span class="keyword">bool</span></div><div class="line">	Checkpoint    *runtime.Checkpoint</div><div class="line">	CheckpointDir <span class="keyword">string</span></div><div class="line">	Runtime       <span class="keyword">string</span></div><div class="line">	RuntimeArgs   []<span class="keyword">string</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其对应的处理函数为同文件中start()方法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***start()可以处理StarkTask***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Supervisor)</span> <span class="title">start</span><span class="params">(t *StartTask)</span> <span class="title">error</span></span> &#123;</div><div class="line">	start := time.Now()</div><div class="line">	rt := s.runtime</div><div class="line">	rtArgs := s.runtimeArgs</div><div class="line">	<span class="keyword">if</span> t.Runtime != <span class="string">""</span> &#123;</div><div class="line">		rt = t.Runtime</div><div class="line">		rtArgs = t.RuntimeArgs</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//***生成container***//</span></div><div class="line">	container, err := runtime.New(runtime.ContainerOpts&#123;</div><div class="line">		Root:        s.stateDir,</div><div class="line">		ID:          t.ID,</div><div class="line">		Bundle:      t.BundlePath,</div><div class="line">		Runtime:     rt,</div><div class="line">		RuntimeArgs: rtArgs,</div><div class="line">		Shim:        s.shim,</div><div class="line">		Labels:      t.Labels,</div><div class="line">		NoPivotRoot: t.NoPivotRoot,</div><div class="line">		Timeout:     s.timeout,</div><div class="line">	&#125;)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	s.containers[t.ID] = &amp;containerInfo&#123;</div><div class="line">		container: container,</div><div class="line">	&#125;</div><div class="line">	ContainersCounter.Inc(<span class="number">1</span>)</div><div class="line">	<span class="comment">//***生成startTask***//</span></div><div class="line">	task := &amp;startTask&#123;</div><div class="line">		Err:           t.ErrorCh(),</div><div class="line">		Container:     container,</div><div class="line">		StartResponse: t.StartResponse,</div><div class="line">		Stdin:         t.Stdin,</div><div class="line">		Stdout:        t.Stdout,</div><div class="line">		Stderr:        t.Stderr,</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> t.Checkpoint != <span class="literal">nil</span> &#123;</div><div class="line">		task.CheckpointPath = filepath.Join(t.CheckpointDir, t.Checkpoint.Name)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//***把task处理后，放入startTasks channel***//</span></div><div class="line">	s.startTasks &lt;- task</div><div class="line">	ContainerCreateTimer.UpdateSince(start)</div><div class="line">	<span class="keyword">return</span> errDeferredResponse</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在start()方法中，先生成container，并记录到supervisor的containers中，然后重新组装成startTask(此处startTask，s为小写，定义在/superviso/worker.go中)，放入startTasks channel中供worker处理。</p>
<p>其他task的定义及处理函数与StartTask类似，如DeleteTask定义在/supervisor/delete.go中，处理方法为delete()；ExitTask定义在/supervisor/exit.go中，处理方法为exit()。</p>
<p>那么这些task是什么时候放入supervisor的tasks中的呢？在gRPCServer的处理结构体server的方法中(/api/grpc/server/server.go)。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">//***第一个参数为context，第二个参数为传入的请求，固定用法***//</div><div class="line">func (s *apiServer) CreateContainer(ctx context.Context, c *types.CreateContainerRequest) (*types.CreateContainerResponse, error) &#123;</div><div class="line">	if c.BundlePath == &quot;&quot; &#123;</div><div class="line">		return nil, errors.New(&quot;empty bundle path&quot;)</div><div class="line">	&#125;</div><div class="line">	//***生成StartTask***//</div><div class="line">	e := &amp;supervisor.StartTask&#123;&#125;</div><div class="line">	e.ID = c.Id</div><div class="line">	e.BundlePath = c.BundlePath</div><div class="line">	e.Stdin = c.Stdin</div><div class="line">	e.Stdout = c.Stdout</div><div class="line">	e.Stderr = c.Stderr</div><div class="line">	e.Labels = c.Labels</div><div class="line">	e.NoPivotRoot = c.NoPivotRoot</div><div class="line">	e.Runtime = c.Runtime</div><div class="line">	e.RuntimeArgs = c.RuntimeArgs</div><div class="line">	e.StartResponse = make(chan supervisor.StartResponse, 1)</div><div class="line">	if c.Checkpoint != &quot;&quot; &#123;</div><div class="line">		e.CheckpointDir = c.CheckpointDir</div><div class="line">		e.Checkpoint = &amp;runtime.Checkpoint&#123;</div><div class="line">			Name: c.Checkpoint,</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	//***把StartTask发送到supervisor的tasks channel***//</div><div class="line">	s.sv.SendTask(e)</div><div class="line">	if err := &lt;-e.ErrorCh(); err != nil &#123;</div><div class="line">		return nil, err</div><div class="line">	&#125;</div><div class="line">	r := &lt;-e.StartResponse</div><div class="line">	//***创建容器实例***//</div><div class="line">	apiC, err := createAPIContainer(r.Container, false)</div><div class="line">	if err != nil &#123;</div><div class="line">		return nil, errW</div><div class="line">	&#125;</div><div class="line">	return &amp;types.CreateContainerResponse&#123;</div><div class="line">		Container: apiC,</div><div class="line">	&#125;, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>CreateContainer()在把startTask放入tasks channel后，会一直等待StartResponse的返回。</p>
<h2 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h2><p>在main.go中的daemon()，生成了10个worker:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***启动10个worker***//</span></div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</div><div class="line">	wg.Add(<span class="number">1</span>)</div><div class="line">	w := supervisor.NewWorker(sv, wg)</div><div class="line">	<span class="keyword">go</span> w.Start()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>worker可以处理supervisor的startTasks channel中的startTask。定义在/supervisor/worker.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NewWorker return a new initialized worker</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWorker</span><span class="params">(s *Supervisor, wg *sync.WaitGroup)</span> <span class="title">Worker</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> &amp;worker&#123;</div><div class="line">		s:  s,</div><div class="line">		wg: wg,</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> worker <span class="keyword">struct</span> &#123;</div><div class="line">	wg *sync.WaitGroup</div><div class="line">	s  *Supervisor</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以通过Start()方法启动worker:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Start runs a loop in charge of starting new containers</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">defer</span> w.wg.Done()</div><div class="line">	<span class="comment">//***消费supervisor的startTasks channel中的task，并作处理***//</span></div><div class="line">	<span class="keyword">for</span> t := <span class="keyword">range</span> w.s.startTasks &#123;</div><div class="line">		started := time.Now()</div><div class="line">		<span class="comment">//***启动container，调用Container的Start()***//</span></div><div class="line">		<span class="comment">//***Start()会通过container-shim调用runc create***//</span></div><div class="line">		process, err := t.Container.Start(t.CheckpointPath, runtime.NewStdio(t.Stdin, t.Stdout, t.Stderr))</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			logrus.WithFields(logrus.Fields&#123;</div><div class="line">				<span class="string">"error"</span>: err,</div><div class="line">				<span class="string">"id"</span>:    t.Container.ID(),</div><div class="line">			&#125;).Error(<span class="string">"containerd: start container"</span>)</div><div class="line">			t.Err &lt;- err</div><div class="line">			<span class="comment">//***启动失败则创建DeleteTask，并放入tasks中***//</span></div><div class="line">			evt := &amp;DeleteTask&#123;</div><div class="line">				ID:      t.Container.ID(),</div><div class="line">				NoEvent: <span class="literal">true</span>,</div><div class="line">				Process: process,</div><div class="line">			&#125;</div><div class="line">			w.s.SendTask(evt)</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">//***启动motitor监控容器***//</span></div><div class="line">		<span class="keyword">if</span> err := w.s.monitor.MonitorOOM(t.Container); err != <span class="literal">nil</span> &amp;&amp; err != runtime.ErrContainerExited &#123;</div><div class="line">			<span class="keyword">if</span> process.State() != runtime.Stopped &#123;</div><div class="line">				logrus.WithField(<span class="string">"error"</span>, err).Error(<span class="string">"containerd: notify OOM events"</span>)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> err := w.s.monitorProcess(process); err != <span class="literal">nil</span> &#123;</div><div class="line">			logrus.WithField(<span class="string">"error"</span>, err).Error(<span class="string">"containerd: add process to monitor"</span>)</div><div class="line">			t.Err &lt;- err</div><div class="line">			evt := &amp;DeleteTask&#123;</div><div class="line">				ID:      t.Container.ID(),</div><div class="line">				NoEvent: <span class="literal">true</span>,</div><div class="line">				Process: process,</div><div class="line">			&#125;</div><div class="line">			w.s.SendTask(evt)</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// only call process start if we aren't restoring from a checkpoint</span></div><div class="line">		<span class="comment">// if we have restored from a checkpoint then the process is already started</span></div><div class="line">		<span class="comment">//***调用process.Start()***//</span></div><div class="line">		<span class="comment">//***process.Start()中会调用runc start id命令启动容器***//</span></div><div class="line">		<span class="keyword">if</span> t.CheckpointPath == <span class="string">""</span> &#123;</div><div class="line">			<span class="keyword">if</span> err := process.Start(); err != <span class="literal">nil</span> &#123;</div><div class="line">				logrus.WithField(<span class="string">"error"</span>, err).Error(<span class="string">"containerd: start init process"</span>)</div><div class="line">				t.Err &lt;- err</div><div class="line">				evt := &amp;DeleteTask&#123;</div><div class="line">					ID:      t.Container.ID(),</div><div class="line">					NoEvent: <span class="literal">true</span>,</div><div class="line">					Process: process,</div><div class="line">				&#125;</div><div class="line">				w.s.SendTask(evt)</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		ContainerStartTimer.UpdateSince(started)</div><div class="line">		t.Err &lt;- <span class="literal">nil</span></div><div class="line">		<span class="comment">//***把结果传给StartResponse***//</span></div><div class="line">		t.StartResponse &lt;- StartResponse&#123;</div><div class="line">			Container: t.Container,</div><div class="line">		&#125;</div><div class="line">		w.s.notifySubscribers(Event&#123;</div><div class="line">			Timestamp: time.Now(),</div><div class="line">			ID:        t.Container.ID(),</div><div class="line">			Type:      StateStart,</div><div class="line">		&#125;)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Start()方法会消费supervisor的startTasks channel中的内容。对startTask，主要做以下处理：</p>
<ol>
<li>调用Container.Start()生成容器；</li>
<li>调用monitor.MonitorOOM()和monitorProcess()监控容器进程；</li>
<li>调用process.Start()启动容器；</li>
<li>把处理结果返回给startTask的StartResponse channel。</li>
</ol>
<h2 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h2><p>monitor负责监控容器进程，定义在/supervisor/monitor_linux.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Monitor represents a runtime.Process monitor</span></div><div class="line"><span class="keyword">type</span> Monitor <span class="keyword">struct</span> &#123;</div><div class="line">	m         sync.Mutex</div><div class="line">	receivers <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">interface</span>&#123;&#125;</div><div class="line">	exits     <span class="keyword">chan</span> runtime.Process</div><div class="line">	ooms      <span class="keyword">chan</span> <span class="keyword">string</span></div><div class="line">	epollFd   <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//***monitor可以监视process***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMonitor</span><span class="params">()</span> <span class="params">(*Monitor, error)</span></span> &#123;</div><div class="line">	m := &amp;Monitor&#123;</div><div class="line">		receivers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">interface</span>&#123;&#125;),</div><div class="line">		exits:     <span class="built_in">make</span>(<span class="keyword">chan</span> runtime.Process, <span class="number">1024</span>),</div><div class="line">		ooms:      <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1024</span>),</div><div class="line">	&#125;</div><div class="line">	fd, err := archutils.EpollCreate1(<span class="number">0</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	m.epollFd = fd</div><div class="line">	<span class="keyword">go</span> m.start()</div><div class="line">	<span class="keyword">return</span> m, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li>receivers: 标识被监控的容器进程；</li>
<li>exits: 退出的容器的id；</li>
<li>ooms：被oom的容器的id。</li>
</ul>
<p>monitor可以使用start()方法启动:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Monitor)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> events [<span class="number">128</span>]syscall.EpollEvent</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="comment">//***EpollWait()收集在epoll监控的事件中已经发送的事件***//</span></div><div class="line">		n, err := archutils.EpollWait(m.epollFd, events[:], <span class="number">-1</span>)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">if</span> err == syscall.EINTR &#123;</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">			logrus.WithField(<span class="string">"error"</span>, err).Fatal(<span class="string">"containerd: epoll wait"</span>)</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// process events</span></div><div class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</div><div class="line">			fd := <span class="keyword">int</span>(events[i].Fd)</div><div class="line">			m.m.Lock()</div><div class="line">			r := m.receivers[fd]</div><div class="line">			<span class="keyword">switch</span> t := r.(<span class="keyword">type</span>) &#123;</div><div class="line">			<span class="comment">//***如果是process类型***//</span></div><div class="line">			<span class="keyword">case</span> runtime.Process:</div><div class="line">				<span class="keyword">if</span> events[i].Events == syscall.EPOLLHUP &#123;</div><div class="line">					<span class="built_in">delete</span>(m.receivers, fd)</div><div class="line">					<span class="keyword">if</span> err = syscall.EpollCtl(m.epollFd, syscall.EPOLL_CTL_DEL, fd, &amp;syscall.EpollEvent&#123;</div><div class="line">						Events: syscall.EPOLLHUP,</div><div class="line">						Fd:     <span class="keyword">int32</span>(fd),</div><div class="line">					&#125;); err != <span class="literal">nil</span> &#123;</div><div class="line">						logrus.WithField(<span class="string">"error"</span>, err).Error(<span class="string">"containerd: epoll remove fd"</span>)</div><div class="line">					&#125;</div><div class="line">					<span class="keyword">if</span> err := t.Close(); err != <span class="literal">nil</span> &#123;</div><div class="line">						logrus.WithField(<span class="string">"error"</span>, err).Error(<span class="string">"containerd: close process IO"</span>)</div><div class="line">					&#125;</div><div class="line">					EpollFdCounter.Dec(<span class="number">1</span>)</div><div class="line">					<span class="comment">//***放入exits channel中***//</span></div><div class="line">					m.exits &lt;- t</div><div class="line">				&#125;</div><div class="line">			<span class="comment">//***被OOM***//</span></div><div class="line">			<span class="keyword">case</span> runtime.OOM:</div><div class="line">				<span class="comment">// always flush the event fd</span></div><div class="line">				t.Flush()</div><div class="line">				<span class="keyword">if</span> t.Removed() &#123;</div><div class="line">					<span class="built_in">delete</span>(m.receivers, fd)</div><div class="line">					<span class="comment">// epoll will remove the fd from its set after it has been closed</span></div><div class="line">					t.Close()</div><div class="line">					EpollFdCounter.Dec(<span class="number">1</span>)</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					<span class="comment">//***放入到ooms channel中***//</span></div><div class="line">					m.ooms &lt;- t.ContainerID()</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			m.m.Unlock()</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>start()流程如下：</p>
<ol>
<li>通过archutils.EpollWait()获取events；</li>
<li>从receivers中获取event对应的类型；</li>
<li>如果类型是runtime.Process，且事件为EPOLLUP，则把该process放入到exits channel中，表示已被挂起；</li>
<li>如果类型为OOM，则把container id加入到ooms channel中。</li>
</ol>
<p>可以通过Exits()方法获取exits channel中的内容；通过OOMs()方法获取ooms channel中的内容：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/ Exits returns the channel used to notify of a process exit</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Monitor)</span> <span class="title">Exits</span><span class="params">()</span> <span class="title">chan</span> <span class="title">runtime</span>.<span class="title">Process</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> m.exits</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// OOMs returns the channel used to notify of a container exit due to OOM</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Monitor)</span> <span class="title">OOMs</span><span class="params">()</span> <span class="title">chan</span> <span class="title">string</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> m.ooms</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ooms及exits的内容在supervisor的exitHandler()及oomHandler()中会用到。</p>
<p>那么，monitor是如何注册监听事件的呢？答案是通过Monitor()及MonitorOOM()两个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">// Monitor adds a process to the list of the one being monitored</div><div class="line">func (m *Monitor) Monitor(p runtime.Process) error &#123;</div><div class="line">	m.m.Lock()</div><div class="line">	defer m.m.Unlock()</div><div class="line">	fd := p.ExitFD()</div><div class="line">	//***定义EpollEvent事件***//</div><div class="line">	event := syscall.EpollEvent&#123;</div><div class="line">		Fd:     int32(fd),</div><div class="line">		Events: syscall.EPOLLHUP,</div><div class="line">	&#125;</div><div class="line">	//***注册事件***//</div><div class="line">	if err := archutils.EpollCtl(m.epollFd, syscall.EPOLL_CTL_ADD, fd, &amp;event); err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	EpollFdCounter.Inc(1)</div><div class="line">	m.receivers[fd] = p</div><div class="line">	return nil</div><div class="line">&#125;</div><div class="line"></div><div class="line">// MonitorOOM adds a container to the list of the ones monitored for OOM</div><div class="line">func (m *Monitor) MonitorOOM(c runtime.Container) error &#123;</div><div class="line">	m.m.Lock()</div><div class="line">	defer m.m.Unlock()</div><div class="line">	o, err := c.OOM()</div><div class="line">	if err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	fd := o.FD()</div><div class="line">	//***定义EpollEvent事件***//</div><div class="line">	event := syscall.EpollEvent&#123;</div><div class="line">		Fd:     int32(fd),</div><div class="line">		Events: syscall.EPOLLHUP | syscall.EPOLLIN,</div><div class="line">	&#125;</div><div class="line">	//***注册事件***//</div><div class="line">	if err := archutils.EpollCtl(m.epollFd, syscall.EPOLL_CTL_ADD, fd, &amp;event); err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	EpollFdCounter.Inc(1)</div><div class="line">	m.receivers[fd] = o</div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>两个方法的流程如下：</p>
<ol>
<li>定义EpollEvent；</li>
<li>使用EpoolCtl注册事件；</li>
<li>把监听行为添加到receivers中。</li>
</ol>
<p>关于Epoll机制，详见<a href="http://blog.csdn.net/xiajun07061225/article/details/9250579。" target="_blank" rel="external">http://blog.csdn.net/xiajun07061225/article/details/9250579。</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>containerd使用gRPC机制对外提供服务，其内部核心是一个supervisor，其主要有tasks和startTasks两个channel。supervisor会自动处理tasks channel中的内容，处理的方法就是根据task类型的不同调用不同的处理方法。其中StartTask使用start()方法处理，会把StartTask处理成startTask，并放入startTasks channel中。</li>
<li>worker会消费startTasks channel中的内容，先通过containerd-shim使用”runc create”创建容器，再使用”runc start”启动容器。</li>
<li>containerd中的monitor会对运行的容器进行监控，并作出相应的处理。</li>
</ol>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://fankangbest.github.com/2017/11/16/containerd执行流程分析-v0-2-4/" data-id="cjba4qryv003c20qsa0g54p35" class="article-share-link">分享</a><div class="tags"><a href="/tags/containerd/">containerd</a><a href="/tags/containerd-v0-2-4/">containerd-v0.2.4</a></div><div class="post-nav"><a href="/2017/11/19/containerd-container和process-v0-2-4/" class="pre">containerd-container和process-v0.2.4</a><a href="/2017/11/13/containerd-crt命令行使用-v0-2-4/" class="next">containerd-crt命令行使用-v0.2.4</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://fankangbest.github.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/GO语言/">GO语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/存储虚拟化/">存储虚拟化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/容器虚拟化/">容器虚拟化</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/containerd-v0-2-4/" style="font-size: 15px;">containerd-v0.2.4</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/docker-v1-12-3/" style="font-size: 15px;">docker-v1.12.3</a> <a href="/tags/GO语言/" style="font-size: 15px;">GO语言</a> <a href="/tags/containerd/" style="font-size: 15px;">containerd</a> <a href="/tags/kubernetes-v1-5-2/" style="font-size: 15px;">kubernetes-v1.5.2</a> <a href="/tags/gRPC/" style="font-size: 15px;">gRPC</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/runc/" style="font-size: 15px;">runc</a> <a href="/tags/runc-v1-0-0-rc2/" style="font-size: 15px;">runc-v1.0.0-rc2</a> <a href="/tags/ceph/" style="font-size: 15px;">ceph</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/12/16/kubelet分析(二)-podWorker-v1-5-2/">kubelet分析(二)-podWorker-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/16/kubelet分析(一)-config-v1-5-2/">kubelet分析(一)-config-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/15/storage解读(六)-strategy-v1-5-2/">storage解读(六)-strategy-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/14/kubernetes-listwatch机制-v1-5-2/">kubernetes-listwatch机制-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/09/kubernetes-添加controller-demo-v1-5-2/">kubernetes-添加controller-demo-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/09/kubernetes-添加资源-demo-v1-5-2/">kubernetes-添加资源-demo-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/04/libnetwork源码分析(二)-network-v1-12-3/">libnetwork源码分析(二)-network-v1-12-3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/03/libnetwork源码分析(一)-controller(5)-v1-12-3/">libnetwork源码分析(一)-controller(5)-v1-12-3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/03/libnetwork源码分析(一)-controller(4)-v1-12-3/">libnetwork源码分析(一)-controller(4)-v1-12-3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/03/libnetwork源码分析(一)-controller(3)-v1-12-3/">libnetwork源码分析(一)-controller(3)-v1-12-3</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/fankangbest" title="myGithub" target="_blank">myGithub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">fankangbest.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>