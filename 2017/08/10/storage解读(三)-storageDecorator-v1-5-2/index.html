<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>storage解读(三)-storageDecorator-v1.5.2 | fankangbest</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">storage解读(三)-storageDecorator-v1.5.2</h1><a id="logo" href="/.">fankangbest</a><p class="description">多听，少说，接受每一个人的责难，但是保留自己的最后裁决。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">storage解读(三)-storageDecorator-v1.5.2</h1><div class="post-meta">Aug 10, 2017<span> | </span><span class="category"><a href="/categories/容器虚拟化/">容器虚拟化</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h2 id="什么是storageDecorator"><a href="#什么是storageDecorator" class="headerlink" title="什么是storageDecorator"></a>什么是storageDecorator</h2><p>在上次分析中，NewStorage()和NewREST()中生成核心storageInterface(即ETCD Helper)的是Decorator()。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***/registry/rbac/role/etcd/etcd.go NewREST()***//</span></div><div class="line">storageInterface, dFunc := opts.Decorator(</div><div class="line">	opts.StorageConfig,</div><div class="line">	cachesize.GetWatchCacheSizeByResource(cachesize.Roles),</div><div class="line">	&amp;rbac.Role&#123;&#125;,</div><div class="line">	prefix,</div><div class="line">	role.Strategy,</div><div class="line">	newListFunc,</div><div class="line">	storage.NoTriggerPublisher,</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">//***/pkg/registry/core/etcd/etcd.go NewStorage()***//</span></div><div class="line">storageInterface, dFunc := opts.Decorator(</div><div class="line">	opts.StorageConfig,</div><div class="line">	cachesize.GetWatchCacheSizeByResource(cachesize.Nodes),</div><div class="line">	&amp;api.Node&#123;&#125;,</div><div class="line">	prefix,</div><div class="line">	node.Strategy,</div><div class="line">	newListFunc,</div><div class="line">	node.NodeNameTriggerFunc)</div></pre></td></tr></table></figure></p>
<p>所以storageDecorator是用来生成ETCD Helper的。我们先来看下/pkg/master/master.go中对storageDecorator的赋值：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***赋值storageDecorator***//</span></div><div class="line"><span class="keyword">if</span> c.EnableWatchCache &#123;</div><div class="line">	restOptionsFactory.storageDecorator = registry.StorageWithCacher</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	restOptionsFactory.storageDecorator = generic.UndecoratedStorage</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以，在EnableWatchCache为true的情况下，storageDecorator为reigstry.StorageWithCacher；否则为generic.UndecoratedStorage。而APIServer的–watch-cache参数默认为true，所以storageDecorator一般为registry.StorageWithCacher。为了从简单到复杂的分析，本次分析先介绍简单的generic.UndecoratedStorage，然后再介绍复杂的registry.StorageWithCacher。</p>
<h2 id="generic-UndecoratedStorage"><a href="#generic-UndecoratedStorage" class="headerlink" title="generic.UndecoratedStorage"></a>generic.UndecoratedStorage</h2><p>generic.UndecoratedStorage可以从字面上看出，可以直接返回storageInterface，定义在/pkg/registry/generic/storeage_decorator.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Returns given 'storageInterface' without any decoration.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">UndecoratedStorage</span><span class="params">(</span></span></div><div class="line">	config *storagebackend.Config,</div><div class="line">	capacity <span class="keyword">int</span>,</div><div class="line">	objectType runtime.Object,</div><div class="line">	resourcePrefix <span class="keyword">string</span>,</div><div class="line">	scopeStrategy rest.NamespaceScopedStrategy,</div><div class="line">	newListFunc <span class="keyword">func</span>() <span class="title">runtime</span>.<span class="title">Object</span>,</div><div class="line">	<span class="title">trigger</span> <span class="title">storage</span>.<span class="title">TriggerPublisherFunc</span>) <span class="params">(storage.Interface, factory.DestroyFunc)</span> &#123;</div><div class="line">	<span class="keyword">return</span> NewRawStorage(config)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>NewStorage()函数同样定义在/pkg/registry/genericc/storage.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NewRawStorage creates the low level kv storage. This is a work-around for current</span></div><div class="line"><span class="comment">// two layer of same storage interface.</span></div><div class="line"><span class="comment">// <span class="doctag">TODO:</span> Once cacher is enabled on all registries (event registry is special), we will remove this method.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRawStorage</span><span class="params">(config *storagebackend.Config)</span> <span class="params">(storage.Interface, factory.DestroyFunc)</span></span> &#123;</div><div class="line">	<span class="comment">//***调用/pkg/storage/storagebackend/factory/factory.go中的Create()***//</span></div><div class="line">	s, d, err := factory.Create(*config)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		glog.Fatalf(<span class="string">"Unable to create storage backend: config (%v), err (%v)"</span>, config, err)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> s, d</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>NewRawStorage()直接调用factory.Create()来生成底层的key-value存储。这里的factory.Create()可以根据配置文件来生成ETCD2 Helper或ETCD3 Helper，这些，将在下一篇分析中详细介绍。</p>
<h2 id="reigstry-StorageWithCacher"><a href="#reigstry-StorageWithCacher" class="headerlink" title="reigstry.StorageWithCacher"></a>reigstry.StorageWithCacher</h2><p>registry.StorageWithCacher也通过调用NewRawStorage()函数生成底层的key-value存储。不同的是registry.StorageWithCacher会对该key-value存储进行一定的封装，特别是在ListWatch场景中，使用了单reflector多watcher模型。</p>
<p>registry.StorageWithCacher定义在/pkg/registry/generic/registry/storage_factory.go中，主要流程如下：</p>
<ol>
<li>调用NewRawStorage()生成ETCD Helper；</li>
<li>生成CacherConfig，其中CacherConfig中的Storage字段为刚生成好的ETCD Helper；</li>
<li>NewCacherFromConfig()生成Cacher</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Creates a cacher based given storageConfig.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">StorageWithCacher</span><span class="params">(</span></span></div><div class="line">	storageConfig *storagebackend.Config,</div><div class="line">	capacity <span class="keyword">int</span>,</div><div class="line">	objectType runtime.Object,</div><div class="line">	resourcePrefix <span class="keyword">string</span>,</div><div class="line">	scopeStrategy rest.NamespaceScopedStrategy,</div><div class="line">	newListFunc <span class="keyword">func</span>() <span class="title">runtime</span>.<span class="title">Object</span>,</div><div class="line">	<span class="title">triggerFunc</span> <span class="title">storage</span>.<span class="title">TriggerPublisherFunc</span>) <span class="params">(storage.Interface, factory.DestroyFunc)</span> &#123;</div><div class="line"></div><div class="line">	s, d := generic.NewRawStorage(storageConfig)</div><div class="line">	<span class="comment">// <span class="doctag">TODO:</span> we would change this later to make storage always have cacher and hide low level KV layer inside.</span></div><div class="line">	<span class="comment">// Currently it has two layers of same storage interface -- cacher and low level kv.</span></div><div class="line">	cacherConfig := storage.CacherConfig&#123;</div><div class="line">		CacheCapacity:        capacity,</div><div class="line">		Storage:              s,</div><div class="line">		Versioner:            etcdstorage.APIObjectVersioner&#123;&#125;,</div><div class="line">		Type:                 objectType,</div><div class="line">		ResourcePrefix:       resourcePrefix,</div><div class="line">		NewListFunc:          newListFunc,</div><div class="line">		TriggerPublisherFunc: triggerFunc,</div><div class="line">		Codec:                storageConfig.Codec,</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> scopeStrategy.NamespaceScoped() &#123;</div><div class="line">		cacherConfig.KeyFunc = <span class="function"><span class="keyword">func</span><span class="params">(obj runtime.Object)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</div><div class="line">			<span class="keyword">return</span> storage.NamespaceKeyFunc(resourcePrefix, obj)</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		cacherConfig.KeyFunc = <span class="function"><span class="keyword">func</span><span class="params">(obj runtime.Object)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</div><div class="line">			<span class="keyword">return</span> storage.NoNamespaceKeyFunc(resourcePrefix, obj)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	cacher := storage.NewCacherFromConfig(cacherConfig)</div><div class="line">	destroyFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		cacher.Stop()</div><div class="line">		d()</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> cacher, destroyFunc</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以，接下来，让我们看下Cacher的定义。</p>
<h3 id="Cacher"><a href="#Cacher" class="headerlink" title="Cacher"></a>Cacher</h3><p>Cacher定义在/pkg/storage/cacher.go中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">// Cacher is responsible for serving WATCH and LIST requests for a given</div><div class="line">// resource from its internal cache and updating its cache in the background</div><div class="line">// based on the underlying storage contents.</div><div class="line">// Cacher implements storage.Interface (although most of the calls are just</div><div class="line">// delegated to the underlying storage).</div><div class="line">type Cacher struct &#123;</div><div class="line">	// HighWaterMarks for performance debugging.</div><div class="line">	// Important: Since HighWaterMark is using sync/atomic, it has to be at the top of the struct due to a bug on 32-bit platforms</div><div class="line">	// See: https://golang.org/pkg/sync/atomic/ for more information</div><div class="line">	incomingHWM HighWaterMark</div><div class="line">	// Incoming events that should be dispatched to watchers.</div><div class="line">	incoming chan watchCacheEvent</div><div class="line"></div><div class="line">	sync.RWMutex</div><div class="line"></div><div class="line">	// Before accessing the cacher&apos;s cache, wait for the ready to be ok.</div><div class="line">	// This is necessary to prevent users from accessing structures that are</div><div class="line">	// uninitialized or are being repopulated right now.</div><div class="line">	// ready needs to be set to false when the cacher is paused or stopped.</div><div class="line">	// ready needs to be set to true when the cacher is ready to use after</div><div class="line">	// initialization.</div><div class="line">	ready *ready</div><div class="line"></div><div class="line">	// Underlying storage.Interface.</div><div class="line">	storage Interface</div><div class="line"></div><div class="line">	// Expected type of objects in the underlying cache.</div><div class="line">	objectType reflect.Type</div><div class="line"></div><div class="line">	// &quot;sliding window&quot; of recent changes of objects and the current state.</div><div class="line">	watchCache *watchCache</div><div class="line">	reflector  *cache.Reflector</div><div class="line"></div><div class="line">	// Versioner is used to handle resource versions.</div><div class="line">	versioner Versioner</div><div class="line"></div><div class="line">	// triggerFunc is used for optimizing amount of watchers that needs to process</div><div class="line">	// an incoming event.</div><div class="line">	triggerFunc TriggerPublisherFunc</div><div class="line">	// watchers is mapping from the value of trigger function that a</div><div class="line">	// watcher is interested into the watchers</div><div class="line">	watcherIdx int</div><div class="line">	watchers   indexedWatchers</div><div class="line"></div><div class="line">	// Handling graceful termination.</div><div class="line">	stopLock sync.RWMutex</div><div class="line">	stopped  bool</div><div class="line">	stopCh   chan struct&#123;&#125;</div><div class="line">	stopWg   sync.WaitGroup</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Cacher主要的字段如下：</p>
<ul>
<li>incoming: incoming channel中的Event会自动分发到各watcher中；</li>
<li>storage: 底层的key-value存储，即ETCD Helper；</li>
<li>watchCache: 与reflector配合使用，处理reflector中的Event；</li>
<li>refstoragelector: 消费listerWatcher中的Event，并把Event并给watchCache处理；</li>
<li>watchers: watcher数组；</li>
<li>versioner: ETCD中数据版本管理结构体。</li>
</ul>
<h4 id="NewCacherFromConfig"><a href="#NewCacherFromConfig" class="headerlink" title="NewCacherFromConfig()"></a>NewCacherFromConfig()</h4><p>NewCacherFromConfig()的流程如下：</p>
<ol>
<li>生成watchCache；</li>
<li>生成listerWatcher，listerWatcher对ETCD Helper进行了封装；</li>
<li>生成cacher；</li>
<li>设置watchCache中的OnEvent为cacher.processEvent；</li>
<li>启动cacher.dispatchEvents()，即分发方法；</li>
<li>返回cacher。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Create a new Cacher responsible from service WATCH and LIST requests from its</span></div><div class="line"><span class="comment">// internal cache and updating its cache in the background based on the given</span></div><div class="line"><span class="comment">// configuration.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCacherFromConfig</span><span class="params">(config CacherConfig)</span> *<span class="title">Cacher</span></span> &#123;</div><div class="line">	watchCache := newWatchCache(config.CacheCapacity, config.KeyFunc)</div><div class="line">	listerWatcher := newCacherListerWatcher(config.Storage, config.ResourcePrefix, config.NewListFunc)</div><div class="line"></div><div class="line">	<span class="comment">// Give this error when it is constructed rather than when you get the</span></div><div class="line">	<span class="comment">// first watch item, because it's much easier to track down that way.</span></div><div class="line">	<span class="keyword">if</span> obj, ok := config.Type.(runtime.Object); ok &#123;</div><div class="line">		<span class="keyword">if</span> err := runtime.CheckCodec(config.Codec, obj); err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="built_in">panic</span>(<span class="string">"storage codec doesn't seem to match given type: "</span> + err.Error())</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	cacher := &amp;Cacher&#123;</div><div class="line">		ready:       newReady(),</div><div class="line">		storage:     config.Storage,</div><div class="line">		objectType:  reflect.TypeOf(config.Type),</div><div class="line">		watchCache:  watchCache,</div><div class="line">		reflector:   cache.NewReflector(listerWatcher, config.Type, watchCache, <span class="number">0</span>),</div><div class="line">		versioner:   config.Versioner,</div><div class="line">		triggerFunc: config.TriggerPublisherFunc,</div><div class="line">		watcherIdx:  <span class="number">0</span>,</div><div class="line">		watchers: indexedWatchers&#123;</div><div class="line">			allWatchers:   <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*cacheWatcher),</div><div class="line">			valueWatchers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]watchersMap),</div><div class="line">		&#125;,</div><div class="line">		<span class="comment">// <span class="doctag">TODO:</span> Figure out the correct value for the buffer size.</span></div><div class="line">		incoming: <span class="built_in">make</span>(<span class="keyword">chan</span> watchCacheEvent, <span class="number">100</span>),</div><div class="line">		<span class="comment">// We need to (potentially) stop both:</span></div><div class="line">		<span class="comment">// - wait.Until go-routine</span></div><div class="line">		<span class="comment">// - reflector.ListAndWatch</span></div><div class="line">		<span class="comment">// and there are no guarantees on the order that they will stop.</span></div><div class="line">		<span class="comment">// So we will be simply closing the channel, and synchronizing on the WaitGroup.</span></div><div class="line">		stopCh: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</div><div class="line">	&#125;</div><div class="line">	watchCache.SetOnEvent(cacher.processEvent)</div><div class="line">	<span class="keyword">go</span> cacher.dispatchEvents()</div><div class="line"></div><div class="line">	stopCh := cacher.stopCh</div><div class="line">	cacher.stopWg.Add(<span class="number">1</span>)</div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">defer</span> cacher.stopWg.Done()</div><div class="line">		wait.Until(</div><div class="line">			<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">				<span class="keyword">if</span> !cacher.isStopped() &#123;</div><div class="line">					cacher.startCaching(stopCh)</div><div class="line">				&#125;</div><div class="line">			&#125;, time.Second, stopCh,</div><div class="line">		)</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">return</span> cacher</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以，Cacher中最重要的方法是processEvent()和dispatchEvents()方法。</p>
<h4 id="processEvent"><a href="#processEvent" class="headerlink" title="processEvent()"></a>processEvent()</h4><p>processEvent()的作用很简单，就是把watchCacheEvent放入Cacher的incoming channel。现在我们有了incoming channel中的生产者。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***把event放入到incoming中***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">processEvent</span><span class="params">(event watchCacheEvent)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> curLen := <span class="keyword">int64</span>(<span class="built_in">len</span>(c.incoming)); c.incomingHWM.Update(curLen) &#123;</div><div class="line">		<span class="comment">// Monitor if this gets backed up, and how much.</span></div><div class="line">		glog.V(<span class="number">1</span>).Infof(<span class="string">"cacher (%v): %v objects queued in incoming channel."</span>, c.objectType.String(), curLen)</div><div class="line">	&#125;</div><div class="line">	c.incoming &lt;- event</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="dispatchEvents"><a href="#dispatchEvents" class="headerlink" title="dispatchEvents()"></a>dispatchEvents()</h4><p>dispatchEvents()会消费incoming中的watchCacheEvent，并调用dispatchEvent()处理watchCacheEvent。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***消费incoming中的数据，并调用dispatchEvent()方法进行分发***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">dispatchEvents</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> event, ok := &lt;-c.incoming:</div><div class="line">			<span class="keyword">if</span> !ok &#123;</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">			c.dispatchEvent(&amp;event)</div><div class="line">		<span class="keyword">case</span> &lt;-c.stopCh:</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="dispatchEvent"><a href="#dispatchEvent" class="headerlink" title="dispatchEvent()"></a>dispatchEvent()</h4><p>dispatchEvent()可以把watchCacheEvent添加到Cacher中的每个watcher中。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">dispatchEvent</span><span class="params">(event *watchCacheEvent)</span></span> &#123;</div><div class="line">	triggerValues, supported := c.triggerValues(event)</div><div class="line"></div><div class="line">	<span class="comment">// <span class="doctag">TODO:</span> For now we assume we have a given &lt;timeout&gt; budget for dispatching</span></div><div class="line">	<span class="comment">// a single event. We should consider changing to the approach with:</span></div><div class="line">	<span class="comment">// - budget has upper bound at &lt;max_timeout&gt;</span></div><div class="line">	<span class="comment">// - we add &lt;portion&gt; to current timeout every second</span></div><div class="line">	timeout := time.Duration(<span class="number">250</span>) * time.Millisecond</div><div class="line"></div><div class="line">	c.Lock()</div><div class="line">	<span class="keyword">defer</span> c.Unlock()</div><div class="line">	<span class="comment">// Iterate over "allWatchers" no matter what the trigger function is.</span></div><div class="line">	<span class="keyword">for</span> _, watcher := <span class="keyword">range</span> c.watchers.allWatchers &#123;</div><div class="line">		watcher.add(event, &amp;timeout)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> supported &#123;</div><div class="line">		<span class="comment">// Iterate over watchers interested in the given values of the trigger.</span></div><div class="line">		<span class="keyword">for</span> _, triggerValue := <span class="keyword">range</span> triggerValues &#123;</div><div class="line">			<span class="keyword">for</span> _, watcher := <span class="keyword">range</span> c.watchers.valueWatchers[triggerValue] &#123;</div><div class="line">				watcher.add(event, &amp;timeout)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">// supported equal to false generally means that trigger function</span></div><div class="line">		<span class="comment">// is not defined (or not aware of any indexes). In this case,</span></div><div class="line">		<span class="comment">// watchers filters should generally also don't generate any</span></div><div class="line">		<span class="comment">// trigger values, but can cause problems in case of some</span></div><div class="line">		<span class="comment">// misconfiguration. Thus we paranoidly leave this branch.</span></div><div class="line"></div><div class="line">		<span class="comment">// Iterate over watchers interested in exact values for all values.</span></div><div class="line">		<span class="keyword">for</span> _, watchers := <span class="keyword">range</span> c.watchers.valueWatchers &#123;</div><div class="line">			<span class="keyword">for</span> _, watcher := <span class="keyword">range</span> watchers &#123;</div><div class="line">				watcher.add(event, &amp;timeout)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Watch"><a href="#Watch" class="headerlink" title="Watch()"></a>Watch()</h4><p>Cacher的Watch()方法通过调用newCacheWatcher()生成一个cacheWatcher，然后把cacheWatcher加入到Cacher中，最后返回cacheWatcher。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Implements storage.Interface.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">Watch</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, resourceVersion <span class="keyword">string</span>, pred SelectionPredicate)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</div><div class="line">	watchRV, err := ParseWatchResourceVersion(resourceVersion)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	c.ready.wait()</div><div class="line"></div><div class="line">	<span class="comment">// We explicitly use thread unsafe version and do locking ourself to ensure that</span></div><div class="line">	<span class="comment">// no new events will be processed in the meantime. The watchCache will be unlocked</span></div><div class="line">	<span class="comment">// on return from this function.</span></div><div class="line">	<span class="comment">// Note that we cannot do it under Cacher lock, to avoid a deadlock, since the</span></div><div class="line">	<span class="comment">// underlying watchCache is calling processEvent under its lock.</span></div><div class="line">	c.watchCache.RLock()</div><div class="line">	<span class="keyword">defer</span> c.watchCache.RUnlock()</div><div class="line">	initEvents, err := c.watchCache.GetAllEventsSinceThreadUnsafe(watchRV)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="comment">// To match the uncached watch implementation, once we have passed authn/authz/admission,</span></div><div class="line">		<span class="comment">// and successfully parsed a resource version, other errors must fail with a watch event of type ERROR,</span></div><div class="line">		<span class="comment">// rather than a directly returned error.</span></div><div class="line">		<span class="keyword">return</span> newErrWatcher(err), <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	triggerValue, triggerSupported := <span class="string">""</span>, <span class="literal">false</span></div><div class="line">	<span class="comment">// <span class="doctag">TODO:</span> Currently we assume that in a given Cacher object, any &lt;predicate&gt; that is</span></div><div class="line">	<span class="comment">// passed here is aware of exactly the same trigger (at most one).</span></div><div class="line">	<span class="comment">// Thus, either 0 or 1 values will be returned.</span></div><div class="line">	<span class="keyword">if</span> matchValues := pred.MatcherIndex(); <span class="built_in">len</span>(matchValues) &gt; <span class="number">0</span> &#123;</div><div class="line">		triggerValue, triggerSupported = matchValues[<span class="number">0</span>].Value, <span class="literal">true</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// If there is triggerFunc defined, but triggerSupported is false,</span></div><div class="line">	<span class="comment">// we can't narrow the amount of events significantly at this point.</span></div><div class="line">	<span class="comment">//</span></div><div class="line">	<span class="comment">// That said, currently triggerFunc is defined only for Pods and Nodes,</span></div><div class="line">	<span class="comment">// and there is only constant number of watchers for which triggerSupported</span></div><div class="line">	<span class="comment">// is false (excluding those issues explicitly by users).</span></div><div class="line">	<span class="comment">// Thus, to reduce the risk of those watchers blocking all watchers of a</span></div><div class="line">	<span class="comment">// given resource in the system, we increase the sizes of buffers for them.</span></div><div class="line">	chanSize := <span class="number">10</span></div><div class="line">	<span class="keyword">if</span> c.triggerFunc != <span class="literal">nil</span> &amp;&amp; !triggerSupported &#123;</div><div class="line">		<span class="comment">// <span class="doctag">TODO:</span> We should tune this value and ideally make it dependent on the</span></div><div class="line">		<span class="comment">// number of objects of a given type and/or their churn.</span></div><div class="line">		chanSize = <span class="number">1000</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	c.Lock()</div><div class="line">	<span class="keyword">defer</span> c.Unlock()</div><div class="line">	forget := forgetWatcher(c, c.watcherIdx, triggerValue, triggerSupported)</div><div class="line">	watcher := newCacheWatcher(watchRV, chanSize, initEvents, filterFunction(key, pred), forget)</div><div class="line"></div><div class="line">	c.watchers.addWatcher(watcher, c.watcherIdx, triggerValue, triggerSupported)</div><div class="line">	c.watcherIdx++</div><div class="line">	<span class="keyword">return</span> watcher, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="cacheWatcher"><a href="#cacheWatcher" class="headerlink" title="cacheWatcher"></a>cacheWatcher</h3><p>再来看下cacheWatcher。cacheWatcher定义在/pkg/storage/cacher.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> cacheWatcher <span class="keyword">struct</span> &#123;</div><div class="line">	sync.Mutex</div><div class="line">	input   <span class="keyword">chan</span> watchCacheEvent</div><div class="line">	result  <span class="keyword">chan</span> watch.Event</div><div class="line">	filter  filterObjectFunc</div><div class="line">	done    <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</div><div class="line">	stopped <span class="keyword">bool</span></div><div class="line">	forget  <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">bool</span>)</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="newWatchCache"><a href="#newWatchCache" class="headerlink" title="newWatchCache()"></a>newWatchCache()</h4><p>newWatchCache()生成一个cacheWatcher()，然后启动process()方法。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***生成cacheWatcher***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCacheWatcher</span><span class="params">(resourceVersion <span class="keyword">uint64</span>, chanSize <span class="keyword">int</span>, initEvents []watchCacheEvent, filter filterObjectFunc, forget <span class="keyword">func</span>(<span class="keyword">bool</span>)</span>) *<span class="title">cacheWatcher</span></span> &#123;</div><div class="line">	watcher := &amp;cacheWatcher&#123;</div><div class="line">		input:   <span class="built_in">make</span>(<span class="keyword">chan</span> watchCacheEvent, chanSize),</div><div class="line">		result:  <span class="built_in">make</span>(<span class="keyword">chan</span> watch.Event, chanSize),</div><div class="line">		done:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</div><div class="line">		filter:  filter,</div><div class="line">		stopped: <span class="literal">false</span>,</div><div class="line">		forget:  forget,</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">go</span> watcher.process(initEvents, resourceVersion)</div><div class="line">	<span class="keyword">return</span> watcher</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Process"><a href="#Process" class="headerlink" title="Process()"></a>Process()</h4><p>process()会消费input channel中的watchCacheEvent，并调用sendWatchCacheEvent()进行处理。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cacheWatcher)</span> <span class="title">process</span><span class="params">(initEvents []watchCacheEvent, resourceVersion <span class="keyword">uint64</span>)</span></span> &#123;</div><div class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</div><div class="line"></div><div class="line">	<span class="comment">// Check how long we are processing initEvents.</span></div><div class="line">	<span class="comment">// As long as these are not processed, we are not processing</span></div><div class="line">	<span class="comment">// any incoming events, so if it takes long, we may actually</span></div><div class="line">	<span class="comment">// block all watchers for some time.</span></div><div class="line">	<span class="comment">// <span class="doctag">TODO:</span> From the logs it seems that there happens processing</span></div><div class="line">	<span class="comment">// times even up to 1s which is very long. However, this doesn't</span></div><div class="line">	<span class="comment">// depend that much on the number of initEvents. E.g. from the</span></div><div class="line">	<span class="comment">// 2000-node Kubemark run we have logs like this, e.g.:</span></div><div class="line">	<span class="comment">// ... processing 13862 initEvents took 66.808689ms</span></div><div class="line">	<span class="comment">// ... processing 14040 initEvents took 993.532539ms</span></div><div class="line">	<span class="comment">// We should understand what is blocking us in those cases (e.g.</span></div><div class="line">	<span class="comment">// is it lack of CPU, network, or sth else) and potentially</span></div><div class="line">	<span class="comment">// consider increase size of result buffer in those cases.</span></div><div class="line">	<span class="keyword">const</span> initProcessThreshold = <span class="number">500</span> * time.Millisecond</div><div class="line">	startTime := time.Now()</div><div class="line">	<span class="keyword">for</span> _, event := <span class="keyword">range</span> initEvents &#123;</div><div class="line">		c.sendWatchCacheEvent(&amp;event)</div><div class="line">	&#125;</div><div class="line">	processingTime := time.Since(startTime)</div><div class="line">	<span class="keyword">if</span> processingTime &gt; initProcessThreshold &#123;</div><div class="line">		objType := <span class="string">"&lt;null&gt;"</span></div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(initEvents) &gt; <span class="number">0</span> &#123;</div><div class="line">			objType = reflect.TypeOf(initEvents[<span class="number">0</span>].Object).String()</div><div class="line">		&#125;</div><div class="line">		glog.V(<span class="number">2</span>).Infof(<span class="string">"processing %d initEvents of %s took %v"</span>, <span class="built_in">len</span>(initEvents), objType, processingTime)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(c.result)</div><div class="line">	<span class="keyword">defer</span> c.Stop()</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		event, ok := &lt;-c.input</div><div class="line">		<span class="keyword">if</span> !ok &#123;</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// only send events newer than resourceVersion</span></div><div class="line">		<span class="keyword">if</span> event.ResourceVersion &gt; resourceVersion &#123;</div><div class="line">			c.sendWatchCacheEvent(&amp;event)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="sendWatchCacheEvent"><a href="#sendWatchCacheEvent" class="headerlink" title="sendWatchCacheEvent()"></a>sendWatchCacheEvent()</h4><p>sendWatchCacheEvent()会把watchCacheEvent转换成普通Event，并把Event放入到result channel。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***把event放入到result中***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cacheWatcher)</span> <span class="title">sendWatchCacheEvent</span><span class="params">(event *watchCacheEvent)</span></span> &#123;</div><div class="line">	curObjPasses := event.Type != watch.Deleted &amp;&amp; c.filter(event.Key, event.Object)</div><div class="line">	oldObjPasses := <span class="literal">false</span></div><div class="line">	<span class="keyword">if</span> event.PrevObject != <span class="literal">nil</span> &#123;</div><div class="line">		oldObjPasses = c.filter(event.Key, event.PrevObject)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> !curObjPasses &amp;&amp; !oldObjPasses &#123;</div><div class="line">		<span class="comment">// Watcher is not interested in that object.</span></div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	object, err := api.Scheme.Copy(event.Object)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		glog.Errorf(<span class="string">"unexpected copy error: %v"</span>, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">var</span> watchEvent watch.Event</div><div class="line">	<span class="keyword">switch</span> &#123;</div><div class="line">	<span class="keyword">case</span> curObjPasses &amp;&amp; !oldObjPasses:</div><div class="line">		watchEvent = watch.Event&#123;Type: watch.Added, Object: object&#125;</div><div class="line">	<span class="keyword">case</span> curObjPasses &amp;&amp; oldObjPasses:</div><div class="line">		watchEvent = watch.Event&#123;Type: watch.Modified, Object: object&#125;</div><div class="line">	<span class="keyword">case</span> !curObjPasses &amp;&amp; oldObjPasses:</div><div class="line">		watchEvent = watch.Event&#123;Type: watch.Deleted, Object: object&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// We need to ensure that if we put event X to the c.result, all</span></div><div class="line">	<span class="comment">// previous events were already put into it before, no matter whether</span></div><div class="line">	<span class="comment">// c.done is close or not.</span></div><div class="line">	<span class="comment">// Thus we cannot simply select from c.done and c.result and this</span></div><div class="line">	<span class="comment">// would give us non-determinism.</span></div><div class="line">	<span class="comment">// At the same time, we don't want to block infinitely on putting</span></div><div class="line">	<span class="comment">// to c.result, when c.done is already closed.</span></div><div class="line"></div><div class="line">	<span class="comment">// This ensures that with c.done already close, we at most once go</span></div><div class="line">	<span class="comment">// into the next select after this. With that, no matter which</span></div><div class="line">	<span class="comment">// statement we choose there, we will deliver only consecutive</span></div><div class="line">	<span class="comment">// events.</span></div><div class="line">	<span class="keyword">select</span> &#123;</div><div class="line">	<span class="keyword">case</span> &lt;-c.done:</div><div class="line">		<span class="keyword">return</span></div><div class="line">	<span class="keyword">default</span>:</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">select</span> &#123;</div><div class="line">	<span class="keyword">case</span> c.result &lt;- watchEvent:</div><div class="line">	<span class="keyword">case</span> &lt;-c.done:</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h4><p>add()可以把watchCacheEvent放到input channel中。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***把event放入到input上***//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cacheWatcher)</span> <span class="title">add</span><span class="params">(event *watchCacheEvent, timeout *time.Duration)</span></span> &#123;</div><div class="line">	<span class="comment">// Try to send the event immediately, without blocking.</span></div><div class="line">	<span class="keyword">select</span> &#123;</div><div class="line">	<span class="keyword">case</span> c.input &lt;- *event:</div><div class="line">		<span class="keyword">return</span></div><div class="line">	<span class="keyword">default</span>:</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// OK, block sending, but only for up to &lt;timeout&gt;.</span></div><div class="line">	<span class="comment">// cacheWatcher.add is called very often, so arrange</span></div><div class="line">	<span class="comment">// to reuse timers instead of constantly allocating.</span></div><div class="line">	startTime := time.Now()</div><div class="line"></div><div class="line">	t, ok := timerPool.Get().(*time.Timer)</div><div class="line">	<span class="keyword">if</span> ok &#123;</div><div class="line">		t.Reset(*timeout)</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		t = time.NewTimer(*timeout)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">defer</span> timerPool.Put(t)</div><div class="line"></div><div class="line">	<span class="keyword">select</span> &#123;</div><div class="line">	<span class="keyword">case</span> c.input &lt;- *event:</div><div class="line">		stopped := t.Stop()</div><div class="line">		<span class="keyword">if</span> !stopped &#123;</div><div class="line">			<span class="comment">// Consume triggered (but not yet received) timer event</span></div><div class="line">			<span class="comment">// so that future reuse does not get a spurious timeout.</span></div><div class="line">			&lt;-t.C</div><div class="line">		&#125;</div><div class="line">	<span class="keyword">case</span> &lt;-t.C:</div><div class="line">		<span class="comment">// This means that we couldn't send event to that watcher.</span></div><div class="line">		<span class="comment">// Since we don't want to block on it infinitely,</span></div><div class="line">		<span class="comment">// we simply terminate it.</span></div><div class="line">		c.forget(<span class="literal">false</span>)</div><div class="line">		c.stop()</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> *timeout = *timeout - time.Since(startTime); *timeout &lt; <span class="number">0</span> &#123;</div><div class="line">		*timeout = <span class="number">0</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="ResultChan"><a href="#ResultChan" class="headerlink" title="ResultChan()"></a>ResultChan()</h4><p>所有watcher必须实现ResultChan()返回result channel。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Implements watch.Interface.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cacheWatcher)</span> <span class="title">ResultChan</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">watch</span>.<span class="title">Event</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> c.result</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="watchCache"><a href="#watchCache" class="headerlink" title="watchCache"></a>watchCache</h3><p>watchCache先把Event转换成cacheWatchEvent，然后对cacheWatchEvent进行处理。watchCache本身是一个store cache，可以和reflector配合使用。其中cacheWatchEvent比Event多了PrevObject，为了不增加复杂度，具体分析略。</p>
<p>watchCache的Add(), Update(), Delete()都会调用processEvent()：</p>
<ol>
<li>生成watchCacheEvent;</li>
<li>调用onEvent()</li>
<li>把watchCacheEvent进行缓存。<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *watchCache)</span> <span class="title">processEvent</span><span class="params">(event watch.Event, resourceVersion <span class="keyword">uint64</span>, updateFunc <span class="keyword">func</span>(*storeElement)</span> <span class="title">error</span>) <span class="title">error</span></span> &#123;</div><div class="line">	key, err := w.keyFunc(event.Object)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"couldn't compute key: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	elem := &amp;storeElement&#123;Key: key, Object: event.Object&#125;</div><div class="line"></div><div class="line">	<span class="comment">// <span class="doctag">TODO:</span> We should consider moving this lock below after the watchCacheEvent</span></div><div class="line">	<span class="comment">// is created. In such situation, the only problematic scenario is Replace(</span></div><div class="line">	<span class="comment">// happening after getting object from store and before acquiring a lock.</span></div><div class="line">	<span class="comment">// Maybe introduce another lock for this purpose.</span></div><div class="line">	w.Lock()</div><div class="line">	<span class="keyword">defer</span> w.Unlock()</div><div class="line">	previous, exists, err := w.store.Get(elem)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">var</span> prevObject runtime.Object</div><div class="line">	<span class="keyword">if</span> exists &#123;</div><div class="line">		prevObject = previous.(*storeElement).Object</div><div class="line">	&#125;</div><div class="line">	watchCacheEvent := watchCacheEvent&#123;</div><div class="line">		Type:            event.Type,</div><div class="line">		Object:          event.Object,</div><div class="line">		PrevObject:      prevObject,</div><div class="line">		Key:             key,</div><div class="line">		ResourceVersion: resourceVersion,</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> w.onEvent != <span class="literal">nil</span> &#123;</div><div class="line">		w.onEvent(watchCacheEvent)</div><div class="line">	&#125;</div><div class="line">	w.updateCache(resourceVersion, &amp;watchCacheEvent)</div><div class="line">	w.resourceVersion = resourceVersion</div><div class="line">	w.cond.Broadcast()</div><div class="line">	<span class="keyword">return</span> updateFunc(elem)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这里的onEvent就是Cacher的processEvent()方法，可以把watchCacheEvent放入到Cacher的incoming channel中。</p>
<h3 id="reflector"><a href="#reflector" class="headerlink" title="reflector"></a>reflector</h3><p>reflector可以消费ListWatcher中的Event，并把Event通过调用cache的Add(), Update()等操对Event进行缓存并处理。具体reflector在以后介绍。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次分析了两个ETCD Helper生成的入口函数：generic.UndecoratedStorage和registry.StorageWithCacher。</p>
<p>其中generic.UndecoratedStorage直接返回ETCD Helper。</p>
<p>而registry.StorageWithCacher中定义了Cacher，cacheWatcher，watchCache。Cacher先生成ETCD Helper，然后通过reflector机制把ETCD Helper的Event使用watchCache进行缓存并处理，处理的过程就是把Event放入到Cacher的incoming channel中。Cacher维护有一个dispatchEvents controller把incoming中的Event分发到各cacheWatcher，即放入到cacheWatcher中的input channel。cacheWatcher中有process controller把input中的Event放到result channel供外部消费。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://fankangbest.github.com/2017/08/10/storage解读(三)-storageDecorator-v1-5-2/" data-id="cj78fngqt0024mcqs8f8ztafq" class="article-share-link">分享</a><div class="tags"><a href="/tags/kubernetes/">kubernetes</a><a href="/tags/kubernetes-v1-5-2/">kubernetes-v1.5.2</a></div><div class="post-nav"><a href="/2017/08/11/storage解读(四)-etcdHelper-v1-5-2/" class="pre">storage解读(四)-etcdHelper-v1.5.2</a><a href="/2017/08/08/storage解读(二)-genericStore-v1-5-2/" class="next">storage解读(二)-genericStore-v1.5.2</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://fankangbest.github.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/存储虚拟化/">存储虚拟化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/容器虚拟化/">容器虚拟化</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/kubernetes-v1-5-2/" style="font-size: 15px;">kubernetes-v1.5.2</a> <a href="/tags/ceph/" style="font-size: 15px;">ceph</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/09/06/resourcequota分析(一)-evaluator-v1-5-2/">resourcequota分析(一)-evaluator-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/04/admission机制分析-v1-5-2/">admission机制分析-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/28/cache解读(四)-SharedInformer-v1-5-2/">cache解读(四)-SharedInformer-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/25/cache解读(三)-Controller-v1-5-2/">cache解读(三)-Controller-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/23/cache解读(二)-Queue-v1-5-2/">cache解读(二)-Queue-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/22/cache解读(一)-Store-v1-5-2/">cache解读(一)-Store-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/21/reflector机制-v1-5-2/">reflector机制-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/17/使用docker搭建Ceph环境/">使用docker搭建Ceph环境</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/16/storage解读(五)-etcdWatcher-v1-5-2/">storage解读(五)-etcdWatcher-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/11/storage解读(四)-etcdHelper-v1-5-2/">storage解读(四)-etcdHelper-v1.5.2</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/fankangbest" title="myGithub" target="_blank">myGithub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">fankangbest.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>