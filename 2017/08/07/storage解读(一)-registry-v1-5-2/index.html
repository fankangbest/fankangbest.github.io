<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>storage解读(一)-registry-v1.5.2 | fankangbest</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">storage解读(一)-registry-v1.5.2</h1><a id="logo" href="/.">fankangbest</a><p class="description">多听，少说，接受每一个人的责难，但是保留自己的最后裁决。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">storage解读(一)-registry-v1.5.2</h1><div class="post-meta">Aug 7, 2017<span> | </span><span class="category"><a href="/categories/容器虚拟化/">容器虚拟化</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h2 id="什么是registry"><a href="#什么是registry" class="headerlink" title="什么是registry"></a>什么是registry</h2><p>在Kubernetes中，registry可以对ETCD中的Kubernetes各类型进行增删查改操作，并对外提供了生成apiGroupInfo的方法。这里的registry包含了两层含义，Storage和Registry，如NodeStorage和NodeRegistry。Storage提供了通用的增删查改方法，Regsitry是对Storage的封装，提供了具体类型的增删查改方法。registry定义在/pkg/registry目录下，主要包含：</p>
<ul>
<li>apps: 定义statefulsets相关的registry信息；</li>
<li>authentication: 定义tokenreview相关的registry信息；</li>
<li>authorization: 定义localsubjectaccessreview, selfsubjectaccessreview, subjectaccessreview相关的registry信息；</li>
<li>autoscaling: 定义horizontalpodautoscaler相关的registry信息；</li>
<li>batch: 定义scheduledjobs相关的registry信息；</li>
<li>certificates: 定义certificatesigningrequests相关的registry信息；</li>
<li>core: 定义componentstatus, configmap, controller, endpoint, event, limitrange, namespace, node, persistentvolume, persistentvolumeclaim, pod, podtemplate, rangeallocation, resourcequota, secret, service, serviceaccount的registry信息；</li>
<li>extensions: 定义replicationcontrollers, daemonset, deployment, ingress, networkpolicy, podsecuritypolicy, replicaset等相关的registry信息；</li>
<li>generic: 公共模块，对storage模块进行封装；</li>
<li>policy: 定义poddisruptionbudgets相关的registry信息；</li>
<li>rbac: 定义cluserrole, role等相关的registry信息；</li>
<li>storage: 定义storageclass相关的registry信息。</li>
</ul>
<p>以上就是/pkg/registry目录下的主要目录，每个子目录都对应一个APIGroup，如core对应的是v1，每个子目录下都有个rest的目录，其中core目录实现了NewLegacyRESTStorage()方法生成对应的apiGroupInfo，其他目录实现了NewRESTStorage()方法生成对应的apiGroupInfo。关于apiGroupInfo将在以后分析，现在只需要知道apiGroupInfo是联系registry和apiserver的通道。</p>
<p>在NewLegacyRESTStorage()方法中，会调用NewStorage()生成storage，如nodeStorage等，进一步地生成restStorageMap，然后生成apiGroupInfo。</p>
<p>其他APIGroup使用NewRESTStorage()，会调用NewREST()生成storage，如rolesStorage。</p>
<p>我们以core包下的node为例来看下NewStorage()的实现，以rbac包下的role为例来看下NewREST()的实现。</p>
<h2 id="nodeStorage"><a href="#nodeStorage" class="headerlink" title="nodeStorage"></a>nodeStorage</h2><p>node定义在/pkg/registry/core/node目录下。我们先来看下/pkg/registry/core/rest/storage_core.go中的NewLegacyRESTStorage()是如何生成nodeStorage和NodeRegistry的，代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nodeStorage, err := nodeetcd.NewStorage(restOptionsGetter(api.Resource(<span class="string">"nodes"</span>)), c.KubeletClientConfig, c.ProxyTransport)</div><div class="line">......</div><div class="line">restStorage.NodeRegistry = node.NewRegistry(nodeStorage.Node)</div></pre></td></tr></table></figure></p>
<h3 id="restOptionsGetter"><a href="#restOptionsGetter" class="headerlink" title="restOptionsGetter()"></a>restOptionsGetter()</h3><p>我们遇到的第一个问题就是restOptionsGetter()函数定义在哪。在NewLegacyRESTStorage()中，restOptionsGetter是以参数的形式传入的; NewLegacyRESTStorage()会被/pkg/master/master.go中的InstallLegacyAPI()方法调用，restOptionsGetter仍是以参数的形式传入；InstallLegacyAPI()会被/pkg/master/master.go中的New()调用，在New()上有restOptionsFactory的定义，可以看出，storageDecorator为registry.StorageWithCacher或generic.UndecoratedStorage。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//***生成restOptionsFactory***//</span></div><div class="line">restOptionsFactory := restOptionsFactory&#123;</div><div class="line">	deleteCollectionWorkers: c.DeleteCollectionWorkers,</div><div class="line">	enableGarbageCollect ion: c.GenericConfig.EnableGarbageCollection,</div><div class="line">	storageFactory:          c.StorageFactory,</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//***赋值storageDecorator***//</span></div><div class="line"><span class="keyword">if</span> c.EnableWatchCache &#123;</div><div class="line">	restOptionsFactory.storageDecorator = registry.StorageWithCacher</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	restOptionsFactory.storageDecorator = generic.UndecoratedStorage</div><div class="line">&#125;</div><div class="line">......</div><div class="line">	</div><div class="line">m.InstallLegacyAPI(c.Config, restOptionsFactory.NewFor, legacyRESTStorageProvider)</div></pre></td></tr></table></figure></p>
<p>所以restOptionsGetter就是restOptionsFactory的NewFor()方法，定义在/pkg/master/master.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f restOptionsFactory)</span> <span class="title">NewFor</span><span class="params">(resource unversioned.GroupResource)</span> <span class="title">generic</span>.<span class="title">RESTOptions</span></span> &#123;</div><div class="line">	<span class="comment">//***获取storageConfig***//</span></div><div class="line">	storageConfig, err := f.storageFactory.NewConfig(resource)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		glog.Fatalf(<span class="string">"Unable to find storage destination for %v, due to %v"</span>, resource, err.Error())</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> generic.RESTOptions&#123;</div><div class="line">		StorageConfig: storageConfig,</div><div class="line">		Decorator:               f.storageDecorator,</div><div class="line">		DeleteCollectionWorkers: f.deleteCollectionWorkers,</div><div class="line">		EnableGarbageCollection: f.enableGarbageCollection,</div><div class="line">		ResourcePrefix:          f.storageFactory.ResourcePrefix(resource),</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>NewFor()会生成一个generic.RESTOptions。这里还需要注意下，generic.RESTOptions中的Decorator一般情况下就是generic.UndercoratedStorage()方法。</p>
<h3 id="NewStorage"><a href="#NewStorage" class="headerlink" title="NewStorage()"></a>NewStorage()</h3><p>node的NewStorage()定义在/pkg/registry/core/node/etcd/etcd.go中，主要流程如下：</p>
<ol>
<li>生成ETCD helper(现在只需知道ETCD helper是对ETCD client的封装即可)，使用opts.Decorator()生成，即registry.StorageWithCacher()或generic.UndercoratedStorage()方法，这些将在以后分析；</li>
<li>生成store，store为genericStore，store中包含ETCD helper；</li>
<li>生成nodeREST;</li>
<li>生成NodeStorage。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NewStorage returns a NodeStorage object that will work against nodes.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStorage</span><span class="params">(opts generic.RESTOptions, kubeletClientConfig client.KubeletClientConfig, proxyTransport http.RoundTripper)</span> <span class="params">(*NodeStorage, error)</span></span> &#123;</div><div class="line">	prefix := <span class="string">"/"</span> + opts.ResourcePrefix</div><div class="line"></div><div class="line">	newListFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">runtime</span>.<span class="title">Object</span></span> &#123; <span class="keyword">return</span> &amp;api.NodeList&#123;&#125; &#125;</div><div class="line">	<span class="comment">//***生成etcd client***//</span></div><div class="line">	storageInterface, dFunc := opts.Decorator(</div><div class="line">		opts.StorageConfig,</div><div class="line">		cachesize.GetWatchCacheSizeByResource(cachesize.Nodes),</div><div class="line">		&amp;api.Node&#123;&#125;,</div><div class="line">		prefix,</div><div class="line">		node.Strategy,</div><div class="line">		newListFunc,</div><div class="line">		node.NodeNameTriggerFunc)</div><div class="line"></div><div class="line">	<span class="comment">//***store为registry包中的store，定义在/pkg/registry/generic/registry/store.go中***//</span></div><div class="line">	store := &amp;registry.Store&#123;</div><div class="line">		NewFunc:     <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">runtime</span>.<span class="title">Object</span></span> &#123; <span class="keyword">return</span> &amp;api.Node&#123;&#125; &#125;,</div><div class="line">		NewListFunc: newListFunc,</div><div class="line">		KeyRootFunc: <span class="function"><span class="keyword">func</span><span class="params">(ctx api.Context)</span> <span class="title">string</span></span> &#123;</div><div class="line">			<span class="keyword">return</span> prefix</div><div class="line">		&#125;,</div><div class="line">		<span class="comment">//***KeyFunc***//</span></div><div class="line">		KeyFunc: <span class="function"><span class="keyword">func</span><span class="params">(ctx api.Context, name <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</div><div class="line">			<span class="keyword">return</span> registry.NoNamespaceKeyFunc(ctx, prefix, name)</div><div class="line">		&#125;,</div><div class="line">		ObjectNameFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj runtime.Object)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</div><div class="line">			<span class="keyword">return</span> obj.(*api.Node).Name, <span class="literal">nil</span></div><div class="line">		&#125;,</div><div class="line">		PredicateFunc:           node.MatchNode,</div><div class="line">		QualifiedResource:       api.Resource(<span class="string">"nodes"</span>),</div><div class="line">		EnableGarbageCollection: opts.EnableGarbageCollection,</div><div class="line">		DeleteCollectionWorkers: opts.DeleteCollectionWorkers,</div><div class="line"></div><div class="line">		CreateStrategy: node.Strategy,</div><div class="line">		UpdateStrategy: node.Strategy,</div><div class="line">		DeleteStrategy: node.Strategy,</div><div class="line">		ExportStrategy: node.Strategy,</div><div class="line"></div><div class="line">		Storage:     storageInterface,</div><div class="line">		DestroyFunc: dFunc,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	statusStore := *store</div><div class="line">	statusStore.UpdateStrategy = node.StatusStrategy</div><div class="line"></div><div class="line">	<span class="comment">// Set up REST handlers</span></div><div class="line">	<span class="comment">//***生成nodeREST***//</span></div><div class="line">	nodeREST := &amp;REST&#123;Store: store, proxyTransport: proxyTransport&#125;</div><div class="line">	<span class="comment">//***生成statusREST***//</span></div><div class="line">	statusREST := &amp;StatusREST&#123;store: &amp;statusStore&#125;</div><div class="line">	<span class="comment">//***生成proxyREST***//</span></div><div class="line">	proxyREST := &amp;noderest.ProxyREST&#123;Store: store, ProxyTransport: proxyTransport&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Build a NodeGetter that looks up nodes using the REST handler</span></div><div class="line">	nodeGetter := client.NodeGetterFunc(<span class="function"><span class="keyword">func</span><span class="params">(nodeName <span class="keyword">string</span>)</span> <span class="params">(*api.Node, error)</span></span> &#123;</div><div class="line">		obj, err := nodeREST.Get(api.NewContext(), nodeName)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">		&#125;</div><div class="line">		node, ok := obj.(*api.Node)</div><div class="line">		<span class="keyword">if</span> !ok &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unexpected type %T"</span>, obj)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> node, <span class="literal">nil</span></div><div class="line">	&#125;)</div><div class="line">	connectionInfoGetter, err := client.NewNodeConnectionInfoGetter(nodeGetter, kubeletClientConfig)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	nodeREST.connection = connectionInfoGetter</div><div class="line">	proxyREST.Connection = connectionInfoGetter</div><div class="line"></div><div class="line">	<span class="keyword">return</span> &amp;NodeStorage&#123;</div><div class="line">		Node:   nodeREST,</div><div class="line">		Status: statusREST,</div><div class="line">		Proxy:  proxyREST,</div><div class="line">		KubeletConnectionInfo: connec   tionInfoGetter,</div><div class="line">	&#125;, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，NodeStorage本质是一个genericStore，关于Store，将在以后分析，现在只需知道Store中定义有Create(), Delete(), Get(), List(), Watch()等方法。</p>
<h3 id="NewRegistry"><a href="#NewRegistry" class="headerlink" title="NewRegistry()"></a>NewRegistry()</h3><p>现在再来看来registry。registry是对storage的封装，可以更方便的增删查改ETCD中的对象。APIServer中的restHandler使用人是更通用的Storage中的方法对对象进行增删查改，感觉只有ApiServer中会使用registry，特别是在APIServer的controller(实现创建default和kube-system空间及default下kubernetes服务)中。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Registry <span class="keyword">interface</span> &#123;</div><div class="line">	ListNodes(ctx api.Context, options *api.ListOptions) (*api.NodeList, error)</div><div class="line">	CreateNode(ctx api.Context, node *api.Node) error</div><div class="line">	UpdateNode(ctx api.Context, node *api.Node) error</div><div class="line">	GetNode(ctx api.Context, nodeID <span class="keyword">string</span>) (*api.Node, error)</div><div class="line">	DeleteNode(ctx api.Context, nodeID <span class="keyword">string</span>) error</div><div class="line">	WatchNodes(ctx api.Context, options *api.ListOptions) (watch.Interface, error)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// storage puts strong typing around storage calls</span></div><div class="line"><span class="keyword">type</span> storage <span class="keyword">struct</span> &#123;</div><div class="line">	rest.StandardStorage</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// NewRegistry returns a new Registry interface for the given Storage. Any mismatched</span></div><div class="line"><span class="comment">// types will panic.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRegistry</span><span class="params">(s rest.StandardStorage)</span> <span class="title">Registry</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> &amp;storage&#123;s&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>NewRegistry()可以生成一个nodeRegistry。nodeRegistry就实现了node的增删查改的方法，如ListNodes(), CreateNode(), UpdateNode(), GetNode(), DeleteNode()和WatchNodes()等方法。</p>
<h2 id="rolesStorage"><a href="#rolesStorage" class="headerlink" title="rolesStorage"></a>rolesStorage</h2><p>role定义在/pkg/registry/rbac/role目录下，我们先来看/pkg/registry/rbac/rest/storage_rbac.go，storage_rabc.go中定义有NewRESTStorage()方法生成apiGroupInfo，NewRESTStorage()会调用v1alpha1Storage()方法，在v1alpha1Storage()中有：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rolesStorage := roleetcd.NewREST(restOptionsGetter(rbac.Resource(<span class="string">"roles"</span>)))</div></pre></td></tr></table></figure></p>
<p>restOptionsGetter已经分析过。</p>
<h3 id="NewREST"><a href="#NewREST" class="headerlink" title="NewREST()"></a>NewREST()</h3><p>rolesStorage的NewREST()定义在/pkg/registry/rbac/role/etcd/etcd.go中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NewREST returns a RESTStorage object that will work against Role objects.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewREST</span><span class="params">(opts generic.RESTOptions)</span> *<span class="title">REST</span></span> &#123;</div><div class="line">	prefix := <span class="string">"/"</span> + opts.ResourcePrefix</div><div class="line"></div><div class="line">	newListFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">runtime</span>.<span class="title">Object</span></span> &#123; <span class="keyword">return</span> &amp;rbac.RoleList&#123;&#125; &#125;</div><div class="line">	storageInterface, dFunc := opts.Decorator(</div><div class="line">		opts.StorageConfig,</div><div class="line">		cachesize.GetWatchCacheSizeByResource(cachesize.Roles),</div><div class="line">		&amp;rbac.Role&#123;&#125;,</div><div class="line">		prefix,</div><div class="line">		role.Strategy,</div><div class="line">		newListFunc,</div><div class="line">		storage.NoTriggerPublisher,</div><div class="line">	)</div><div class="line"></div><div class="line">	store := &amp;registry.Store&#123;</div><div class="line">		NewFunc:     <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">runtime</span>.<span class="title">Object</span></span> &#123; <span class="keyword">return</span> &amp;rbac.Role&#123;&#125; &#125;,</div><div class="line">		NewListFunc: newListFunc,</div><div class="line">		KeyRootFunc: <span class="function"><span class="keyword">func</span><span class="params">(ctx api.Context)</span> <span class="title">string</span></span> &#123;</div><div class="line">			<span class="keyword">return</span> registry.NamespaceKeyRootFunc(ctx, prefix)</div><div class="line">		&#125;,</div><div class="line">		KeyFunc: <span class="function"><span class="keyword">func</span><span class="params">(ctx api.Context, id <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</div><div class="line">			<span class="keyword">return</span> registry.NamespaceKeyFunc(ctx, prefix, id)</div><div class="line">		&#125;,</div><div class="line">		ObjectNameFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj runtime.Object)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</div><div class="line">			<span class="keyword">return</span> obj.(*rbac.Role).Name, <span class="literal">nil</span></div><div class="line">		&#125;,</div><div class="line">		PredicateFunc:           role.Matcher,</div><div class="line">		QualifiedResource:       rbac.Resource(<span class="string">"roles"</span>),</div><div class="line">		EnableGarbageCollection: opts.EnableGarbageCollection,</div><div class="line">		DeleteCollectionWorkers: opts.DeleteCollectionWorkers,</div><div class="line"></div><div class="line">		CreateStrategy: role.Strategy,</div><div class="line">		UpdateStrategy: role.Strategy,</div><div class="line">		DeleteStrategy: role.Strategy,</div><div class="line"></div><div class="line">		Storage:     storageInterface,</div><div class="line">		DestroyFunc: dFunc,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> &amp;REST&#123;store&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，roleStorage本质是一个genericStore。</p>
<h3 id="NewRegistry-1"><a href="#NewRegistry-1" class="headerlink" title="NewRegistry()"></a>NewRegistry()</h3><p>NewRegistry()可以生成一个rolesRegistry，rolesRegistry定义有ListRoles(), CreateRole(), UpdateRole(), GetRole(), DeleteRole(), WatchRoles()等方法。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Registry is an interface for things that know how to store Roles.</span></div><div class="line"><span class="keyword">type</span> Registry <span class="keyword">interface</span> &#123;</div><div class="line">	ListRoles(ctx api.Context, options *api.ListOptions) (*rbac.RoleList, error)</div><div class="line">	CreateRole(ctx api.Context, role *rbac.Role) error</div><div class="line">	UpdateRole(ctx api.Context, role *rbac.Role) error</div><div class="line">	GetRole(ctx api.Context, name <span class="keyword">string</span>) (*rbac.Role, error)</div><div class="line">	DeleteRole(ctx api.Context, name <span class="keyword">string</span>) error</div><div class="line">	WatchRoles(ctx api.Context, options *api.ListOptions) (watch.Interface, error)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// storage puts strong typing around storage calls</span></div><div class="line"><span class="keyword">type</span> storage <span class="keyword">struct</span> &#123;</div><div class="line">	rest.StandardStorage</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// NewRegistry returns a new Registry interface for the given Storage. Any mismatched</span></div><div class="line"><span class="comment">// types will panic.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRegistry</span><span class="params">(s rest.StandardStorage)</span> <span class="title">Registry</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> &amp;storage&#123;s&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次分析介绍了Storage和Registry，主要分析了nodeStorage和nodeRegistry，rolesStorage和rolesRegsitry。其中NodeStorage是对generic.Storage的封装，generic.Storage中定义了对ETCD中对象的通用操作；NodeRegistry是对NodeStorage的封装，NodeRegistry定义了关于node的增删查改操作；rolesStorage和rolesRegistry也一样，可以用来操作role。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://fankangbest.github.com/2017/08/07/storage解读(一)-registry-v1-5-2/" data-id="cjagjrcpj0057xkqsetm8iymm" class="article-share-link">分享</a><div class="tags"><a href="/tags/kubernetes/">kubernetes</a><a href="/tags/kubernetes-v1-5-2/">kubernetes-v1.5.2</a></div><div class="post-nav"><a href="/2017/08/08/storage解读(二)-genericStore-v1-5-2/" class="pre">storage解读(二)-genericStore-v1.5.2</a><a href="/2017/08/01/apimachinery机制解读(二)-GroupMetaFactory-v1-5-2/" class="next">apimachinery机制解读(二)-GroupMetaFactory-v1.5.2</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://fankangbest.github.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/GO语言/">GO语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/存储虚拟化/">存储虚拟化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/容器虚拟化/">容器虚拟化</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/containerd-v0-2-4/" style="font-size: 15px;">containerd-v0.2.4</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/docker-v1-12-3/" style="font-size: 15px;">docker-v1.12.3</a> <a href="/tags/GO语言/" style="font-size: 15px;">GO语言</a> <a href="/tags/containerd/" style="font-size: 15px;">containerd</a> <a href="/tags/kubernetes-v1-5-2/" style="font-size: 15px;">kubernetes-v1.5.2</a> <a href="/tags/gRPC/" style="font-size: 15px;">gRPC</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/runc/" style="font-size: 15px;">runc</a> <a href="/tags/runc-v1-0-0-rc2/" style="font-size: 15px;">runc-v1.0.0-rc2</a> <a href="/tags/ceph/" style="font-size: 15px;">ceph</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/11/26/Docker-reexec机制分析-v1-12-3/">Docker-reexec机制分析-v1.12.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/24/containerd-containerd-shim和runc的依存关系/">containerd,containerd-shim和runc的依存关系</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/22/runc源码分析(一)-create和start流程-v1-0-0-rc2/">runc源码分析(一)-create和start流程-v1.0.0-rc2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/19/containerd-shim源码分析-v0-2-4/">containerd-shim源码分析-v0.2.4</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/19/containerd-container和process-v0-2-4/">containerd-container和process-v0.2.4</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/16/containerd执行流程分析-v0-2-4/">containerd执行流程分析-v0.2.4</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/13/containerd-crt命令行使用-v0-2-4/">containerd-crt命令行使用-v0.2.4</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/11/gRPC-demo/">gRPC-demo</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/31/kubernetes-controller分析(四)-garbagecollector-v1-5-2/">kubernetes-controller分析(四)-garbagecollector-v1.5.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/Docker镜像存储代码分析-layerStore-v1-12-3/">Docker镜像存储代码分析-layerStore-v1.12.3</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/fankangbest" title="myGithub" target="_blank">myGithub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">fankangbest.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>